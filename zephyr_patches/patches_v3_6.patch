From 3592b0f11ece89f389d6c0d73110850a0232ef34 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 21 Aug 2023 14:09:40 -0700
Subject: [PATCH 01/42] soc: arm: microchip: mec172x: Add macro to get pin mux
 value

Add macro to read pin mux control value

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 soc/arm/microchip_mec/mec172x/reg/mec172x_gpio.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/soc/arm/microchip_mec/mec172x/reg/mec172x_gpio.h b/soc/arm/microchip_mec/mec172x/reg/mec172x_gpio.h
index 39ed59d27..f013ba69a 100644
--- a/soc/arm/microchip_mec/mec172x/reg/mec172x_gpio.h
+++ b/soc/arm/microchip_mec/mec172x/reg/mec172x_gpio.h
@@ -92,6 +92,9 @@
 #define MCHP_GPIO_CTRL_MUX_F7		SHLU32(7, MCHP_GPIO_CTRL_MUX_POS)
 #define MCHP_GPIO_CTRL_MUX(n) SHLU32(((n) & 0x7u), MCHP_GPIO_CTRL_MUX_POS)
 
+#define MCHP_GPIO_CTRL_MUX_GET(x) (((uint32_t)(x) >> MCHP_GPIO_CTRL_MUX_POS)\
+				& MCHP_GPIO_CTRL_MUX_MASK0)
+
 /*
  * bit[15] Disables input pad leaving output pad enabled
  * Useful for reducing power consumption of output only pins.
-- 
2.17.1


From a0db96f2d008283e575c26dc9d57b52468a5e165 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 21 Aug 2023 14:51:56 -0700
Subject: [PATCH 02/42] drivers: gpio: mec172x: Add message to warn about pins
 not in GPIO mode

Warn about potential device tree errors for cases when driver's
client tries to configure a pin as GPIO but which is not
in GPIO mode.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/gpio/gpio_mchp_xec_v2.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/gpio/gpio_mchp_xec_v2.c b/drivers/gpio/gpio_mchp_xec_v2.c
index 3c89ed79c..67697b1e3 100644
--- a/drivers/gpio/gpio_mchp_xec_v2.c
+++ b/drivers/gpio/gpio_mchp_xec_v2.c
@@ -11,6 +11,7 @@
 #include <zephyr/device.h>
 #include <zephyr/drivers/gpio.h>
 #include <zephyr/dt-bindings/gpio/gpio.h>
+#include <zephyr/logging/log.h>
 #include <zephyr/dt-bindings/pinctrl/mchp-xec-pinctrl.h>
 #include <soc.h>
 #include <zephyr/irq.h>
@@ -19,6 +20,8 @@
 
 #define XEC_GPIO_EDGE_DLY_COUNT		4
 
+LOG_MODULE_REGISTER(gpio, CONFIG_GPIO_LOG_LEVEL);
+
 static const uint32_t valid_ctrl_masks[NUM_MCHP_GPIO_PORTS] = {
 	(MCHP_GPIO_PORT_A_BITMAP),
 	(MCHP_GPIO_PORT_B_BITMAP),
@@ -141,6 +144,12 @@ static int gpio_xec_configure(const struct device *dev,
 	pcr1_addr = pin_ctrl_addr(dev, pin);
 	pcr1 = sys_read32(pcr1_addr);
 
+	/* Check if pin is in GPIO mode */
+	if (MCHP_GPIO_CTRL_MUX_GET(pcr1) != MCHP_GPIO_CTRL_MUX_F0) {
+		LOG_WRN("Port:%d pin:0x%x not in GPIO mode. CTRL[%x]=%x", config->port_num, pin,
+			(uint32_t)pcr1_addr, pcr1);
+	}
+
 	if (flags == GPIO_DISCONNECTED) {
 		pcr1 = (pcr1 & ~MCHP_GPIO_CTRL_PWRG_MASK) | MCHP_GPIO_CTRL_PWRG_OFF;
 		sys_write32(pcr1, pcr1_addr);
-- 
2.17.1


From c2bff70e3fecbf8509a4c08504485d21f29e4875 Mon Sep 17 00:00:00 2001
From: Mulin Chao <mlchao@nuvoton.com>
Date: Tue, 23 Jan 2024 18:43:19 -0800
Subject: [PATCH 03/42] drivers: espi: npcx: add ESPI_OOB_CHANNEL_RX_ASYNC
 support

Add CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC support in npcx espi driver.

Signed-off-by: Mulin Chao <mlchao@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_npcx.c | 25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index fc6712575..628de8426 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -40,7 +40,7 @@ struct espi_npcx_data {
 	uint8_t plt_rst_asserted;
 	uint8_t espi_rst_level;
 	uint8_t sx_state;
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	struct k_sem oob_rx_lock;
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
@@ -295,9 +295,22 @@ static void espi_bus_cfg_update_isr(const struct device *dev)
 static void espi_bus_oob_rx_isr(const struct device *dev)
 {
 	struct espi_npcx_data *const data = dev->data;
+#if defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_event evt = {
+			.evt_type = ESPI_BUS_EVENT_OOB_RECEIVED,
+			.evt_details = 0,
+			.evt_data = 0,
+		};
+
+	/* Get received package length and set to additional detail of event */
+	evt.evt_details = NPCX_OOB_RX_PACKAGE_LEN(inst->OOBRXBUF[0]);
+	espi_send_callbacks(&data->callbacks, dev, evt);
+#else
 
 	LOG_DBG("%s", __func__);
 	k_sem_give(&data->oob_rx_lock);
+#endif
 }
 #endif
 
@@ -915,15 +928,14 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		return -EIO;
 	}
 
-	/* Notify host that OOB received buffer is free now. */
-	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
-
+#if !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	/* Wait until get oob package or timeout */
 	ret = k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT));
 	if (ret == -EAGAIN) {
 		LOG_ERR("%s: Timeout", __func__);
 		return -ETIMEDOUT;
 	}
+#endif
 
 	/*
 	 * PUT_OOB header (first 4 bytes) in npcx 32-bits rx buffer
@@ -965,6 +977,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		for (i = 0; i < sz_oob_rx % 4; i++)
 			*(oob_buf++) = (oob_data >> (8 * i)) & 0xFF;
 	}
+
+	/* Notify host that OOB received buffer is free now. */
+	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
 	return 0;
 }
 #endif
@@ -1316,7 +1331,7 @@ static int espi_npcx_init(const struct device *dev)
 		inst->ESPIWE |= BIT(espi_bus_isr_tbl[i].wake_en_bit);
 	}
 
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	k_sem_init(&data->oob_rx_lock, 0, 1);
 #endif
 
-- 
2.17.1


From 9b8d9300e303aefb22c32060b11c72d5d3287a6c Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Tue, 5 Mar 2024 11:15:37 +0800
Subject: [PATCH 04/42] drivers: espi: npcx: workaround Global Reset issue

Apply the workaround for the issue "eSPI global reset" in the
NPCX49nF_Errata

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig.npcx |  6 ++++++
 drivers/espi/espi_npcx.c  | 43 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 49 insertions(+)

diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index 3f1d511ca..d746d89f9 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -118,4 +118,10 @@ config ESPI_NPCX_SUPP_VW_GPIO
 	help
 	  Selected if NPCX series supports virtual wire GPIOs in eSPI module.
 
+config ESPI_NPCX_CAF_GLOBAL_RESET_WORKAROUND
+	bool
+	default y if SOC_SERIES_NPCX4 && ESPI_FLASH_CHANNEL
+	help
+	  Workaround the issue "Global Reset" in the npcx4 SoC errata.
+
 endif #ESPI_NPCX
diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 628de8426..d506c1ec9 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -46,6 +46,10 @@ struct espi_npcx_data {
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
 	struct k_sem flash_rx_lock;
 #endif
+#ifdef CONFIG_ESPI_NPCX_CAF_GLOBAL_RESET_WORKAROUND
+	/* tell the interrupt handler that it is a fake request */
+	bool fake_req_flag;
+#endif
 };
 
 /* Driver convenience defines */
@@ -190,6 +194,13 @@ static int espi_npcx_send_vwire(const struct device *dev,
 			enum espi_vwire_signal signal, uint8_t level);
 static void espi_vw_send_bootload_done(const struct device *dev);
 
+#if defined(CONFIG_ESPI_FLASH_CHANNEL)
+static int espi_npcx_flash_parse_completion_with_data(const struct device *dev,
+						      struct espi_flash_packet *pckt);
+static void espi_npcx_flash_prepare_tx_header(const struct device *dev, int cyc_type,
+					      int flash_addr, int flash_len, int tx_payload);
+#endif
+
 /* eSPI local initialization functions */
 static void espi_init_wui_callback(const struct device *dev,
 		struct miwu_callback *callback, const struct npcx_wui *wui,
@@ -232,6 +243,20 @@ static void espi_bus_reset_isr(const struct device *dev)
 	/* Do nothing! This signal is handled in ESPI_RST VW signal ISR */
 }
 
+#if defined(CONFIG_ESPI_NPCX_CAF_GLOBAL_RESET_WORKAROUND)
+static void espi_npcx_flash_fake_request(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_npcx_data *const data = dev->data;
+
+	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_AMTEN);
+
+	data->fake_req_flag = true;
+
+	espi_npcx_flash_prepare_tx_header(dev, ESPI_FLASH_READ_CYCLE_TYPE, 0, 16, 0);
+}
+#endif
+
 static void espi_bus_cfg_update_isr(const struct device *dev)
 {
 	int chan;
@@ -259,6 +284,13 @@ static void espi_bus_cfg_update_isr(const struct device *dev)
 						NPCX_ESPI_HOST_CH_EN(chan));
 			evt.evt_details = BIT(chan);
 
+#if defined(CONFIG_ESPI_NPCX_CAF_GLOBAL_RESET_WORKAROUND)
+			if (chan == NPCX_ESPI_CH_FLASH && evt.evt_data == 1 &&
+			    IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
+				espi_npcx_flash_fake_request(dev);
+			}
+#endif
+
 			if (evt.evt_data) {
 				inst->ESPICFG |= BIT(chan);
 			} else {
@@ -358,6 +390,17 @@ static void espi_bus_flash_rx_isr(const struct device *dev)
 
 	/* Controller Attached Flash Access */
 	if ((inst->ESPICFG & BIT(NPCX_ESPICFG_FLCHANMODE)) == 0) {
+#ifdef CONFIG_ESPI_NPCX_CAF_GLOBAL_RESET_WORKAROUND
+		if (data->fake_req_flag == true) {
+			uint8_t pckt_buf[16];
+			struct espi_flash_packet pckt;
+
+			pckt.buf = &pckt_buf[0];
+			espi_npcx_flash_parse_completion_with_data(dev, &pckt);
+			data->fake_req_flag = false;
+			return;
+		}
+#endif
 		k_sem_give(&data->flash_rx_lock);
 	} else { /* Target Attached Flash Access */
 #if defined(CONFIG_ESPI_SAF)
-- 
2.17.1


From a88028125521561b0b468b06297202ffbc9752c4 Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Tue, 9 Apr 2024 14:15:26 +0800
Subject: [PATCH 05/42] drivers: espi: npcx: support multi-byte for dp80

This CL adds multi-byte support for debug port 80 on npcx4.

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig.npcx | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index d746d89f9..d67f1a481 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -45,7 +45,7 @@ config ESPI_NPCX_BYPASS_CH_ENABLE_FATAL_ERROR
 
 config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
 	bool "Host can write 1/2/4 bytes of Port80 data in a eSPI transaction"
-	depends on SOC_SERIES_NPCX9 && ESPI_PERIPHERAL_DEBUG_PORT_80
+	depends on (SOC_SERIES_NPCX9 || SOC_SERIES_NPCX4) && ESPI_PERIPHERAL_DEBUG_PORT_80
 	help
 	  EC can accept 1/2/4 bytes of Port 80 data written from the Host in an
 	  eSPI transaction.
-- 
2.17.1


From 30817d34cb3f0069d5c84bebd4ede3b155930ef3 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Mon, 6 May 2024 15:42:54 +0800
Subject: [PATCH 06/42] pinctrl: npcx: add nodes for Serial Port SIO clock
 selection

This commits adds required pinctrl node to provide the corresponding SIO
clock selection for the Serial Port under the different VOSCCLK.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
---
 dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi | 16 ++++++++++++++++
 dts/arm/nuvoton/npcx/npcx7/npcx7-pinctrl.dtsi |  8 ++++++++
 dts/arm/nuvoton/npcx/npcx9/npcx9-pinctrl.dtsi |  8 ++++++++
 3 files changed, 32 insertions(+)

diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
index af45fa59d..ec9979c70 100644
--- a/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
@@ -30,6 +30,22 @@
 		dev-ctl = <0x0 6 1 0x01>;
 	};
 
+	/omit-if-no-ref/ sio_clk_sel_96m: devctl3-sio-clk_sel-96m {
+		dev-ctl = <0x4 6 2 0x00>;
+	};
+
+	/omit-if-no-ref/ sio_clk_sel_100: devctl3-sio-clk_sel-100m {
+		dev-ctl = <0x4 6 2 0x01>;
+	};
+
+	/omit-if-no-ref/ sio_clk_sel_120m: devctl3-sio-clk_sel-120m {
+		dev-ctl = <0x4 6 2 0x02>;
+	};
+
+	/omit-if-no-ref/ sio_clk_sel_90m: devctl3-sio-clk_sel-90m {
+		dev-ctl = <0x4 6 2 0x03>;
+	};
+
 	/* Prebuild nodes for peripheral device's pin-muxing and pad properties */
 	/* Flash Interface Unit (FIU) */
 	/omit-if-no-ref/ fiu_ext_io0_io1_clk_cs_gpa4_96_a2_a0: periph-fiu-ext {
diff --git a/dts/arm/nuvoton/npcx/npcx7/npcx7-pinctrl.dtsi b/dts/arm/nuvoton/npcx/npcx7/npcx7-pinctrl.dtsi
index 2b219c48e..35a404118 100644
--- a/dts/arm/nuvoton/npcx/npcx7/npcx7-pinctrl.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx7/npcx7-pinctrl.dtsi
@@ -22,6 +22,14 @@
 		dev-ctl = <0x0 6 1 0x01>;
 	};
 
+	/omit-if-no-ref/ sio_full_ck48: devctl4-sio-full-ck48 {
+		dev-ctl = <0x6 3 1 0x00>;
+	};
+
+	/omit-if-no-ref/ sio_full_ck50: devctl4-sio-full-ck50 {
+		dev-ctl = <0x6 3 1 0x01>;
+	};
+
 	/* Prebuild nodes for peripheral device's pin-muxing and pad properties */
 	/* Flash Interface Unit (FIU) */
 	/omit-if-no-ref/ fiu_ext_io0_io1_clk_cs_gpa4_96_a2_a0: periph-fiu-ext {
diff --git a/dts/arm/nuvoton/npcx/npcx9/npcx9-pinctrl.dtsi b/dts/arm/nuvoton/npcx/npcx9/npcx9-pinctrl.dtsi
index 2ba0b78fd..583b5352f 100644
--- a/dts/arm/nuvoton/npcx/npcx9/npcx9-pinctrl.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx9/npcx9-pinctrl.dtsi
@@ -23,6 +23,14 @@
 		dev-ctl = <0x0 6 1 0x01>;
 	};
 
+	/omit-if-no-ref/ sio_full_ck48: devctl4-sio-full-ck48 {
+		dev-ctl = <0x6 3 1 0x00>;
+	};
+
+	/omit-if-no-ref/ sio_full_ck50: devctl4-sio-full-ck50 {
+		dev-ctl = <0x6 3 1 0x01>;
+	};
+
 	/* Prebuild nodes for peripheral device's pin-muxing and pad properties */
 	/* Flash Interface Unit (FIU) */
 	/omit-if-no-ref/ fiu_ext_io0_io1_clk_cs_gpa4_96_a2_a0: periph-fiu-ext {
-- 
2.17.1


From 8b7001eb493f21e9cbe00de49ccf5ba9639d6aea Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Mon, 6 May 2024 15:43:09 +0800
Subject: [PATCH 07/42] driver: espi: npcx: enable the Serial Port

Initialize and enable the Serial Port/Host UART when
CONFIG_ESPI_PERIPHERAL_UART=y.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/host_subs_npcx.c | 38 ++++++++++++++++++++++++++++++-----
 1 file changed, 33 insertions(+), 5 deletions(-)

diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index 418106666..51802586c 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -191,6 +191,7 @@ struct host_sub_npcx_data host_sub_data;
 #define NPCX_C2H_TRANSACTION_TIMEOUT_US 200
 
 /* Logical Device Number Assignments */
+#define EC_CFG_LDN_SP    0x03
 #define EC_CFG_LDN_MOUSE 0x05
 #define EC_CFG_LDN_KBC   0x06
 #define EC_CFG_LDN_SHM   0x0F
@@ -205,6 +206,13 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_IDX_DATA_IO_ADDR_H  0x62
 #define EC_CFG_IDX_DATA_IO_ADDR_L  0x63
 
+/* LDN Activation Enable */
+#define EC_CFG_IDX_CTRL_LDN_ENABLE 0x01
+
+/* Index of SuperI/O Control and Configuration Registers */
+#define EC_CFG_IDX_SUPERIO_SIOCF9      0x29
+#define EC_CFG_IDX_SUPERIO_SIOCF9_CKEN 2
+
 /* Index of Special Logical Device Configuration (Shared Memory Module) */
 #define EC_CFG_IDX_SHM_CFG             0xF1
 #define EC_CFG_IDX_SHM_WND1_ADDR_0     0xF4
@@ -217,6 +225,11 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_IDX_SHM_WND2_ADDR_3     0xFB
 #define EC_CFG_IDX_SHM_DP80_ADDR_RANGE 0xFD
 
+/* Index of Special Logical Device Configuration (Serial Port/Host UART) */
+#define EC_CFG_IDX_SP_CFG              0xF0
+/* Enable selection of bank 2 and 3 for the Serial Port */
+#define EC_CFG_IDX_SP_CFG_BK_SL_ENABLE 7
+
 /* Host sub-device local inline functions */
 static inline uint8_t host_shd_mem_wnd_size_sl(uint32_t size)
 {
@@ -995,10 +1008,10 @@ void npcx_host_init_subs_host_domain(void)
 		 * modules by setting bit 0 in its Control (index is 0x30) reg.
 		 */
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_KBC);
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_MOUSE);
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 	}
 
 	if (IS_ENABLED(CONFIG_ESPI_PERIPHERAL_HOST_IO)) {
@@ -1007,7 +1020,7 @@ void npcx_host_init_subs_host_domain(void)
 		 * module by setting bit 0 in its Control (index is 0x30) reg.
 		 */
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_ACPI);
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 	}
 
 	if (IS_ENABLED(CONFIG_ESPI_PERIPHERAL_EC_HOST_CMD) ||
@@ -1028,7 +1041,7 @@ void npcx_host_init_subs_host_domain(void)
 		 (CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM + 4) & 0xff);
 #endif
 		/* Enable 'Host Command' io port (PM Channel 2) */
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 
 		/* Select 'Shared Memory' bank which LDN are 0x0F */
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_SHM);
@@ -1053,8 +1066,23 @@ void npcx_host_init_subs_host_domain(void)
 			host_c2h_write_io_cfg_reg(EC_CFG_IDX_SHM_DP80_ADDR_RANGE, 0x0f);
 		}
 	/* Enable SHM direct memory access */
-	host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
+	host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 	}
+
+	if (IS_ENABLED(CONFIG_ESPI_PERIPHERAL_UART)) {
+		/* Select Serial Port banks which LDN are 0x03. */
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_SP);
+		/* Enable SIO_CLK */
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_SUPERIO_SIOCF9,
+					  host_c2h_read_io_cfg_reg(EC_CFG_IDX_SUPERIO_SIOCF9) |
+						  BIT(EC_CFG_IDX_SUPERIO_SIOCF9_CKEN));
+		/* Enable Bank Select */
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_SP_CFG,
+					  host_c2h_read_io_cfg_reg(EC_CFG_IDX_SP_CFG) |
+						  BIT(EC_CFG_IDX_SP_CFG_BK_SL_ENABLE));
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
+	}
+
 	LOG_DBG("Hos sub-modules configurations are done!");
 }
 
-- 
2.17.1


From c7806332927c35c39fa85828aaf454871d6f88d9 Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Mon, 22 Apr 2024 18:18:24 +0800
Subject: [PATCH 08/42] drivers: espi: npcx: update espi taf driver

This CL updates the read, write, erase, and get_channel_status
implementations of NPCX chip.

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
---
 drivers/espi/espi_npcx.c                   |  31 +--
 drivers/espi/espi_taf_npcx.c               | 221 +++++++++++++++------
 soc/arm/nuvoton_npcx/common/soc_espi_taf.h |   2 +
 3 files changed, 165 insertions(+), 89 deletions(-)

diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index d506c1ec9..89d46c367 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -363,7 +363,7 @@ static uint32_t espi_taf_parse(const struct device *dev)
 	taf_pckt.len = (((uint16_t)taf_head.tag_hlen & 0xF) << 8) | taf_head.llen;
 	taf_pckt.tag = taf_head.tag_hlen >> 4;
 
-	if ((taf_pckt.len == 0) && ((taf_pckt.type & 0xF) == NPCX_ESPI_TAF_REQ_READ)) {
+	if ((taf_pckt.len == 0) && (taf_pckt.type == NPCX_ESPI_TAF_REQ_READ)) {
 		taf_pckt.len = KB(4);
 	}
 
@@ -372,7 +372,7 @@ static uint32_t espi_taf_parse(const struct device *dev)
 	taf_pckt.addr = sys_cpu_to_be32(taf_addr);
 
 	/* Get written data if eSPI TAF write */
-	if ((taf_pckt.type & 0xF) == NPCX_ESPI_TAF_REQ_WRITE) {
+	if (taf_pckt.type == NPCX_ESPI_TAF_REQ_WRITE) {
 		roundsize = DIV_ROUND_UP(taf_pckt.len, sizeof(uint32_t));
 		for (i = 0; i < roundsize; i++) {
 			taf_pckt.src[i] = inst->FLASHRXBUF[2 + i];
@@ -415,27 +415,7 @@ static void espi_bus_flash_rx_isr(const struct device *dev)
 #endif
 	}
 }
-
-static void espi_bus_completion_sent_isr(const struct device *dev)
-{
-	struct espi_reg *const inst = HAL_INSTANCE(dev);
-
-	/* check that ESPISTS.FLNACS is clear. */
-	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS)) {
-		LOG_ERR("ESPISTS_FLNACS not clear\r\n");
-	}
-
-	/* flash operation is done, Make sure the TAFS transmit buffer is empty */
-	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
-		LOG_ERR("FLASH_TX_AVAIL not clear\r\n");
-	}
-
-	/* In auto mode, release FLASH_NP_FREE here to get next SAF request.*/
-	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_SAF_AUTO_READ)) {
-		inst->FLASHCTL |= BIT(NPCX_FLASHCTL_FLASH_NP_FREE);
-	}
-}
-#endif
+#endif /* CONFIG_ESPI_FLASH_CHANNEL */
 
 const struct espi_bus_isr espi_bus_isr_tbl[] = {
 	NPCX_ESPI_BUS_INT_ITEM(BERR, espi_bus_err_isr),
@@ -447,7 +427,6 @@ const struct espi_bus_isr espi_bus_isr_tbl[] = {
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
 	NPCX_ESPI_BUS_INT_ITEM(FLASHRX, espi_bus_flash_rx_isr),
-	NPCX_ESPI_BUS_INT_ITEM(FLNACS, espi_bus_completion_sent_isr),
 #endif
 };
 
@@ -1414,6 +1393,10 @@ static int espi_npcx_init(const struct device *dev)
 	/* Configure host sub-modules which HW blocks belong to core domain */
 	npcx_host_init_subs_core_domain(dev, &data->callbacks);
 
+#if defined(CONFIG_ESPI_FLASH_CHANNEL) && defined(CONFIG_ESPI_SAF)
+	npcx_init_taf(dev, &data->callbacks);
+#endif
+
 	/* eSPI Bus interrupt installation */
 	IRQ_CONNECT(DT_INST_IRQN(0),
 		    DT_INST_IRQ(0, priority),
diff --git a/drivers/espi/espi_taf_npcx.c b/drivers/espi/espi_taf_npcx.c
index 722b26730..c1760f7ad 100644
--- a/drivers/espi/espi_taf_npcx.c
+++ b/drivers/espi/espi_taf_npcx.c
@@ -17,6 +17,14 @@ LOG_MODULE_REGISTER(espi_taf, CONFIG_ESPI_LOG_LEVEL);
 
 static const struct device *const spi_dev = DEVICE_DT_GET(DT_ALIAS(taf_flash));
 
+enum ESPI_TAF_ERASE_LEN {
+	NPCX_ESPI_TAF_ERASE_LEN_4KB,
+	NPCX_ESPI_TAF_ERASE_LEN_32KB,
+	NPCX_ESPI_TAF_ERASE_LEN_64KB,
+	NPCX_ESPI_TAF_ERASE_LEN_128KB,
+	NPCX_ESPI_TAF_ERASE_LEN_MAX,
+};
+
 struct espi_taf_npcx_config {
 	uintptr_t base;
 	uintptr_t mapped_addr;
@@ -26,9 +34,19 @@ struct espi_taf_npcx_config {
 };
 
 struct espi_taf_npcx_data {
-	sys_slist_t callbacks;
+	sys_slist_t *callbacks;
+	const struct device *host_dev;
+	uint8_t taf_type;
+	uint8_t taf_tag;
+	uint32_t address;
+	uint16_t length;
+	uint32_t src[16];
+	struct k_work work;
 };
 
+static struct espi_taf_npcx_data npcx_espi_taf_data;
+static struct espi_callback espi_taf_cb;
+
 #define HAL_INSTANCE(dev)						\
 	((struct espi_reg *)((const struct espi_taf_npcx_config *)	\
 	(dev)->config)->base)
@@ -45,6 +63,24 @@ struct espi_taf_npcx_data {
 	GET_FIELD(inst->FLASH_PRTR_HADDR[i], NPCX_FLASH_PRTR_HADDR)	\
 	<< GET_FIELD_POS(NPCX_FLASH_PRTR_HADDR)) | 0xFFF;
 
+static void espi_taf_get_pckt(const struct device *dev, struct espi_taf_npcx_data *pckt,
+			      struct espi_event event)
+{
+	struct espi_taf_pckt *data_ptr;
+
+	data_ptr = (struct espi_taf_pckt *)event.evt_data;
+
+	pckt->taf_type = data_ptr->type;
+	pckt->length = data_ptr->len;
+	pckt->taf_tag = data_ptr->tag;
+	pckt->address = data_ptr->addr;
+
+	if (data_ptr->type == NPCX_ESPI_TAF_REQ_WRITE) {
+		memcpy(pckt->src, data_ptr->src, sizeof(pckt->src));
+	}
+}
+
+#if defined(CONFIG_ESPI_TAF_MANUAL_MODE)
 /* Check access region of read request is protected or not */
 static bool espi_taf_check_read_protect(const struct device *dev, uint32_t addr, uint32_t len,
 					uint8_t tag)
@@ -73,6 +109,7 @@ static bool espi_taf_check_read_protect(const struct device *dev, uint32_t addr,
 
 	return false;
 }
+#endif
 
 /* Check access region of write request is protected or not */
 static bool espi_taf_check_write_protect(const struct device *dev, uint32_t addr,
@@ -107,11 +144,16 @@ static int espi_taf_npcx_configure(const struct device *dev, const struct espi_s
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
 
+	if (cfg->nflash_devices == 0U) {
+		return -EINVAL;
+	}
+
 #if defined(CONFIG_ESPI_TAF_AUTO_MODE)
 	inst->FLASHCTL |= BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
 #else
 	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
 #endif
+
 	return 0;
 }
 
@@ -173,10 +215,17 @@ static int espi_taf_npcx_activate(const struct device *dev)
 static bool espi_taf_npcx_channel_ready(const struct device *dev)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint8_t ret =
+		GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLCAPA) & NPCX_FLASH_SHARING_CAP_SUPP_TAF;
 
-	if (!IS_BIT_SET(inst->ESPICFG, NPCX_ESPICFG_FLCHANMODE)) {
+	if (ret != NPCX_FLASH_SHARING_CAP_SUPP_TAF) {
 		return false;
 	}
+
+	if (!device_is_ready(spi_dev)) {
+		return false;
+	}
+
 	return true;
 }
 
@@ -214,52 +263,58 @@ static void taf_release_flash_np_free(const struct device *dev)
 	inst->FLASHCTL = tmp;
 }
 
-static int taf_npcx_completion_handler(const struct device *dev, uint32_t *buffer)
+static int taf_npcx_completion_handler(const struct device *dev, uint8_t type, uint8_t tag,
+				       uint16_t len, uint32_t *buffer)
 {
-	uint16_t size = DIV_ROUND_UP((uint8_t)(buffer[0]) + 1, sizeof(uint32_t));
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
-	struct npcx_taf_head *head = (struct npcx_taf_head *)buffer;
-	uint8_t i;
+	struct npcx_taf_head taf_head;
+	uint16_t i, size;
+	uint32_t tx_buf[16];
+
+	taf_head.pkt_len = NPCX_TAF_CMP_HEADER_LEN + len;
+	taf_head.type = type;
+	taf_head.tag_hlen = (tag << 4) | ((len & 0xF00) >> 8);
+	taf_head.llen = len & 0xFF;
+
+	memcpy(&tx_buf[0], &taf_head, sizeof(struct npcx_taf_head));
+
+	if (type == CYC_SCS_CMP_WITH_DATA_ONLY || type == CYC_SCS_CMP_WITH_DATA_FIRST ||
+	    type == CYC_SCS_CMP_WITH_DATA_MIDDLE || type == CYC_SCS_CMP_WITH_DATA_LAST) {
+		memcpy(&tx_buf[1], buffer, (uint8_t)(len));
+	}
 
 	/* Check the Flash Access TX Queue is empty by polling
 	 * FLASH_TX_AVAIL.
 	 */
-	if (WAIT_FOR(IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL),
-		     NPCX_FLASH_CHK_TIMEOUT, NULL)) {
+	if (WAIT_FOR(!IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL),
+		     NPCX_FLASH_CHK_TIMEOUT, NULL) == false) {
 		LOG_ERR("Check TX Queue Is Empty Timeout");
 		return -EBUSY;
 	}
 
-	/* Check ESPISTS.FLNACS is clear (no slave completion is detected) */
-	if (WAIT_FOR(IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS),
-		     NPCX_FLASH_CHK_TIMEOUT, NULL)) {
-		LOG_ERR("Check Slave Completion Timeout");
-		return -EBUSY;
-	}
-
 	/* Write packet to FLASHTXBUF */
+	size = DIV_ROUND_UP((uint8_t)(tx_buf[0]) + 1, sizeof(uint32_t));
 	for (i = 0; i < size; i++) {
-		inst->FLASHTXBUF[i] = buffer[i];
+		inst->FLASHTXBUF[i] = tx_buf[i];
 	}
 
 	/* Set the FLASHCTL.FLASH_TX_AVAIL bit to 1 to enqueue the packet */
 	taf_set_flash_c_avail(dev);
 
 	/* Release FLASH_NP_FREE here to ready get next TAF request */
-	if ((head->type != CYC_SCS_CMP_WITH_DATA_FIRST) &&
-	    (head->type != CYC_SCS_CMP_WITH_DATA_MIDDLE)) {
+	if ((type != CYC_SCS_CMP_WITH_DATA_FIRST) && (type != CYC_SCS_CMP_WITH_DATA_MIDDLE)) {
 		taf_release_flash_np_free(dev);
 	}
 
 	return 0;
 }
 
+#if defined(CONFIG_ESPI_TAF_MANUAL_MODE)
 static int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_packet *pckt)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
 	struct espi_taf_npcx_config *config = ((struct espi_taf_npcx_config *)(dev)->config);
 	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
-	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
 	uint8_t cycle_type = CYC_SCS_CMP_WITH_DATA_ONLY;
 	uint32_t total_len = pckt->len;
 	uint32_t len = total_len;
@@ -267,7 +322,7 @@ static int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_pa
 	uint8_t flash_req_size = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLASHREQSIZE);
 	uint8_t target_max_size = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLREQSUP);
 	uint16_t max_read_req = 32 << flash_req_size;
-	struct npcx_taf_head taf_head;
+	uint8_t read_buf[64];
 	int rc;
 
 	if (flash_req_size > target_max_size) {
@@ -297,21 +352,14 @@ static int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_pa
 	}
 
 	do {
-		data_ptr = (uint8_t *)taf_data_ptr->data;
-
-		taf_head.pkt_len = len + NPCX_TAF_CMP_HEADER_LEN;
-		taf_head.type = cycle_type;
-		taf_head.tag_hlen = (taf_data_ptr->tag << 4) | ((len & 0xF00) >> 8);
-		taf_head.llen = len & 0xFF;
-		memcpy(data_ptr, &taf_head, sizeof(taf_head));
-
-		rc = flash_read(spi_dev, addr, data_ptr + 4, len);
+		rc = flash_read(spi_dev, addr, &read_buf[0], len);
 		if (rc) {
 			LOG_ERR("flash read fail 0x%x", rc);
 			return -EIO;
 		}
 
-		rc = taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+		rc = taf_npcx_completion_handler(dev, cycle_type, taf_data_ptr->tag, len,
+						 (uint32_t *)&read_buf[0]);
 		if (rc) {
 			LOG_ERR("espi taf completion handler fail");
 			return rc;
@@ -330,12 +378,12 @@ static int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_pa
 
 	return 0;
 }
+#endif
 
 static int espi_taf_npcx_flash_write(const struct device *dev, struct espi_saf_packet *pckt)
 {
 	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
 	uint8_t *data_ptr = (uint8_t *)(taf_data_ptr->data);
-	struct npcx_taf_head taf_head;
 	int rc;
 
 	if (espi_taf_check_write_protect(dev, pckt->flash_addr,
@@ -350,13 +398,8 @@ static int espi_taf_npcx_flash_write(const struct device *dev, struct espi_saf_p
 		return -EIO;
 	}
 
-	taf_head.pkt_len = NPCX_TAF_CMP_HEADER_LEN;
-	taf_head.type = CYC_SCS_CMP_WITHOUT_DATA;
-	taf_head.tag_hlen = (taf_data_ptr->tag << 4);
-	taf_head.llen = 0x0;
-	memcpy(data_ptr, &taf_head, sizeof(taf_head));
-
-	rc = taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	rc = taf_npcx_completion_handler(dev, CYC_SCS_CMP_WITHOUT_DATA, taf_data_ptr->tag, 0x0,
+					 NULL);
 	if (rc) {
 		LOG_ERR("espi taf completion handler fail");
 		return rc;
@@ -367,13 +410,19 @@ static int espi_taf_npcx_flash_write(const struct device *dev, struct espi_saf_p
 
 static int espi_taf_npcx_flash_erase(const struct device *dev, struct espi_saf_packet *pckt)
 {
+	int erase_blk[] = {KB(4), KB(32), KB(64), KB(128)};
 	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
-	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
 	uint32_t addr = pckt->flash_addr;
-	uint32_t len = pckt->len;
-	struct npcx_taf_head taf_head;
+	uint32_t len;
 	int rc;
 
+	if ((pckt->len < 0) || (pckt->len >= NPCX_ESPI_TAF_ERASE_LEN_MAX)) {
+		LOG_ERR("Invalid erase block size");
+		return -EINVAL;
+	}
+
+	len = erase_blk[pckt->len];
+
 	if (espi_taf_check_write_protect(dev, addr, len, taf_data_ptr->tag)) {
 		LOG_ERR("Access protection region");
 		return -EINVAL;
@@ -385,13 +434,8 @@ static int espi_taf_npcx_flash_erase(const struct device *dev, struct espi_saf_p
 		return -EIO;
 	}
 
-	taf_head.pkt_len = NPCX_TAF_CMP_HEADER_LEN;
-	taf_head.type = CYC_SCS_CMP_WITHOUT_DATA;
-	taf_head.tag_hlen = (taf_data_ptr->tag << 4);
-	taf_head.llen = 0x0;
-	memcpy(data_ptr, &taf_head, sizeof(taf_head));
-
-	rc = taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	rc = taf_npcx_completion_handler(dev, CYC_SCS_CMP_WITHOUT_DATA, taf_data_ptr->tag, 0x0,
+					 NULL);
 	if (rc) {
 		LOG_ERR("espi taf completion handler fail");
 		return rc;
@@ -402,19 +446,11 @@ static int espi_taf_npcx_flash_erase(const struct device *dev, struct espi_saf_p
 
 static int espi_taf_npcx_flash_unsuccess(const struct device *dev, struct espi_saf_packet *pckt)
 {
-	struct espi_taf_npcx_pckt *taf_data_ptr
-			= (struct espi_taf_npcx_pckt *)pckt->buf;
-	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
-	struct npcx_taf_head taf_head;
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
 	int rc;
 
-	taf_head.pkt_len = NPCX_TAF_CMP_HEADER_LEN;
-	taf_head.type = CYC_UNSCS_CMP_WITHOUT_DATA_ONLY;
-	taf_head.tag_hlen = (taf_data_ptr->tag << 4);
-	taf_head.llen = 0x0;
-	memcpy(data_ptr, &taf_head, sizeof(taf_head));
-
-	rc = taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	rc = taf_npcx_completion_handler(dev, CYC_UNSCS_CMP_WITHOUT_DATA_ONLY, taf_data_ptr->tag,
+					 0x0, NULL);
 	if (rc) {
 		LOG_ERR("espi taf completion handler fail");
 		return rc;
@@ -423,6 +459,67 @@ static int espi_taf_npcx_flash_unsuccess(const struct device *dev, struct espi_s
 	return 0;
 }
 
+static void espi_taf_work(struct k_work *item)
+{
+	struct espi_taf_npcx_data *info = CONTAINER_OF(item, struct espi_taf_npcx_data, work);
+	int ret = 0;
+
+	struct espi_taf_npcx_pckt taf_data;
+	struct espi_saf_packet pckt_taf;
+
+	pckt_taf.flash_addr = info->address;
+	pckt_taf.len = info->length;
+	taf_data.tag = info->taf_tag;
+	if (info->taf_type == NPCX_ESPI_TAF_REQ_WRITE) {
+		taf_data.data = (uint8_t *)info->src;
+	} else {
+		taf_data.data = NULL;
+	}
+	pckt_taf.buf = (uint8_t *)&taf_data;
+
+	switch (info->taf_type) {
+#if defined(CONFIG_ESPI_TAF_MANUAL_MODE)
+	case NPCX_ESPI_TAF_REQ_READ:
+		ret = espi_taf_npcx_flash_read(info->host_dev, &pckt_taf);
+		break;
+#endif
+	case NPCX_ESPI_TAF_REQ_ERASE:
+		ret = espi_taf_npcx_flash_erase(info->host_dev, &pckt_taf);
+		break;
+	case NPCX_ESPI_TAF_REQ_WRITE:
+		ret = espi_taf_npcx_flash_write(info->host_dev, &pckt_taf);
+		break;
+	}
+
+	if (ret != 0) {
+		ret = espi_taf_npcx_flash_unsuccess(info->host_dev, &pckt_taf);
+	}
+}
+
+static void espi_taf_event_handler(const struct device *dev, struct espi_callback *cb,
+				   struct espi_event event)
+{
+	if ((event.evt_type != ESPI_BUS_SAF_NOTIFICATION) ||
+	    (event.evt_details != ESPI_CHANNEL_FLASH)) {
+		return;
+	}
+
+	espi_taf_get_pckt(dev, &npcx_espi_taf_data, event);
+	k_work_submit(&npcx_espi_taf_data.work);
+}
+
+int npcx_init_taf(const struct device *dev, sys_slist_t *callbacks)
+{
+	espi_init_callback(&espi_taf_cb, espi_taf_event_handler, ESPI_BUS_SAF_NOTIFICATION);
+	espi_add_callback(dev, &espi_taf_cb);
+
+	npcx_espi_taf_data.host_dev = dev;
+	npcx_espi_taf_data.callbacks = callbacks;
+	k_work_init(&npcx_espi_taf_data.work, espi_taf_work);
+
+	return 0;
+}
+
 static int espi_taf_npcx_init(const struct device *dev)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
@@ -444,14 +541,8 @@ static const struct espi_saf_driver_api espi_taf_npcx_driver_api = {
 	.set_protection_regions = espi_taf_npcx_set_pr,
 	.activate = espi_taf_npcx_activate,
 	.get_channel_status = espi_taf_npcx_channel_ready,
-	.flash_read = espi_taf_npcx_flash_read,
-	.flash_write = espi_taf_npcx_flash_write,
-	.flash_erase = espi_taf_npcx_flash_erase,
-	.flash_unsuccess = espi_taf_npcx_flash_unsuccess,
 };
 
-static struct espi_taf_npcx_data npcx_espi_taf_data;
-
 static const struct espi_taf_npcx_config espi_taf_npcx_config = {
 	.base = DT_INST_REG_ADDR(0),
 	.mapped_addr = DT_INST_PROP(0, mapped_addr),
diff --git a/soc/arm/nuvoton_npcx/common/soc_espi_taf.h b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
index a8755e080..90b98cbb6 100644
--- a/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
+++ b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
@@ -144,6 +144,8 @@ struct npcx_taf_head {
 	uint8_t llen;
 };
 
+int npcx_init_taf(const struct device *dev, sys_slist_t *callbacks);
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.17.1


From 933a65ecf1d98dd6210844e7d7ac2055538cefa5 Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Wed, 24 Apr 2024 11:25:15 +0800
Subject: [PATCH 09/42] drivers: espi: npcx: select RING_BUFFER for p80

This CL adds automatic select CONFIG_RING_BUFFER for port 80 multi-byte.

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig.npcx | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index d67f1a481..035db2415 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -46,6 +46,7 @@ config ESPI_NPCX_BYPASS_CH_ENABLE_FATAL_ERROR
 config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
 	bool "Host can write 1/2/4 bytes of Port80 data in a eSPI transaction"
 	depends on (SOC_SERIES_NPCX9 || SOC_SERIES_NPCX4) && ESPI_PERIPHERAL_DEBUG_PORT_80
+	select RING_BUFFER
 	help
 	  EC can accept 1/2/4 bytes of Port 80 data written from the Host in an
 	  eSPI transaction.
-- 
2.17.1


From b5d387d5f279bc2e2208e65d4188bfd71932df4c Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Thu, 30 May 2024 13:45:47 +0800
Subject: [PATCH 10/42] drivers: espi: npcx: add support 66MHz eSPI clock

This CL adds support 66MHz eSPI clock for NPCX4.

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_npcx.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 89d46c367..302aff132 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -69,6 +69,7 @@ struct espi_npcx_data {
 #define NPCX_ESPI_MAXFREQ_25         1
 #define NPCX_ESPI_MAXFREQ_33         2
 #define NPCX_ESPI_MAXFREQ_50         3
+#define NPCX_ESPI_MAXFREQ_66         4
 
 /* Minimum delay before acknowledging a virtual wire */
 #define NPCX_ESPI_VWIRE_ACK_DELAY    10ul /* 10 us */
@@ -676,6 +677,11 @@ static int espi_npcx_configure(const struct device *dev, struct espi_cfg *cfg)
 	case 50:
 		max_freq = NPCX_ESPI_MAXFREQ_50;
 		break;
+#ifdef CONFIG_SOC_SERIES_NPCX4
+	case 66:
+		max_freq = NPCX_ESPI_MAXFREQ_66;
+		break;
+#endif
 	default:
 		return -EINVAL;
 	}
-- 
2.17.1


From 015a6073a933a5722abb68e0e9fafc735225b0b0 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Mon, 1 Apr 2024 10:34:25 +0800
Subject: [PATCH 11/42] driver: reset: npcx: add driver support for reset
 controller

Nuvoton NPCX chips have reset registers which allow to reset the
peripheral hardware modules. This commit adds the support by
implementing the reset driver. Note that only the reset_line_toggle API
is supported because of the nature of the reset controller's design.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/reset/CMakeLists.txt                  |   1 +
 drivers/reset/Kconfig                         |   1 +
 drivers/reset/Kconfig.npcx                    |  11 ++
 drivers/reset/reset_npcx.c                    |  78 ++++++++++++
 dts/arm/nuvoton/npcx/npcx4.dtsi               |   7 ++
 dts/arm/nuvoton/npcx/npcx7.dtsi               |   7 ++
 dts/arm/nuvoton/npcx/npcx9.dtsi               |   7 ++
 dts/bindings/reset/nuvoton,npcx-rst.yaml      |  18 +++
 .../zephyr/dt-bindings/reset/npcx4_reset.h    | 114 ++++++++++++++++++
 .../zephyr/dt-bindings/reset/npcx7_reset.h    |  94 +++++++++++++++
 .../zephyr/dt-bindings/reset/npcx9_reset.h    | 104 ++++++++++++++++
 soc/arm/nuvoton_npcx/common/reg/reg_def.h     |   8 ++
 soc/arm/nuvoton_npcx/common/registers.c       |   8 ++
 13 files changed, 458 insertions(+)
 create mode 100644 drivers/reset/Kconfig.npcx
 create mode 100644 drivers/reset/reset_npcx.c
 create mode 100644 dts/bindings/reset/nuvoton,npcx-rst.yaml
 create mode 100644 include/zephyr/dt-bindings/reset/npcx4_reset.h
 create mode 100644 include/zephyr/dt-bindings/reset/npcx7_reset.h
 create mode 100644 include/zephyr/dt-bindings/reset/npcx9_reset.h

diff --git a/drivers/reset/CMakeLists.txt b/drivers/reset/CMakeLists.txt
index 36c68367d..f27f31f68 100644
--- a/drivers/reset/CMakeLists.txt
+++ b/drivers/reset/CMakeLists.txt
@@ -9,3 +9,4 @@ zephyr_library_sources_ifdef(CONFIG_RESET_AST10X0 reset_ast10x0.c)
 zephyr_library_sources_ifdef(CONFIG_RESET_STM32 reset_stm32.c)
 zephyr_library_sources_ifdef(CONFIG_RESET_NUMAKER reset_numaker.c)
 zephyr_library_sources_ifdef(CONFIG_RESET_INTEL_SOCFPGA reset_intel_socfpga.c)
+zephyr_library_sources_ifdef(CONFIG_RESET_NPCX reset_npcx.c)
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index f940583c9..1d361aa8e 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -33,5 +33,6 @@ rsource "Kconfig.aspeed"
 rsource "Kconfig.stm32"
 rsource "Kconfig.numaker"
 rsource "Kconfig.intel_socfpga"
+rsource "Kconfig.npcx"
 
 endif # RESET
diff --git a/drivers/reset/Kconfig.npcx b/drivers/reset/Kconfig.npcx
new file mode 100644
index 000000000..1ce6d27fe
--- /dev/null
+++ b/drivers/reset/Kconfig.npcx
@@ -0,0 +1,11 @@
+# NPCX reset controller driver configuration options
+
+# Copyright (c) 2024 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config RESET_NPCX
+	bool "Nuvoton NPCX embedded controller (EC) reset controller driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_RST_ENABLED
+	help
+	  This option enables the reset controller driver for Nuvoton NPCX MCUs.
diff --git a/drivers/reset/reset_npcx.c b/drivers/reset/reset_npcx.c
new file mode 100644
index 000000000..af9cac37f
--- /dev/null
+++ b/drivers/reset/reset_npcx.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2024 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_rst
+
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/reset.h>
+
+#if defined(CONFIG_SOC_SERIES_NPCX7)
+#include <zephyr/dt-bindings/reset/npcx7_reset.h>
+#elif defined(CONFIG_SOC_SERIES_NPCX9)
+#include <zephyr/dt-bindings/reset/npcx9_reset.h>
+#elif defined(CONFIG_SOC_SERIES_NPCX4)
+#include <zephyr/dt-bindings/reset/npcx4_reset.h>
+#endif
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(rst_npcx);
+
+#define NPCX_RESET_CTL_REG_BYTE_SIZE  4
+#define NPCX_RESET_CTL_REG_OFFSET(id) ((id) >> (NPCX_RESET_CTL_REG_BYTE_SIZE + 1))
+#define NPCX_RESET_CTL_REG_BIT(id)    (((id) & ((1 << (NPCX_RESET_CTL_REG_BYTE_SIZE + 1)) - 1)))
+
+#define NPCX_SWRST_TRG_WORD_START  0xC183
+#define NPCX_SWRST_TRG_WORD_CLEAR  0x0
+#define NPCX_SWRST_TRG_WORD_DONE   0xFFFF
+#define NPCX_SWRST_DONE_TIMEOUT_US 100
+
+struct reset_npcx_dev_config {
+	struct swrst_reg *reg_base;
+};
+
+static int reset_npcx_line_toggle(const struct device *dev, uint32_t id)
+{
+	const struct reset_npcx_dev_config *const config = dev->config;
+	struct swrst_reg *const reg = config->reg_base;
+	unsigned int key;
+	uint8_t reg_offset;
+	uint8_t reg_bit;
+	int ret = 0;
+
+	if (!IN_RANGE(id, NPCX_RESET_ID_START, NPCX_RESET_ID_END)) {
+		LOG_ERR("Invalid Reset ID");
+		return -EINVAL;
+	}
+	reg_offset = NPCX_RESET_CTL_REG_OFFSET(id);
+	reg_bit = NPCX_RESET_CTL_REG_BIT(id);
+
+	key = irq_lock();
+
+	reg->SWRST_CTL[reg_offset] |= BIT(reg_bit);
+	reg->SWRST_TRG = NPCX_SWRST_TRG_WORD_CLEAR;
+	reg->SWRST_TRG = NPCX_SWRST_TRG_WORD_START;
+
+	if (!WAIT_FOR((reg->SWRST_TRG == NPCX_SWRST_TRG_WORD_DONE), NPCX_SWRST_DONE_TIMEOUT_US,
+		     NULL)) {
+		LOG_ERR("Reset trig timeout");
+		ret = -EBUSY;
+	}
+
+	irq_unlock(key);
+
+	return ret;
+}
+
+static const struct reset_driver_api reset_npcx_driver_api = {
+	.line_toggle = reset_npcx_line_toggle,
+};
+
+static const struct reset_npcx_dev_config reset_npcx_config = {
+	.reg_base = (struct swrst_reg *)DT_INST_REG_ADDR(0),
+};
+
+DEVICE_DT_INST_DEFINE(0, NULL, NULL, NULL, &reset_npcx_config, PRE_KERNEL_1,
+		      CONFIG_RESET_INIT_PRIORITY, &reset_npcx_driver_api);
diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
index 004ca5332..9070b4a71 100644
--- a/dts/arm/nuvoton/npcx/npcx4.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -317,6 +317,13 @@
 				status = "disabled";
 			};
 		};
+
+		rctl: reset-controller@400c3100 {
+			compatible = "nuvoton,npcx-rst";
+			reg = <0x400c3100 0x14>;
+			#reset-cells = <1>;
+			status = "disabled";
+		};
 	};
 
 	soc-if {
diff --git a/dts/arm/nuvoton/npcx/npcx7.dtsi b/dts/arm/nuvoton/npcx/npcx7.dtsi
index be0031275..fb4001c17 100644
--- a/dts/arm/nuvoton/npcx/npcx7.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx7.dtsi
@@ -260,6 +260,13 @@
 			rx-plsize = <64>;
 			tx-plsize = <16>;
 		};
+
+		rctl: reset-controller@400c3100 {
+			compatible = "nuvoton,npcx-rst";
+			reg = <0x400c3100 0x10>;
+			#reset-cells = <1>;
+			status = "disabled";
+		};
 	};
 
 	soc-id {
diff --git a/dts/arm/nuvoton/npcx/npcx9.dtsi b/dts/arm/nuvoton/npcx/npcx9.dtsi
index e3004ab87..4a49e2c27 100644
--- a/dts/arm/nuvoton/npcx/npcx9.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx9.dtsi
@@ -288,6 +288,13 @@
 			rx-plsize = <64>;
 			tx-plsize = <16>;
 		};
+
+		rctl: reset-controller@400c3100 {
+			compatible = "nuvoton,npcx-rst";
+			reg = <0x400c3100 0x14>;
+			#reset-cells = <1>;
+			status = "disabled";
+		};
 	};
 
 	soc-id {
diff --git a/dts/bindings/reset/nuvoton,npcx-rst.yaml b/dts/bindings/reset/nuvoton,npcx-rst.yaml
new file mode 100644
index 000000000..3efceb3ae
--- /dev/null
+++ b/dts/bindings/reset/nuvoton,npcx-rst.yaml
@@ -0,0 +1,18 @@
+# Copyright (c) 2024 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+description: NPCX Reset Controller
+
+compatible: "nuvoton,npcx-rst"
+
+include: [reset-controller.yaml, base.yaml]
+
+properties:
+  reg:
+    required: true
+
+  "#reset-cells":
+    const: 1
+
+reset-cells:
+- id
diff --git a/include/zephyr/dt-bindings/reset/npcx4_reset.h b/include/zephyr/dt-bindings/reset/npcx4_reset.h
new file mode 100644
index 000000000..46793b66e
--- /dev/null
+++ b/include/zephyr/dt-bindings/reset/npcx4_reset.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2024 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX4_RESET_H
+#define ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX4_RESET_H
+
+#define NPCX_RESET_SWRST_CTL1_OFFSET 0
+#define NPCX_RESET_SWRST_CTL2_OFFSET 32
+#define NPCX_RESET_SWRST_CTL3_OFFSET 64
+#define NPCX_RESET_SWRST_CTL4_OFFSET 96
+
+#define NPCX_RESET_GPIO0    (NPCX_RESET_SWRST_CTL1_OFFSET + 0)
+#define NPCX_RESET_GPIO1    (NPCX_RESET_SWRST_CTL1_OFFSET + 1)
+#define NPCX_RESET_GPIO2    (NPCX_RESET_SWRST_CTL1_OFFSET + 2)
+#define NPCX_RESET_GPIO3    (NPCX_RESET_SWRST_CTL1_OFFSET + 3)
+#define NPCX_RESET_GPIO4    (NPCX_RESET_SWRST_CTL1_OFFSET + 4)
+#define NPCX_RESET_GPIO5    (NPCX_RESET_SWRST_CTL1_OFFSET + 5)
+#define NPCX_RESET_GPIO6    (NPCX_RESET_SWRST_CTL1_OFFSET + 6)
+#define NPCX_RESET_GPIO7    (NPCX_RESET_SWRST_CTL1_OFFSET + 7)
+#define NPCX_RESET_GPIO8    (NPCX_RESET_SWRST_CTL1_OFFSET + 8)
+#define NPCX_RESET_GPIO9    (NPCX_RESET_SWRST_CTL1_OFFSET + 9)
+#define NPCX_RESET_GPIOA    (NPCX_RESET_SWRST_CTL1_OFFSET + 10)
+#define NPCX_RESET_GPIOB    (NPCX_RESET_SWRST_CTL1_OFFSET + 11)
+#define NPCX_RESET_GPIOC    (NPCX_RESET_SWRST_CTL1_OFFSET + 12)
+#define NPCX_RESET_GPIOD    (NPCX_RESET_SWRST_CTL1_OFFSET + 13)
+#define NPCX_RESET_GPIOE    (NPCX_RESET_SWRST_CTL1_OFFSET + 14)
+#define NPCX_RESET_GPIOF    (NPCX_RESET_SWRST_CTL1_OFFSET + 15)
+#define NPCX_RESET_ITIM64   (NPCX_RESET_SWRST_CTL1_OFFSET + 16)
+#define NPCX_RESET_ITIM32_1 (NPCX_RESET_SWRST_CTL1_OFFSET + 18)
+#define NPCX_RESET_ITIM32_2 (NPCX_RESET_SWRST_CTL1_OFFSET + 19)
+#define NPCX_RESET_ITIM32_3 (NPCX_RESET_SWRST_CTL1_OFFSET + 20)
+#define NPCX_RESET_ITIM32_4 (NPCX_RESET_SWRST_CTL1_OFFSET + 21)
+#define NPCX_RESET_ITIM32_5 (NPCX_RESET_SWRST_CTL1_OFFSET + 22)
+#define NPCX_RESET_ITIM32_6 (NPCX_RESET_SWRST_CTL1_OFFSET + 23)
+#define NPCX_RESET_MTC      (NPCX_RESET_SWRST_CTL1_OFFSET + 25)
+#define NPCX_RESET_MIWU0    (NPCX_RESET_SWRST_CTL1_OFFSET + 26)
+#define NPCX_RESET_MIWU1    (NPCX_RESET_SWRST_CTL1_OFFSET + 27)
+#define NPCX_RESET_MIWU2    (NPCX_RESET_SWRST_CTL1_OFFSET + 28)
+#define NPCX_RESET_GDMA1    (NPCX_RESET_SWRST_CTL1_OFFSET + 29)
+#define NPCX_RESET_GDMA2    (NPCX_RESET_SWRST_CTL1_OFFSET + 30)
+
+#define NPCX_RESET_PMC     (NPCX_RESET_SWRST_CTL2_OFFSET + 0)
+#define NPCX_RESET_SHI     (NPCX_RESET_SWRST_CTL2_OFFSET + 2)
+#define NPCX_RESET_SPIP    (NPCX_RESET_SWRST_CTL2_OFFSET + 3)
+#define NPCX_RESET_ADCE    (NPCX_RESET_SWRST_CTL2_OFFSET + 4)
+#define NPCX_RESET_PECI    (NPCX_RESET_SWRST_CTL2_OFFSET + 5)
+#define NPCX_RESET_CRUART2 (NPCX_RESET_SWRST_CTL2_OFFSET + 6)
+#define NPCX_RESET_ADCI    (NPCX_RESET_SWRST_CTL2_OFFSET + 7)
+#define NPCX_RESET_SMB0    (NPCX_RESET_SWRST_CTL2_OFFSET + 8)
+#define NPCX_RESET_SMB1    (NPCX_RESET_SWRST_CTL2_OFFSET + 9)
+#define NPCX_RESET_SMB2    (NPCX_RESET_SWRST_CTL2_OFFSET + 10)
+#define NPCX_RESET_SMB3    (NPCX_RESET_SWRST_CTL2_OFFSET + 11)
+#define NPCX_RESET_SMB4    (NPCX_RESET_SWRST_CTL2_OFFSET + 12)
+#define NPCX_RESET_SMB5    (NPCX_RESET_SWRST_CTL2_OFFSET + 13)
+#define NPCX_RESET_SMB6    (NPCX_RESET_SWRST_CTL2_OFFSET + 14)
+#define NPCX_RESET_TWD     (NPCX_RESET_SWRST_CTL2_OFFSET + 15)
+#define NPCX_RESET_PWM0    (NPCX_RESET_SWRST_CTL2_OFFSET + 16)
+#define NPCX_RESET_PWM1    (NPCX_RESET_SWRST_CTL2_OFFSET + 17)
+#define NPCX_RESET_PWM2    (NPCX_RESET_SWRST_CTL2_OFFSET + 18)
+#define NPCX_RESET_PWM3    (NPCX_RESET_SWRST_CTL2_OFFSET + 19)
+#define NPCX_RESET_PWM4    (NPCX_RESET_SWRST_CTL2_OFFSET + 20)
+#define NPCX_RESET_PWM5    (NPCX_RESET_SWRST_CTL2_OFFSET + 21)
+#define NPCX_RESET_PWM6    (NPCX_RESET_SWRST_CTL2_OFFSET + 22)
+#define NPCX_RESET_PWM7    (NPCX_RESET_SWRST_CTL2_OFFSET + 23)
+#define NPCX_RESET_MFT16_1 (NPCX_RESET_SWRST_CTL2_OFFSET + 24)
+#define NPCX_RESET_MFT16_2 (NPCX_RESET_SWRST_CTL2_OFFSET + 25)
+#define NPCX_RESET_MFT16_3 (NPCX_RESET_SWRST_CTL2_OFFSET + 26)
+#define NPCX_RESET_SMB7    (NPCX_RESET_SWRST_CTL2_OFFSET + 27)
+#define NPCX_RESET_CRUART1 (NPCX_RESET_SWRST_CTL2_OFFSET + 28)
+#define NPCX_RESET_PS2     (NPCX_RESET_SWRST_CTL2_OFFSET + 29)
+#define NPCX_RESET_SDP     (NPCX_RESET_SWRST_CTL2_OFFSET + 30)
+#define NPCX_RESET_KBS     (NPCX_RESET_SWRST_CTL2_OFFSET + 31)
+
+#define NPCX_RESET_SIOCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 0)
+#define NPCX_RESET_SERPORT (NPCX_RESET_SWRST_CTL3_OFFSET + 1)
+#define NPCX_RESET_I3C_1   (NPCX_RESET_SWRST_CTL3_OFFSET + 4)
+#define NPCX_RESET_I3C_2   (NPCX_RESET_SWRST_CTL3_OFFSET + 5)
+#define NPCX_RESET_I3C_3   (NPCX_RESET_SWRST_CTL3_OFFSET + 6)
+#define NPCX_RESET_I3C_RD  (NPCX_RESET_SWRST_CTL3_OFFSET + 7)
+#define NPCX_RESET_MSWC    (NPCX_RESET_SWRST_CTL3_OFFSET + 8)
+#define NPCX_RESET_SHM     (NPCX_RESET_SWRST_CTL3_OFFSET + 9)
+#define NPCX_RESET_PMCH1   (NPCX_RESET_SWRST_CTL3_OFFSET + 10)
+#define NPCX_RESET_PMCH2   (NPCX_RESET_SWRST_CTL3_OFFSET + 11)
+#define NPCX_RESET_PMCH3   (NPCX_RESET_SWRST_CTL3_OFFSET + 12)
+#define NPCX_RESET_PMCH4   (NPCX_RESET_SWRST_CTL3_OFFSET + 13)
+#define NPCX_RESET_KBC     (NPCX_RESET_SWRST_CTL3_OFFSET + 15)
+#define NPCX_RESET_C2HOST  (NPCX_RESET_SWRST_CTL3_OFFSET + 16)
+#define NPCX_RESET_CRUART3 (NPCX_RESET_SWRST_CTL3_OFFSET + 18)
+#define NPCX_RESET_CRUART4 (NPCX_RESET_SWRST_CTL3_OFFSET + 19)
+#define NPCX_RESET_LFCG    (NPCX_RESET_SWRST_CTL3_OFFSET + 20)
+#define NPCX_RESET_DEV     (NPCX_RESET_SWRST_CTL3_OFFSET + 22)
+#define NPCX_RESET_SYSCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 23)
+#define NPCX_RESET_SBY     (NPCX_RESET_SWRST_CTL3_OFFSET + 24)
+#define NPCX_RESET_BBRAM   (NPCX_RESET_SWRST_CTL3_OFFSET + 25)
+#define NPCX_RESET_SHA_2B  (NPCX_RESET_SWRST_CTL3_OFFSET + 26)
+#define NPCX_RESET_SHA_2A  (NPCX_RESET_SWRST_CTL3_OFFSET + 29)
+
+#define NPCX_RESET_MDC   (NPCX_RESET_SWRST_CTL4_OFFSET + 15)
+#define NPCX_RESET_FIU0  (NPCX_RESET_SWRST_CTL4_OFFSET + 16)
+#define NPCX_RESET_FIU1  (NPCX_RESET_SWRST_CTL4_OFFSET + 17)
+#define NPCX_RESET_MDMA1 (NPCX_RESET_SWRST_CTL4_OFFSET + 24)
+#define NPCX_RESET_MDMA2 (NPCX_RESET_SWRST_CTL4_OFFSET + 25)
+#define NPCX_RESET_MDMA3 (NPCX_RESET_SWRST_CTL4_OFFSET + 26)
+#define NPCX_RESET_MDMA4 (NPCX_RESET_SWRST_CTL4_OFFSET + 27)
+#define NPCX_RESET_MDMA5 (NPCX_RESET_SWRST_CTL4_OFFSET + 28)
+#define NPCX_RESET_MDMA6 (NPCX_RESET_SWRST_CTL4_OFFSET + 29)
+#define NPCX_RESET_MDMA7 (NPCX_RESET_SWRST_CTL4_OFFSET + 30)
+
+#define NPCX_RESET_ID_START NPCX_RESET_GPIO0
+#define NPCX_RESET_ID_END   NPCX_RESET_MDMA7
+#endif
diff --git a/include/zephyr/dt-bindings/reset/npcx7_reset.h b/include/zephyr/dt-bindings/reset/npcx7_reset.h
new file mode 100644
index 000000000..b9df54829
--- /dev/null
+++ b/include/zephyr/dt-bindings/reset/npcx7_reset.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2024 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX7_RESET_H
+#define ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX7_RESET_H
+
+#define NPCX_RESET_SWRST_CTL1_OFFSET 0
+#define NPCX_RESET_SWRST_CTL2_OFFSET 32
+#define NPCX_RESET_SWRST_CTL3_OFFSET 64
+
+#define NPCX_RESET_GPIO0    (NPCX_RESET_SWRST_CTL1_OFFSET + 0)
+#define NPCX_RESET_GPIO1    (NPCX_RESET_SWRST_CTL1_OFFSET + 1)
+#define NPCX_RESET_GPIO2    (NPCX_RESET_SWRST_CTL1_OFFSET + 2)
+#define NPCX_RESET_GPIO3    (NPCX_RESET_SWRST_CTL1_OFFSET + 3)
+#define NPCX_RESET_GPIO4    (NPCX_RESET_SWRST_CTL1_OFFSET + 4)
+#define NPCX_RESET_GPIO5    (NPCX_RESET_SWRST_CTL1_OFFSET + 5)
+#define NPCX_RESET_GPIO6    (NPCX_RESET_SWRST_CTL1_OFFSET + 6)
+#define NPCX_RESET_GPIO7    (NPCX_RESET_SWRST_CTL1_OFFSET + 7)
+#define NPCX_RESET_GPIO8    (NPCX_RESET_SWRST_CTL1_OFFSET + 8)
+#define NPCX_RESET_GPIO9    (NPCX_RESET_SWRST_CTL1_OFFSET + 9)
+#define NPCX_RESET_GPIOA    (NPCX_RESET_SWRST_CTL1_OFFSET + 10)
+#define NPCX_RESET_GPIOB    (NPCX_RESET_SWRST_CTL1_OFFSET + 11)
+#define NPCX_RESET_GPIOC    (NPCX_RESET_SWRST_CTL1_OFFSET + 12)
+#define NPCX_RESET_GPIOD    (NPCX_RESET_SWRST_CTL1_OFFSET + 13)
+#define NPCX_RESET_GPIOE    (NPCX_RESET_SWRST_CTL1_OFFSET + 14)
+#define NPCX_RESET_GPIOF    (NPCX_RESET_SWRST_CTL1_OFFSET + 15)
+#define NPCX_RESET_ITIM64   (NPCX_RESET_SWRST_CTL1_OFFSET + 16)
+#define NPCX_RESET_ITIM16_1 (NPCX_RESET_SWRST_CTL1_OFFSET + 18)
+#define NPCX_RESET_ITIM16_2 (NPCX_RESET_SWRST_CTL1_OFFSET + 19)
+#define NPCX_RESET_ITIM16_3 (NPCX_RESET_SWRST_CTL1_OFFSET + 20)
+#define NPCX_RESET_ITIM16_4 (NPCX_RESET_SWRST_CTL1_OFFSET + 21)
+#define NPCX_RESET_ITIM16_5 (NPCX_RESET_SWRST_CTL1_OFFSET + 22)
+#define NPCX_RESET_ITIM16_6 (NPCX_RESET_SWRST_CTL1_OFFSET + 23)
+#define NPCX_RESET_ITIM32   (NPCX_RESET_SWRST_CTL1_OFFSET + 24)
+#define NPCX_RESET_MTC      (NPCX_RESET_SWRST_CTL1_OFFSET + 25)
+#define NPCX_RESET_MIWU0    (NPCX_RESET_SWRST_CTL1_OFFSET + 26)
+#define NPCX_RESET_MIWU1    (NPCX_RESET_SWRST_CTL1_OFFSET + 27)
+#define NPCX_RESET_MIWU2    (NPCX_RESET_SWRST_CTL1_OFFSET + 28)
+#define NPCX_RESET_GDMA     (NPCX_RESET_SWRST_CTL1_OFFSET + 29)
+#define NPCX_RESET_FIU      (NPCX_RESET_SWRST_CTL1_OFFSET + 30)
+
+#define NPCX_RESET_PMC     (NPCX_RESET_SWRST_CTL2_OFFSET + 0)
+#define NPCX_RESET_SHI     (NPCX_RESET_SWRST_CTL2_OFFSET + 2)
+#define NPCX_RESET_SPIP    (NPCX_RESET_SWRST_CTL2_OFFSET + 3)
+#define NPCX_RESET_PECI    (NPCX_RESET_SWRST_CTL2_OFFSET + 5)
+#define NPCX_RESET_CRUART2 (NPCX_RESET_SWRST_CTL2_OFFSET + 6)
+#define NPCX_RESET_ADC     (NPCX_RESET_SWRST_CTL2_OFFSET + 7)
+#define NPCX_RESET_SMB0    (NPCX_RESET_SWRST_CTL2_OFFSET + 8)
+#define NPCX_RESET_SMB1    (NPCX_RESET_SWRST_CTL2_OFFSET + 9)
+#define NPCX_RESET_SMB2    (NPCX_RESET_SWRST_CTL2_OFFSET + 10)
+#define NPCX_RESET_SMB3    (NPCX_RESET_SWRST_CTL2_OFFSET + 11)
+#define NPCX_RESET_SMB4    (NPCX_RESET_SWRST_CTL2_OFFSET + 12)
+#define NPCX_RESET_SMB5    (NPCX_RESET_SWRST_CTL2_OFFSET + 13)
+#define NPCX_RESET_SMB6    (NPCX_RESET_SWRST_CTL2_OFFSET + 14)
+#define NPCX_RESET_TWD     (NPCX_RESET_SWRST_CTL2_OFFSET + 15)
+#define NPCX_RESET_PWM0    (NPCX_RESET_SWRST_CTL2_OFFSET + 16)
+#define NPCX_RESET_PWM1    (NPCX_RESET_SWRST_CTL2_OFFSET + 17)
+#define NPCX_RESET_PWM2    (NPCX_RESET_SWRST_CTL2_OFFSET + 18)
+#define NPCX_RESET_PWM3    (NPCX_RESET_SWRST_CTL2_OFFSET + 19)
+#define NPCX_RESET_PWM4    (NPCX_RESET_SWRST_CTL2_OFFSET + 20)
+#define NPCX_RESET_PWM5    (NPCX_RESET_SWRST_CTL2_OFFSET + 21)
+#define NPCX_RESET_PWM6    (NPCX_RESET_SWRST_CTL2_OFFSET + 22)
+#define NPCX_RESET_PWM7    (NPCX_RESET_SWRST_CTL2_OFFSET + 23)
+#define NPCX_RESET_MFT16_1 (NPCX_RESET_SWRST_CTL2_OFFSET + 24)
+#define NPCX_RESET_MFT16_2 (NPCX_RESET_SWRST_CTL2_OFFSET + 25)
+#define NPCX_RESET_MFT16_3 (NPCX_RESET_SWRST_CTL2_OFFSET + 26)
+#define NPCX_RESET_SMB7    (NPCX_RESET_SWRST_CTL2_OFFSET + 27)
+#define NPCX_RESET_CRUART1 (NPCX_RESET_SWRST_CTL2_OFFSET + 28)
+#define NPCX_RESET_PS2     (NPCX_RESET_SWRST_CTL2_OFFSET + 29)
+#define NPCX_RESET_SDP     (NPCX_RESET_SWRST_CTL2_OFFSET + 30)
+#define NPCX_RESET_KBS     (NPCX_RESET_SWRST_CTL2_OFFSET + 31)
+
+#define NPCX_RESET_SIOCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 0)
+#define NPCX_RESET_SERPORT (NPCX_RESET_SWRST_CTL3_OFFSET + 1)
+#define NPCX_RESET_MSWC    (NPCX_RESET_SWRST_CTL3_OFFSET + 8)
+#define NPCX_RESET_SHM     (NPCX_RESET_SWRST_CTL3_OFFSET + 9)
+#define NPCX_RESET_PMCH1   (NPCX_RESET_SWRST_CTL3_OFFSET + 10)
+#define NPCX_RESET_PMCH2   (NPCX_RESET_SWRST_CTL3_OFFSET + 11)
+#define NPCX_RESET_PMCH3   (NPCX_RESET_SWRST_CTL3_OFFSET + 12)
+#define NPCX_RESET_PMCH4   (NPCX_RESET_SWRST_CTL3_OFFSET + 13)
+#define NPCX_RESET_KBC     (NPCX_RESET_SWRST_CTL3_OFFSET + 15)
+#define NPCX_RESET_C2HOST  (NPCX_RESET_SWRST_CTL3_OFFSET + 16)
+#define NPCX_RESET_LFCG    (NPCX_RESET_SWRST_CTL3_OFFSET + 20)
+#define NPCX_RESET_DEV     (NPCX_RESET_SWRST_CTL3_OFFSET + 22)
+#define NPCX_RESET_SYSCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 23)
+#define NPCX_RESET_SBY     (NPCX_RESET_SWRST_CTL3_OFFSET + 24)
+#define NPCX_RESET_BBRAM   (NPCX_RESET_SWRST_CTL3_OFFSET + 25)
+
+#define NPCX_RESET_ID_START NPCX_RESET_GPIO0
+#define NPCX_RESET_ID_END   NPCX_RESET_BBRAM
+#endif
diff --git a/include/zephyr/dt-bindings/reset/npcx9_reset.h b/include/zephyr/dt-bindings/reset/npcx9_reset.h
new file mode 100644
index 000000000..c8032bddd
--- /dev/null
+++ b/include/zephyr/dt-bindings/reset/npcx9_reset.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2024 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX9_RESET_H
+#define ZEPHYR_INCLUDE_DT_BINDINGS_RESET_NPCX9_RESET_H
+
+#define NPCX_RESET_SWRST_CTL1_OFFSET 0
+#define NPCX_RESET_SWRST_CTL2_OFFSET 32
+#define NPCX_RESET_SWRST_CTL3_OFFSET 64
+#define NPCX_RESET_SWRST_CTL4_OFFSET 96
+
+#define NPCX_RESET_GPIO0    (NPCX_RESET_SWRST_CTL1_OFFSET + 0)
+#define NPCX_RESET_GPIO1    (NPCX_RESET_SWRST_CTL1_OFFSET + 1)
+#define NPCX_RESET_GPIO2    (NPCX_RESET_SWRST_CTL1_OFFSET + 2)
+#define NPCX_RESET_GPIO3    (NPCX_RESET_SWRST_CTL1_OFFSET + 3)
+#define NPCX_RESET_GPIO4    (NPCX_RESET_SWRST_CTL1_OFFSET + 4)
+#define NPCX_RESET_GPIO5    (NPCX_RESET_SWRST_CTL1_OFFSET + 5)
+#define NPCX_RESET_GPIO6    (NPCX_RESET_SWRST_CTL1_OFFSET + 6)
+#define NPCX_RESET_GPIO7    (NPCX_RESET_SWRST_CTL1_OFFSET + 7)
+#define NPCX_RESET_GPIO8    (NPCX_RESET_SWRST_CTL1_OFFSET + 8)
+#define NPCX_RESET_GPIO9    (NPCX_RESET_SWRST_CTL1_OFFSET + 9)
+#define NPCX_RESET_GPIOA    (NPCX_RESET_SWRST_CTL1_OFFSET + 10)
+#define NPCX_RESET_GPIOB    (NPCX_RESET_SWRST_CTL1_OFFSET + 11)
+#define NPCX_RESET_GPIOC    (NPCX_RESET_SWRST_CTL1_OFFSET + 12)
+#define NPCX_RESET_GPIOD    (NPCX_RESET_SWRST_CTL1_OFFSET + 13)
+#define NPCX_RESET_GPIOE    (NPCX_RESET_SWRST_CTL1_OFFSET + 14)
+#define NPCX_RESET_GPIOF    (NPCX_RESET_SWRST_CTL1_OFFSET + 15)
+#define NPCX_RESET_ITIM64   (NPCX_RESET_SWRST_CTL1_OFFSET + 16)
+#define NPCX_RESET_ITIM32_1 (NPCX_RESET_SWRST_CTL1_OFFSET + 18)
+#define NPCX_RESET_ITIM32_2 (NPCX_RESET_SWRST_CTL1_OFFSET + 19)
+#define NPCX_RESET_ITIM32_3 (NPCX_RESET_SWRST_CTL1_OFFSET + 20)
+#define NPCX_RESET_ITIM32_4 (NPCX_RESET_SWRST_CTL1_OFFSET + 21)
+#define NPCX_RESET_ITIM32_5 (NPCX_RESET_SWRST_CTL1_OFFSET + 22)
+#define NPCX_RESET_ITIM32_6 (NPCX_RESET_SWRST_CTL1_OFFSET + 23)
+#define NPCX_RESET_MTC      (NPCX_RESET_SWRST_CTL1_OFFSET + 25)
+#define NPCX_RESET_MIWU0    (NPCX_RESET_SWRST_CTL1_OFFSET + 26)
+#define NPCX_RESET_MIWU1    (NPCX_RESET_SWRST_CTL1_OFFSET + 27)
+#define NPCX_RESET_MIWU2    (NPCX_RESET_SWRST_CTL1_OFFSET + 28)
+#define NPCX_RESET_GDMA     (NPCX_RESET_SWRST_CTL1_OFFSET + 29)
+#define NPCX_RESET_FIU      (NPCX_RESET_SWRST_CTL1_OFFSET + 30)
+
+#define NPCX_RESET_PMC     (NPCX_RESET_SWRST_CTL2_OFFSET + 0)
+#define NPCX_RESET_SHI     (NPCX_RESET_SWRST_CTL2_OFFSET + 2)
+#define NPCX_RESET_SPIP    (NPCX_RESET_SWRST_CTL2_OFFSET + 3)
+#define NPCX_RESET_PECI    (NPCX_RESET_SWRST_CTL2_OFFSET + 5)
+#define NPCX_RESET_CRUART2 (NPCX_RESET_SWRST_CTL2_OFFSET + 6)
+#define NPCX_RESET_ADC     (NPCX_RESET_SWRST_CTL2_OFFSET + 7)
+#define NPCX_RESET_SMB0    (NPCX_RESET_SWRST_CTL2_OFFSET + 8)
+#define NPCX_RESET_SMB1    (NPCX_RESET_SWRST_CTL2_OFFSET + 9)
+#define NPCX_RESET_SMB2    (NPCX_RESET_SWRST_CTL2_OFFSET + 10)
+#define NPCX_RESET_SMB3    (NPCX_RESET_SWRST_CTL2_OFFSET + 11)
+#define NPCX_RESET_SMB4    (NPCX_RESET_SWRST_CTL2_OFFSET + 12)
+#define NPCX_RESET_SMB5    (NPCX_RESET_SWRST_CTL2_OFFSET + 13)
+#define NPCX_RESET_SMB6    (NPCX_RESET_SWRST_CTL2_OFFSET + 14)
+#define NPCX_RESET_TWD     (NPCX_RESET_SWRST_CTL2_OFFSET + 15)
+#define NPCX_RESET_PWM0    (NPCX_RESET_SWRST_CTL2_OFFSET + 16)
+#define NPCX_RESET_PWM1    (NPCX_RESET_SWRST_CTL2_OFFSET + 17)
+#define NPCX_RESET_PWM2    (NPCX_RESET_SWRST_CTL2_OFFSET + 18)
+#define NPCX_RESET_PWM3    (NPCX_RESET_SWRST_CTL2_OFFSET + 19)
+#define NPCX_RESET_PWM4    (NPCX_RESET_SWRST_CTL2_OFFSET + 20)
+#define NPCX_RESET_PWM5    (NPCX_RESET_SWRST_CTL2_OFFSET + 21)
+#define NPCX_RESET_PWM6    (NPCX_RESET_SWRST_CTL2_OFFSET + 22)
+#define NPCX_RESET_PWM7    (NPCX_RESET_SWRST_CTL2_OFFSET + 23)
+#define NPCX_RESET_MFT16_1 (NPCX_RESET_SWRST_CTL2_OFFSET + 24)
+#define NPCX_RESET_MFT16_2 (NPCX_RESET_SWRST_CTL2_OFFSET + 25)
+#define NPCX_RESET_MFT16_3 (NPCX_RESET_SWRST_CTL2_OFFSET + 26)
+#define NPCX_RESET_SMB7    (NPCX_RESET_SWRST_CTL2_OFFSET + 27)
+#define NPCX_RESET_CRUART1 (NPCX_RESET_SWRST_CTL2_OFFSET + 28)
+#define NPCX_RESET_PS2     (NPCX_RESET_SWRST_CTL2_OFFSET + 29)
+#define NPCX_RESET_SDP     (NPCX_RESET_SWRST_CTL2_OFFSET + 30)
+#define NPCX_RESET_KBS     (NPCX_RESET_SWRST_CTL2_OFFSET + 31)
+
+#define NPCX_RESET_SIOCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 0)
+#define NPCX_RESET_SERPORT (NPCX_RESET_SWRST_CTL3_OFFSET + 1)
+#define NPCX_RESET_I3C     (NPCX_RESET_SWRST_CTL3_OFFSET + 5)
+#define NPCX_RESET_MSWC    (NPCX_RESET_SWRST_CTL3_OFFSET + 8)
+#define NPCX_RESET_SHM     (NPCX_RESET_SWRST_CTL3_OFFSET + 9)
+#define NPCX_RESET_PMCH1   (NPCX_RESET_SWRST_CTL3_OFFSET + 10)
+#define NPCX_RESET_PMCH2   (NPCX_RESET_SWRST_CTL3_OFFSET + 11)
+#define NPCX_RESET_PMCH3   (NPCX_RESET_SWRST_CTL3_OFFSET + 12)
+#define NPCX_RESET_PMCH4   (NPCX_RESET_SWRST_CTL3_OFFSET + 13)
+#define NPCX_RESET_KBC     (NPCX_RESET_SWRST_CTL3_OFFSET + 15)
+#define NPCX_RESET_C2HOST  (NPCX_RESET_SWRST_CTL3_OFFSET + 16)
+#define NPCX_RESET_CRUART3 (NPCX_RESET_SWRST_CTL3_OFFSET + 18)
+#define NPCX_RESET_CRUART4 (NPCX_RESET_SWRST_CTL3_OFFSET + 19)
+#define NPCX_RESET_LFCG    (NPCX_RESET_SWRST_CTL3_OFFSET + 20)
+#define NPCX_RESET_DEV     (NPCX_RESET_SWRST_CTL3_OFFSET + 22)
+#define NPCX_RESET_SYSCFG  (NPCX_RESET_SWRST_CTL3_OFFSET + 23)
+#define NPCX_RESET_SBY     (NPCX_RESET_SWRST_CTL3_OFFSET + 24)
+#define NPCX_RESET_BBRAM   (NPCX_RESET_SWRST_CTL3_OFFSET + 25)
+#define NPCX_RESET_SHA     (NPCX_RESET_SWRST_CTL3_OFFSET + 29)
+
+#define NPCX_RESET_MDMA1 (NPCX_RESET_SWRST_CTL4_OFFSET + 24)
+#define NPCX_RESET_MDMA2 (NPCX_RESET_SWRST_CTL4_OFFSET + 25)
+#define NPCX_RESET_MDMA3 (NPCX_RESET_SWRST_CTL4_OFFSET + 26)
+#define NPCX_RESET_MDMA4 (NPCX_RESET_SWRST_CTL4_OFFSET + 27)
+#define NPCX_RESET_MDMA5 (NPCX_RESET_SWRST_CTL4_OFFSET + 28)
+
+#define NPCX_RESET_ID_START NPCX_RESET_GPIO0
+#define NPCX_RESET_ID_END   NPCX_RESET_MDMA5
+#endif
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index a4a23e543..01b4a365e 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -1746,4 +1746,12 @@ struct spip_reg {
 #define NPCX_SPIP_STAT_BSY              0
 #define NPCX_SPIP_STAT_RBF              1
 
+/* Software-triggered Pheripheral Reset Controller Register */
+struct swrst_reg {
+	/* 0x000: Software Reset Trigger */
+	volatile uint16_t SWRST_TRG;
+	volatile uint8_t reserved1[2];
+	volatile uint32_t SWRST_CTL[4];
+};
+
 #endif /* _NUVOTON_NPCX_REG_DEF_H */
diff --git a/soc/arm/nuvoton_npcx/common/registers.c b/soc/arm/nuvoton_npcx/common/registers.c
index 8c4ed132b..e12b3bc10 100644
--- a/soc/arm/nuvoton_npcx/common/registers.c
+++ b/soc/arm/nuvoton_npcx/common/registers.c
@@ -189,3 +189,11 @@ NPCX_REG_OFFSET_CHECK(kbs_reg, KBS_BUF_INDX, 0x00a);
 /* SPIP register structure check */
 NPCX_REG_SIZE_CHECK(spip_reg, 0x006);
 NPCX_REG_OFFSET_CHECK(spip_reg, SPIP_CTL1, 0x002);
+
+/* SWRST register structure check */
+NPCX_REG_SIZE_CHECK(swrst_reg, 0x014);
+NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_TRG, 0x000);
+NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[0], 0x004);
+NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[1], 0x008);
+NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[2], 0x00c);
+NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[3], 0x010);
-- 
2.17.1


From 21b06523433ba49b088b085e3f937580c21c0889 Mon Sep 17 00:00:00 2001
From: Tom Chang <CHChang19@nuvoton.com>
Date: Wed, 6 Mar 2024 10:23:33 +0800
Subject: [PATCH 12/42] drivers: espi: npcx: fix warning when using
 ESPI_OOB_RX_ASYNC macro

This CL prevents unused warnings when CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
is used.

Signed-off-by: Tom Chang <CHChang19@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_npcx.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 302aff132..42e559a8b 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -945,10 +945,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 				struct espi_oob_packet *pckt)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
-	struct espi_npcx_data *const data = dev->data;
 	uint8_t *oob_buf = pckt->buf;
 	uint32_t oob_data;
-	int idx_rx_buf, sz_oob_rx, ret;
+	int idx_rx_buf, sz_oob_rx;
 
 	/* Check eSPI bus status first */
 	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_BERR)) {
@@ -957,6 +956,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 	}
 
 #if !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
+	struct espi_npcx_data *const data = dev->data;
+	int ret;
+
 	/* Wait until get oob package or timeout */
 	ret = k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT));
 	if (ret == -EAGAIN) {
-- 
2.17.1


From 57060f5d454537037d097becbcbb1b78004a96c5 Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Wed, 17 Apr 2024 11:03:50 +0800
Subject: [PATCH 13/42] dts: arm: nuvoton: add I3C device nodes

Add I3C device nodes.

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/nuvoton/npcx/npcx4.dtsi | 77 +++++++++++++++++++++++++++++++++
 1 file changed, 77 insertions(+)

diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
index 9070b4a71..1a02a70d2 100644
--- a/dts/arm/nuvoton/npcx/npcx4.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -14,6 +14,8 @@
 #include "npcx4/npcx4-espi-vws-map.dtsi"
 /* npcx4 series low-voltage io controls mapping table */
 #include "npcx4/npcx4-lvol-ctrl-map.dtsi"
+/* npcx4 series reset mapping table*/
+#include "zephyr/dt-bindings/reset/npcx4_reset.h"
 
 /* Device tree declarations of npcx soc family */
 #include "npcx.dtsi"
@@ -324,6 +326,81 @@
 			#reset-cells = <1>;
 			status = "disabled";
 		};
+
+		i3c0: i3c@400f0000 {
+			compatible = "nuvoton,npcx-i3c";
+
+			/* reg[0]: I3C_1 register, reg[1]: MDMA5 register */
+			reg-names = "i3c1", "mdma5";
+			reg = <0x400f0000 0x2000>,
+			      <0x40011500 0x100>;
+
+			interrupts = <29 3>;
+
+			/* Reset controller */
+			resets = <&rctl NPCX_RESET_I3C_1>;
+
+			/* clk[0]: I3C source clock, clk[1]: timeout reference clock */
+			/* clk[2]: MDMA5 */
+			clock-names = "mclkd", "apb4", "mdma5";
+			clocks = <&pcc NPCX_CLOCK_BUS_MCLKD NPCX_PWDWN_CTL8 0>,
+				 <&pcc NPCX_CLOCK_BUS_APB4 0 0>,
+				 <&pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 4>;
+
+			status = "disabled";
+			#address-cells = <3>;
+			#size-cells = <0>;
+		};
+
+		i3c1: i3c@400f2000 {
+			compatible = "nuvoton,npcx-i3c";
+
+			/* reg[0]: I3C_2 register, reg[1]: MDMA6 register */
+			reg-names = "i3c2", "mdma6";
+			reg = <0x400f2000 0x2000>,
+			      <0x40011600 0x100>;
+
+			interrupts = <66 3>;
+
+			/* Reset controller */
+			resets = <&rctl NPCX_RESET_I3C_2>;
+
+			/* clk[0]: I3C source clock, clk[1]: timeout reference clock */
+			/* clk[2]: MDMA6 */
+			clock-names = "mclkd", "apb4", "mdma6";
+			clocks = <&pcc NPCX_CLOCK_BUS_MCLKD NPCX_PWDWN_CTL8 2>,
+				 <&pcc NPCX_CLOCK_BUS_APB4 0 0>,
+				 <&pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 5>;
+
+			status = "disabled";
+			#address-cells = <3>;
+			#size-cells = <0>;
+		};
+
+		i3c2: i3c@400f4000 {
+			compatible = "nuvoton,npcx-i3c";
+
+			/* reg[0]: I3C_3 register, reg[1]: MDMA7 register */
+			reg-names = "i3c1", "mdma7";
+			reg = <0x400f4000 0x2000>,
+			      <0x40011700 0x100>;
+
+			interrupts = <67 3>;
+
+			/* Reset controller */
+			resets = <&rctl NPCX_RESET_I3C_3>;
+
+			/* clk[0]: I3C source clock, clk[1]: timeout reference clock */
+			/* clk[2]: MDMA7 */
+			clock-names = "mclkd", "apb4", "mdma7";
+			clocks = <&pcc NPCX_CLOCK_BUS_MCLKD NPCX_PWDWN_CTL8 3>,
+				 <&pcc NPCX_CLOCK_BUS_APB4 0 0>,
+				 <&pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 6>;
+
+			status = "disabled";
+			#address-cells = <3>;
+			#size-cells = <0>;
+		};
 	};
 
 	soc-if {
-- 
2.17.1


From 7fbef831827ab0423ec4826644f99c45061f679c Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Wed, 17 Apr 2024 11:04:47 +0800
Subject: [PATCH 14/42] boards: nuvoton: npcx4m8f_evb: add i3c pinctrl

Add I3C pinmux configuration.

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
index a34002e8b..b90d94b0c 100644
--- a/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
@@ -118,3 +118,18 @@
 		compatible = "zephyr,kscan-input";
 	};
 };
+
+&i3c0 {
+	pinctrl-0 = <&i3c1_sda_scl_gpe3_e4>;
+	pinctrl-names = "default";
+};
+
+&i3c1 {
+	pinctrl-0 = <&i3c2_sda_scl_gp50_56>;
+	pinctrl-names = "default";
+};
+
+&i3c2 {
+	pinctrl-0 = <&i3c3_sda_scl_gpf4_f5>;
+	pinctrl-names = "default";
+};
-- 
2.17.1


From 444e125bddc1968edf9f00dc50ec66a4e6c46180 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Tue, 23 Apr 2024 14:32:36 +0800
Subject: [PATCH 15/42] driver: uart: npcx: fix coding style

Fix the coding style by clang-format tool.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/serial/uart_npcx.c | 75 ++++++++++++++++++++------------------
 1 file changed, 39 insertions(+), 36 deletions(-)

diff --git a/drivers/serial/uart_npcx.c b/drivers/serial/uart_npcx.c
index 979cbd038..a698130ff 100644
--- a/drivers/serial/uart_npcx.c
+++ b/drivers/serial/uart_npcx.c
@@ -71,7 +71,7 @@ static void uart_npcx_pm_policy_state_lock_get(struct uart_npcx_data *data,
 }
 
 static void uart_npcx_pm_policy_state_lock_put(struct uart_npcx_data *data,
-					    enum uart_pm_policy_state_flag flag)
+					       enum uart_pm_policy_state_flag flag)
 {
 	if (atomic_test_and_clear_bit(data->pm_policy_state_flag, flag) == 1) {
 		pm_policy_state_lock_put(PM_STATE_SUSPEND_TO_IDLE, PM_ALL_SUBSTATES);
@@ -125,8 +125,7 @@ static void uart_npcx_dis_all_tx_interrupts(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* Disable all Tx interrupts */
-	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_LVL_EN) |
-			  BIT(NPCX_UFTCTL_TEMPTY_EN) |
+	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_LVL_EN) | BIT(NPCX_UFTCTL_TEMPTY_EN) |
 			  BIT(NPCX_UFTCTL_NXMIP_EN));
 }
 
@@ -137,8 +136,9 @@ static void uart_npcx_clear_rx_fifo(const struct device *dev)
 	uint8_t scratch;
 
 	/* Read all dummy bytes out from Rx FIFO */
-	while (uart_npcx_rx_fifo_available(dev))
+	while (uart_npcx_rx_fifo_available(dev)) {
 		scratch = inst->URBUF;
+	}
 }
 
 static int uart_npcx_fifo_fill(const struct device *dev, const uint8_t *tx_data, int size)
@@ -271,7 +271,7 @@ static void uart_npcx_irq_err_disable(const struct device *dev)
 static int uart_npcx_irq_is_pending(const struct device *dev)
 {
 	return uart_npcx_irq_tx_ready(dev) ||
-		(uart_npcx_irq_rx_ready(dev) && uart_npcx_irq_rx_is_enabled(dev));
+	       (uart_npcx_irq_rx_ready(dev) && uart_npcx_irq_rx_is_enabled(dev));
 }
 
 static int uart_npcx_irq_update(const struct device *dev)
@@ -341,11 +341,12 @@ static int uart_npcx_poll_in(const struct device *dev, unsigned char *c)
  */
 static void uart_npcx_poll_out(const struct device *dev, unsigned char c)
 {
-	while (!uart_npcx_fifo_fill(dev, &c, 1))
+	while (!uart_npcx_fifo_fill(dev, &c, 1)) {
 		continue;
+	}
 }
 
-#else /* !CONFIG_UART_INTERRUPT_DRIVEN */
+#else  /* !CONFIG_UART_INTERRUPT_DRIVEN */
 
 /*
  * Poll-in implementation for byte mode config, read byte from URBUF if
@@ -357,8 +358,9 @@ static int uart_npcx_poll_in(const struct device *dev, unsigned char *c)
 	struct uart_reg *const inst = config->inst;
 
 	/* Rx single byte buffer is not full */
-	if (!IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_RBF))
+	if (!IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_RBF)) {
 		return -1;
+	}
 
 	*c = inst->URBUF;
 	return 0;
@@ -373,8 +375,9 @@ static void uart_npcx_poll_out(const struct device *dev, unsigned char c)
 	struct uart_reg *const inst = config->inst;
 
 	/* Wait while Tx single byte buffer is ready to send */
-	while (!IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_TBE))
+	while (!IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_TBE)) {
 		continue;
+	}
 
 	inst->UTBUF = c;
 }
@@ -388,14 +391,17 @@ static int uart_npcx_err_check(const struct device *dev)
 	uint32_t err = 0U;
 	uint8_t stat = inst->USTAT;
 
-	if (IS_BIT_SET(stat, NPCX_USTAT_DOE))
+	if (IS_BIT_SET(stat, NPCX_USTAT_DOE)) {
 		err |= UART_ERROR_OVERRUN;
+	}
 
-	if (IS_BIT_SET(stat, NPCX_USTAT_PE))
+	if (IS_BIT_SET(stat, NPCX_USTAT_PE)) {
 		err |= UART_ERROR_PARITY;
+	}
 
-	if (IS_BIT_SET(stat, NPCX_USTAT_FE))
+	if (IS_BIT_SET(stat, NPCX_USTAT_FE)) {
 		err |= UART_ERROR_FRAMING;
+	}
 
 	return err;
 }
@@ -480,8 +486,7 @@ static int uart_npcx_init(const struct device *dev)
 	 * If apb2's clock is not 15MHz, we need to find the other optimized
 	 * values of UPSR and UBAUD for baud rate 115200.
 	 */
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg,
-				     &uart_rate);
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg, &uart_rate);
 	if (ret < 0) {
 		LOG_ERR("Get UART clock rate error %d", ret);
 		return ret;
@@ -560,32 +565,30 @@ static int uart_npcx_init(const struct device *dev)
 #define NPCX_UART_IRQ_CONFIG_FUNC(inst)
 #endif
 
-#define NPCX_UART_INIT(i)                                                                       \
-	NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                      \
-												\
-	PINCTRL_DT_INST_DEFINE(i);                                                              \
-												\
-	static const struct uart_npcx_config uart_npcx_cfg_##i = {                              \
-		.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                 \
-		.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                             \
-		.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                            \
-		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                      \
-		NPCX_UART_IRQ_CONFIG_FUNC_INIT(i)                                               \
-	};                                                                                      \
-												\
-	static struct uart_npcx_data uart_npcx_data_##i = { .baud_rate = DT_INST_PROP(          \
-								       i, current_speed) };     \
-												\
-	DEVICE_DT_INST_DEFINE(i, &uart_npcx_init, NULL, &uart_npcx_data_##i,                    \
-			      &uart_npcx_cfg_##i, PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,    \
-			      &uart_npcx_driver_api);                                           \
-												\
+#define NPCX_UART_INIT(i)                                                                          \
+	NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                         \
+                                                                                                   \
+	PINCTRL_DT_INST_DEFINE(i);                                                                 \
+                                                                                                   \
+	static const struct uart_npcx_config uart_npcx_cfg_##i = {                                 \
+		.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                    \
+		.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                                \
+		.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                               \
+		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                         \
+		NPCX_UART_IRQ_CONFIG_FUNC_INIT(i)};                                                \
+                                                                                                   \
+	static struct uart_npcx_data uart_npcx_data_##i = {                                        \
+		.baud_rate = DT_INST_PROP(i, current_speed)};                                      \
+                                                                                                   \
+	DEVICE_DT_INST_DEFINE(i, &uart_npcx_init, NULL, &uart_npcx_data_##i, &uart_npcx_cfg_##i,   \
+			      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY, &uart_npcx_driver_api);   \
+                                                                                                   \
 	NPCX_UART_IRQ_CONFIG_FUNC(i)
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_UART_INIT)
 
-#define ENABLE_MIWU_CRIN_IRQ(i)                                                                 \
-	npcx_miwu_irq_get_and_clear_pending(&uart_npcx_cfg_##i.uart_rx_wui);                    \
+#define ENABLE_MIWU_CRIN_IRQ(i)                                                                    \
+	npcx_miwu_irq_get_and_clear_pending(&uart_npcx_cfg_##i.uart_rx_wui);                       \
 	npcx_miwu_irq_enable(&uart_npcx_cfg_##i.uart_rx_wui);
 
 #define DISABLE_MIWU_CRIN_IRQ(i) npcx_miwu_irq_disable(&uart_npcx_cfg_##i.uart_rx_wui);
-- 
2.17.1


From 7b4859ed1e6d8250220e6b7c35950335e180bce1 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Tue, 23 Apr 2024 14:33:09 +0800
Subject: [PATCH 16/42] drivers: uart: npcx: add asychronous API support

This commit implement the UART asynchronous API mode support.
When the API is used, the UART hardware cooperates with the DMA (MDMA)
module to handle the the data transfer and receiving.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/serial/Kconfig.npcx               |  11 +
 drivers/serial/uart_npcx.c                | 654 ++++++++++++++++++++--
 dts/arm/nuvoton/npcx/npcx4.dtsi           |  24 +-
 dts/arm/nuvoton/npcx/npcx9.dtsi           |  28 +-
 soc/arm/nuvoton_npcx/common/reg/reg_def.h |   3 +
 5 files changed, 650 insertions(+), 70 deletions(-)

diff --git a/drivers/serial/Kconfig.npcx b/drivers/serial/Kconfig.npcx
index 07a4b02a0..6284ed3a3 100644
--- a/drivers/serial/Kconfig.npcx
+++ b/drivers/serial/Kconfig.npcx
@@ -3,6 +3,8 @@
 # Copyright (c) 2020 Nuvoton Technology Corporation.
 # SPDX-License-Identifier: Apache-2.0
 
+DT_UART_NPCX:=$(dt_nodelabel_path,uart1)
+
 config UART_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) serial driver"
 	default y
@@ -13,3 +15,12 @@ config UART_NPCX
 	  This option enables the UART driver for NPCX family of
 	  processors.
 	  Say y if you wish to use serial port on NPCX MCU.
+
+# Expose this option when the reg porperty has two register base address.
+# i.e. One UART register bass address and one MDMA register base address.
+config UART_NPCX_USE_MDMA
+	bool "Nuvoton NPCX embedded controller (EC) serial driver DMA support"
+	depends on UART_NPCX && "$(dt_node_reg_addr_hex,$(DT_UART_NPCX),1)" != 0
+	select SERIAL_SUPPORT_ASYNC
+	help
+	  Enable support for npcx UART DMA mode.
diff --git a/drivers/serial/uart_npcx.c b/drivers/serial/uart_npcx.c
index a698130ff..8e25da50d 100644
--- a/drivers/serial/uart_npcx.c
+++ b/drivers/serial/uart_npcx.c
@@ -25,7 +25,7 @@ LOG_MODULE_REGISTER(uart_npcx, CONFIG_UART_LOG_LEVEL);
 /* Driver config */
 struct uart_npcx_config {
 	struct uart_reg *inst;
-#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN) || defined(CONFIG_UART_ASYNC_API)
 	uart_irq_config_func_t irq_config_func;
 #endif
 	/* clock configuration */
@@ -34,6 +34,10 @@ struct uart_npcx_config {
 	const struct npcx_wui uart_rx_wui;
 	/* pinmux configuration */
 	const struct pinctrl_dev_config *pcfg;
+#ifdef CONFIG_UART_ASYNC_API
+	struct npcx_clk_cfg mdma_clk_cfg;
+	struct mdma_reg *mdma_reg_base;
+#endif
 };
 
 enum uart_pm_policy_state_flag {
@@ -43,6 +47,36 @@ enum uart_pm_policy_state_flag {
 	UART_PM_POLICY_STATE_FLAG_COUNT,
 };
 
+#ifdef CONFIG_UART_ASYNC_API
+struct uart_npcx_rx_dma_params {
+	uint8_t *buf;
+	size_t buf_len;
+	size_t offset;
+	size_t counter;
+	size_t timeout_us;
+	struct k_work_delayable timeout_work;
+	bool enabled;
+};
+
+struct uart_npcx_tx_dma_params {
+	const uint8_t *buf;
+	size_t buf_len;
+	struct k_work_delayable timeout_work;
+	size_t timeout_us;
+};
+
+struct uart_npcx_async_data {
+	const struct device *uart_dev;
+	uart_callback_t user_callback;
+	void *user_data;
+	struct uart_npcx_rx_dma_params rx_dma_params;
+	struct uart_npcx_tx_dma_params tx_dma_params;
+	uint8_t *next_rx_buffer;
+	size_t next_rx_buffer_len;
+	bool tx_in_progress;
+};
+#endif
+
 /* Driver data */
 struct uart_npcx_data {
 	/* Baud rate */
@@ -59,6 +93,9 @@ struct uart_npcx_data {
 	struct k_work_delayable rx_refresh_timeout_work;
 #endif
 #endif
+#ifdef CONFIG_UART_ASYNC_API
+	struct uart_npcx_async_data async;
+#endif
 };
 
 #ifdef CONFIG_PM
@@ -100,16 +137,7 @@ static int uart_set_npcx_baud_rate(struct uart_reg *const inst, int baud_rate, i
 	return 0;
 }
 
-#ifdef CONFIG_UART_INTERRUPT_DRIVEN
-static int uart_npcx_tx_fifo_ready(const struct device *dev)
-{
-	const struct uart_npcx_config *const config = dev->config;
-	struct uart_reg *const inst = config->inst;
-
-	/* True if the Tx FIFO is not completely full */
-	return !(GET_FIELD(inst->UFTSTS, NPCX_UFTSTS_TEMPTY_LVL) == 0);
-}
-
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN) || defined(CONFIG_UART_ASYNC_API)
 static int uart_npcx_rx_fifo_available(const struct device *dev)
 {
 	const struct uart_npcx_config *const config = dev->config;
@@ -141,6 +169,18 @@ static void uart_npcx_clear_rx_fifo(const struct device *dev)
 	}
 }
 
+#endif
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+static int uart_npcx_tx_fifo_ready(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+
+	/* True if the Tx FIFO is not completely full */
+	return !(GET_FIELD(inst->UFTSTS, NPCX_UFTSTS_TEMPTY_LVL) == 0);
+}
+
 static int uart_npcx_fifo_fill(const struct device *dev, const uint8_t *tx_data, int size)
 {
 	const struct uart_npcx_config *const config = dev->config;
@@ -288,42 +328,11 @@ static void uart_npcx_irq_callback_set(const struct device *dev, uart_irq_callba
 
 	data->user_cb = cb;
 	data->user_data = cb_data;
-}
-
-static void uart_npcx_isr(const struct device *dev)
-{
-	struct uart_npcx_data *data = dev->data;
-
-	/*
-	 * Set pm constraint to prevent the system enter suspend state within
-	 * the CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT period.
-	 */
-#ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
-	if (uart_npcx_irq_rx_ready(dev)) {
-		k_timeout_t delay = K_MSEC(CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT);
 
-		uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_RX_FLAG);
-		k_work_reschedule(&data->rx_refresh_timeout_work, delay);
-	}
+#if defined(CONFIG_UART_EXCLUSIVE_API_CALLBACKS)
+	data->async.user_callback = NULL;
+	data->async.user_data = NULL;
 #endif
-
-	if (data->user_cb) {
-		data->user_cb(dev, data->user_data);
-	}
-#ifdef CONFIG_PM
-	const struct uart_npcx_config *const config = dev->config;
-	struct uart_reg *const inst = config->inst;
-
-	if (IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_NXMIP_EN) &&
-	    IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP)) {
-		k_spinlock_key_t key = k_spin_lock(&data->lock);
-
-		/* Disable NXMIP interrupt */
-		inst->UFTCTL &= ~BIT(NPCX_UFTCTL_NXMIP_EN);
-		k_spin_unlock(&data->lock, key);
-		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
-	}
-#endif /* CONFIG_PM */
 }
 
 /*
@@ -383,6 +392,509 @@ static void uart_npcx_poll_out(const struct device *dev, unsigned char c)
 }
 #endif /* !CONFIG_UART_INTERRUPT_DRIVEN */
 
+#ifdef CONFIG_UART_ASYNC_API
+static void async_user_callback(const struct device *dev, struct uart_event *evt)
+{
+	const struct uart_npcx_data *data = dev->data;
+
+	if (data->async.user_callback) {
+		data->async.user_callback(dev, evt, data->async.user_data);
+	}
+}
+
+static void async_evt_rx_rdy(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+
+	struct uart_event event = {.type = UART_RX_RDY,
+				   .data.rx.buf = rx_dma_params->buf,
+				   .data.rx.len = rx_dma_params->counter - rx_dma_params->offset,
+				   .data.rx.offset = rx_dma_params->offset};
+
+	LOG_DBG("RX Ready: (len: %d off: %d buf: %x)", event.data.rx.len, event.data.rx.offset,
+		(uint32_t)event.data.rx.buf);
+
+	/* Update the current pos for new data */
+	rx_dma_params->offset = rx_dma_params->counter;
+
+	/* Only send event for new data */
+	if (event.data.rx.len > 0) {
+		async_user_callback(dev, &event);
+	}
+}
+
+static void async_evt_tx_done(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+
+	(void)k_work_cancel_delayable(&data->async.tx_dma_params.timeout_work);
+
+	LOG_DBG("TX done: %d", data->async.tx_dma_params.buf_len);
+
+	struct uart_event event = {.type = UART_TX_DONE,
+				   .data.tx.buf = data->async.tx_dma_params.buf,
+				   .data.tx.len = data->async.tx_dma_params.buf_len};
+
+	/* Reset TX Buffer */
+	data->async.tx_dma_params.buf = NULL;
+	data->async.tx_dma_params.buf_len = 0U;
+	async_user_callback(dev, &event);
+}
+
+static void uart_npcx_async_rx_dma_get_status(const struct device *dev, size_t *pending_length)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+
+	if (IS_BIT_SET(mdma_reg_base->MDMA_CTL0, NPCX_MDMA_CTL_MDMAEN)) {
+		*pending_length = mdma_reg_base->MDMA_CTCNT0;
+	} else {
+		*pending_length = 0;
+	}
+}
+
+static void uart_npcx_async_rx_flush(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+	size_t curr_rcv_len, dma_pending_len;
+
+	uart_npcx_async_rx_dma_get_status(dev, &dma_pending_len);
+	curr_rcv_len = rx_dma_params->buf_len - dma_pending_len;
+
+	if (curr_rcv_len > rx_dma_params->offset) {
+		rx_dma_params->counter = curr_rcv_len;
+		async_evt_rx_rdy(dev);
+#ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
+		k_timeout_t delay = K_MSEC(CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT);
+
+		uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_RX_FLAG);
+		k_work_reschedule(&data->rx_refresh_timeout_work, delay);
+#endif
+	}
+}
+
+static void async_evt_rx_buf_request(const struct device *dev)
+{
+	struct uart_event evt = {
+		.type = UART_RX_BUF_REQUEST,
+	};
+
+	async_user_callback(dev, &evt);
+}
+
+static int uart_npcx_async_callback_set(const struct device *dev, uart_callback_t callback,
+					void *user_data)
+{
+	struct uart_npcx_data *data = dev->data;
+
+	data->async.user_callback = callback;
+	data->async.user_data = user_data;
+
+#if defined(CONFIG_UART_EXCLUSIVE_API_CALLBACKS)
+	data->user_cb = NULL;
+	data->user_data = NULL;
+#endif
+
+	return 0;
+}
+
+static inline void async_timer_start(struct k_work_delayable *work, uint32_t timeout_us)
+{
+	if ((timeout_us != SYS_FOREVER_US) && (timeout_us != 0)) {
+		LOG_DBG("async timer started for %d us", timeout_us);
+		k_work_reschedule(work, K_USEC(timeout_us));
+	}
+}
+
+static int uart_npcx_async_tx_dma_get_status(const struct device *dev, size_t *pending_length)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+
+	if (IS_BIT_SET(mdma_reg_base->MDMA_CTL1, NPCX_MDMA_CTL_MDMAEN)) {
+		*pending_length = mdma_reg_base->MDMA_CTCNT1;
+	} else {
+		*pending_length = 0;
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int uart_npcx_async_tx(const struct device *dev, const uint8_t *buf, size_t len,
+			      int32_t timeout)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_tx_dma_params *tx_dma_params = &data->async.tx_dma_params;
+	int key = irq_lock();
+
+	if (buf == NULL || len == 0) {
+		irq_unlock(key);
+		return -EINVAL;
+	}
+
+	if (tx_dma_params->buf) {
+		irq_unlock(key);
+		return -EBUSY;
+	}
+
+	data->async.tx_in_progress = true;
+
+	data->async.tx_dma_params.buf = buf;
+	data->async.tx_dma_params.buf_len = len;
+	data->async.tx_dma_params.timeout_us = timeout;
+
+	mdma_reg_base->MDMA_SRCB1 = (uint32_t)buf;
+	mdma_reg_base->MDMA_TCNT1 = len;
+
+	async_timer_start(&data->async.tx_dma_params.timeout_work, timeout);
+	mdma_reg_base->MDMA_CTL1 |= BIT(NPCX_MDMA_CTL_MDMAEN) | BIT(NPCX_MDMA_CTL_SIEN);
+
+	inst->UMDSL |= BIT(NPCX_UMDSL_ETD);
+
+#ifdef CONFIG_PM
+	/* Do not allow system to suspend until transmission has completed */
+	uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_TX_FLAG);
+#endif
+	irq_unlock(key);
+
+	return 0;
+}
+
+static int uart_npcx_async_tx_abort(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_npcx_data *data = dev->data;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+	size_t dma_pending_len, bytes_transmitted;
+	int ret;
+
+	k_work_cancel_delayable(&data->async.tx_dma_params.timeout_work);
+
+	mdma_reg_base->MDMA_CTL1 &= ~BIT(NPCX_MDMA_CTL_MDMAEN);
+
+	ret = uart_npcx_async_tx_dma_get_status(dev, &dma_pending_len);
+	if (ret != 0) {
+		bytes_transmitted = 0;
+	} else {
+		bytes_transmitted = data->async.tx_dma_params.buf_len - dma_pending_len;
+	}
+
+	struct uart_event tx_aborted_event = {
+		.type = UART_TX_ABORTED,
+		.data.tx.buf = data->async.tx_dma_params.buf,
+		.data.tx.len = bytes_transmitted,
+	};
+	async_user_callback(dev, &tx_aborted_event);
+
+	return ret;
+}
+
+static void uart_npcx_async_tx_timeout(struct k_work *work)
+{
+	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
+	struct uart_npcx_tx_dma_params *tx_params =
+		CONTAINER_OF(dwork, struct uart_npcx_tx_dma_params, timeout_work);
+	struct uart_npcx_async_data *async_data =
+		CONTAINER_OF(tx_params, struct uart_npcx_async_data, tx_dma_params);
+	const struct device *dev = async_data->uart_dev;
+
+	LOG_ERR("Async Tx Timeout");
+	uart_npcx_async_tx_abort(dev);
+}
+
+static int uart_npcx_async_rx_enable(const struct device *dev, uint8_t *buf, const size_t len,
+				     const int32_t timeout_us)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+	unsigned int key;
+
+	LOG_DBG("Enable RX DMA, len:%d", len);
+
+	key = irq_lock();
+
+	__ASSERT_NO_MSG(buf != NULL);
+	__ASSERT_NO_MSG(len > 0);
+
+	rx_dma_params->timeout_us = timeout_us;
+	rx_dma_params->buf = buf;
+	rx_dma_params->buf_len = len;
+
+	rx_dma_params->offset = 0;
+	rx_dma_params->counter = 0;
+
+	SET_FIELD(inst->UFRCTL, NPCX_UFRCTL_RFULL_LVL_SEL, 1);
+
+	mdma_reg_base->MDMA_DSTB0 = (uint32_t)buf;
+	mdma_reg_base->MDMA_TCNT0 = len;
+	mdma_reg_base->MDMA_CTL0 |= BIT(NPCX_MDMA_CTL_MDMAEN) | BIT(NPCX_MDMA_CTL_SIEN);
+
+	inst->UMDSL |= BIT(NPCX_UMDSL_ERD);
+
+	rx_dma_params->enabled = true;
+
+	async_evt_rx_buf_request(dev);
+
+	inst->UFRCTL |= BIT(NPCX_UFRCTL_RNEMPTY_EN);
+
+	irq_unlock(key);
+
+	return 0;
+}
+
+static void async_evt_rx_buf_release(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+	struct uart_event evt = {
+		.type = UART_RX_BUF_RELEASED,
+		.data.rx_buf.buf = data->async.rx_dma_params.buf,
+	};
+
+	async_user_callback(dev, &evt);
+	data->async.rx_dma_params.buf = NULL;
+	data->async.rx_dma_params.buf_len = 0U;
+	data->async.rx_dma_params.offset = 0U;
+	data->async.rx_dma_params.counter = 0U;
+}
+
+static int uart_npcx_async_rx_disable(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+	struct uart_npcx_data *data = dev->data;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+	unsigned int key;
+
+	LOG_DBG("Async RX Disable");
+
+	key = irq_lock();
+	inst->UFRCTL &= ~(BIT(NPCX_UFRCTL_RNEMPTY_EN));
+
+	k_work_cancel_delayable(&rx_dma_params->timeout_work);
+
+	if (rx_dma_params->buf == NULL) {
+		LOG_DBG("No buffers to release from RX DMA!");
+	} else {
+		uart_npcx_async_rx_flush(dev);
+		async_evt_rx_buf_release(dev);
+	}
+
+	rx_dma_params->enabled = false;
+
+	if (data->async.next_rx_buffer != NULL) {
+		rx_dma_params->buf = data->async.next_rx_buffer;
+		rx_dma_params->buf_len = data->async.next_rx_buffer_len;
+		data->async.next_rx_buffer = NULL;
+		data->async.next_rx_buffer_len = 0;
+		/* Release the next buffer as well */
+		async_evt_rx_buf_release(dev);
+	}
+
+	mdma_reg_base->MDMA_CTL0 &= ~BIT(NPCX_MDMA_CTL_MDMAEN);
+
+	struct uart_event disabled_event = {.type = UART_RX_DISABLED};
+
+	async_user_callback(dev, &disabled_event);
+
+	irq_unlock(key);
+
+	return 0;
+}
+
+static int uart_npcx_async_rx_buf_rsp(const struct device *dev, uint8_t *buf, size_t len)
+{
+	struct uart_npcx_data *data = dev->data;
+
+	if (data->async.next_rx_buffer != NULL) {
+		return -EBUSY;
+	} else if (data->async.rx_dma_params.enabled == false) {
+		return -EACCES;
+	}
+
+	data->async.next_rx_buffer = buf;
+	data->async.next_rx_buffer_len = len;
+
+	LOG_DBG("Next RX buf rsp, new: %d", len);
+
+	return 0;
+}
+
+static void uart_npcx_async_rx_timeout(struct k_work *work)
+{
+	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
+	struct uart_npcx_rx_dma_params *rx_params =
+		CONTAINER_OF(dwork, struct uart_npcx_rx_dma_params, timeout_work);
+	struct uart_npcx_async_data *async_data =
+		CONTAINER_OF(rx_params, struct uart_npcx_async_data, rx_dma_params);
+	const struct device *dev = async_data->uart_dev;
+
+	LOG_DBG("Async RX timeout");
+	uart_npcx_async_rx_flush(dev);
+}
+
+static void uart_npcx_async_dma_load_new_rx_buf(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+	struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+
+	rx_dma_params->offset = 0;
+	rx_dma_params->counter = 0;
+
+	rx_dma_params->buf = data->async.next_rx_buffer;
+	rx_dma_params->buf_len = data->async.next_rx_buffer_len;
+	data->async.next_rx_buffer = NULL;
+	data->async.next_rx_buffer_len = 0;
+
+	mdma_reg_base->MDMA_DSTB0 = (uint32_t)rx_dma_params->buf;
+	mdma_reg_base->MDMA_TCNT0 = rx_dma_params->buf_len;
+	mdma_reg_base->MDMA_CTL0 |= BIT(NPCX_MDMA_CTL_MDMAEN) | BIT(NPCX_MDMA_CTL_SIEN);
+	inst->UMDSL |= BIT(NPCX_UMDSL_ERD);
+}
+
+/* DMA rx reaches the terminal Count */
+static void uart_npcx_async_dma_rx_complete(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+	struct uart_npcx_rx_dma_params *rx_dma_params = &data->async.rx_dma_params;
+
+	rx_dma_params->counter = rx_dma_params->buf_len;
+
+	async_evt_rx_rdy(dev);
+
+	/* A new buffer was available.  */
+	if (data->async.next_rx_buffer != NULL) {
+		async_evt_rx_buf_release(dev);
+		uart_npcx_async_dma_load_new_rx_buf(dev);
+		/* Request the next buffer */
+		async_evt_rx_buf_request(dev);
+		async_timer_start(&rx_dma_params->timeout_work, rx_dma_params->timeout_us);
+	} else {
+		/* Buffer full without valid next buffer, disable RX DMA */
+		LOG_DBG("Disabled RX DMA, no valid next buffer ");
+		uart_npcx_async_rx_disable(dev);
+	}
+}
+#endif
+
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN) || defined(CONFIG_UART_ASYNC_API)
+static void uart_npcx_isr(const struct device *dev)
+{
+	struct uart_npcx_data *data = dev->data;
+#if defined(CONFIG_PM) || defined(CONFIG_UART_ASYNC_API)
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+#endif
+
+	/*
+	 * Set pm constraint to prevent the system enter suspend state within
+	 * the CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT period.
+	 */
+#ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
+	if (uart_npcx_irq_rx_ready(dev)) {
+		k_timeout_t delay = K_MSEC(CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT);
+
+		uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_RX_FLAG);
+		k_work_reschedule(&data->rx_refresh_timeout_work, delay);
+	}
+#endif
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (data->user_cb) {
+		data->user_cb(dev, data->user_data);
+	}
+#endif
+
+#ifdef CONFIG_UART_ASYNC_API
+	if (data->async.user_callback) {
+		struct mdma_reg *const mdma_reg_base = config->mdma_reg_base;
+
+		/*
+		 * Check rx in any way because the RFIFO_NEMPTY_STS is not valid when MDMA mode is
+		 * used. This is needed when the rx timeout_us is zero. In the case that the
+		 * rx timeout_us is not zero, rx_flush is done in the tiemout_work callback.
+		 */
+		if (data->async.rx_dma_params.timeout_us == 0) {
+			uart_npcx_async_rx_flush(dev);
+		} else if (IS_BIT_SET(inst->UFRCTL, NPCX_UFRCTL_RNEMPTY_EN)) {
+			async_timer_start(&data->async.rx_dma_params.timeout_work,
+					  data->async.rx_dma_params.timeout_us);
+		}
+
+		/* MDMA rx end interrupt */
+		if (IS_BIT_SET(mdma_reg_base->MDMA_CTL0, NPCX_MDMA_CTL_TC) &&
+		    IS_BIT_SET(mdma_reg_base->MDMA_CTL0, NPCX_MDMA_CTL_SIEN)) {
+			mdma_reg_base->MDMA_CTL0 &= ~BIT(NPCX_MDMA_CTL_SIEN);
+			/* TC is write-0-clear bit */
+			mdma_reg_base->MDMA_CTL0 &= ~BIT(NPCX_MDMA_CTL_TC);
+			inst->UMDSL &= ~BIT(NPCX_UMDSL_ERD);
+			uart_npcx_async_dma_rx_complete(dev);
+			LOG_DBG("DMA Rx TC");
+		}
+
+		/* MDMA tx done interrupt */
+		if (IS_BIT_SET(mdma_reg_base->MDMA_CTL1, NPCX_MDMA_CTL_TC) &&
+		    IS_BIT_SET(mdma_reg_base->MDMA_CTL1, NPCX_MDMA_CTL_SIEN)) {
+			mdma_reg_base->MDMA_CTL1 &= ~BIT(NPCX_MDMA_CTL_SIEN);
+			/* TC is write-0-clear bit */
+			mdma_reg_base->MDMA_CTL1 &= ~BIT(NPCX_MDMA_CTL_TC);
+
+			/*
+			 * MDMA tx is done (i.e. all data in the memory are moved to UART tx FIFO),
+			 * but data in the tx FIFO are not completely sent to the bus.
+			 */
+			if (!IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP)) {
+				k_spinlock_key_t key = k_spin_lock(&data->lock);
+
+				inst->UFTCTL |= BIT(NPCX_UFTCTL_NXMIP_EN);
+				k_spin_unlock(&data->lock, key);
+			} else {
+				data->async.tx_in_progress = false;
+#ifdef CONFIG_PM
+				uart_npcx_pm_policy_state_lock_put(data,
+								   UART_PM_POLICY_STATE_TX_FLAG);
+#endif /* CONFIG_PM */
+				async_evt_tx_done(dev);
+			}
+		}
+	}
+#endif
+
+#if defined(CONFIG_PM) || defined(CONFIG_UART_ASYNC_API)
+	if (IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_NXMIP_EN) &&
+	    IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP)) {
+		k_spinlock_key_t key = k_spin_lock(&data->lock);
+
+		/* Disable NXMIP interrupt */
+		inst->UFTCTL &= ~BIT(NPCX_UFTCTL_NXMIP_EN);
+		k_spin_unlock(&data->lock, key);
+#ifdef CONFIG_PM
+		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
+#endif
+#ifdef CONFIG_UART_ASYNC_API
+		if (data->async.tx_in_progress) {
+			data->async.tx_in_progress = false;
+			async_evt_tx_done(dev);
+			LOG_DBG("Tx wait-empty done");
+		}
+#endif
+	}
+#endif
+}
+#endif
+
 /* UART api functions */
 static int uart_npcx_err_check(const struct device *dev)
 {
@@ -412,6 +924,7 @@ static __unused void uart_npcx_rx_wk_isr(const struct device *dev, struct npcx_w
 	 * Set pm constraint to prevent the system enter suspend state within
 	 * the CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT period.
 	 */
+	LOG_DBG("-->%s", dev->name);
 #ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
 	struct uart_npcx_data *data = dev->data;
 	k_timeout_t delay = K_MSEC(CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT);
@@ -459,6 +972,14 @@ static const struct uart_driver_api uart_npcx_driver_api = {
 	.irq_update = uart_npcx_irq_update,
 	.irq_callback_set = uart_npcx_irq_callback_set,
 #endif /* CONFIG_UART_INTERRUPT_DRIVEN */
+#ifdef CONFIG_UART_ASYNC_API
+	.callback_set = uart_npcx_async_callback_set,
+	.tx = uart_npcx_async_tx,
+	.tx_abort = uart_npcx_async_tx_abort,
+	.rx_enable = uart_npcx_async_rx_enable,
+	.rx_buf_rsp = uart_npcx_async_rx_buf_rsp,
+	.rx_disable = uart_npcx_async_rx_disable,
+#endif /* CONFIG_UART_ASYNC_API */
 };
 
 static int uart_npcx_init(const struct device *dev)
@@ -482,6 +1003,14 @@ static int uart_npcx_init(const struct device *dev)
 		return ret;
 	}
 
+#ifdef CONFIG_UART_ASYNC_API
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->mdma_clk_cfg);
+	if (ret < 0) {
+		LOG_ERR("Turn on UART MDMA clock fail %d", ret);
+		return ret;
+	}
+#endif
+
 	/*
 	 * If apb2's clock is not 15MHz, we need to find the other optimized
 	 * values of UPSR and UBAUD for baud rate 115200.
@@ -507,7 +1036,7 @@ static int uart_npcx_init(const struct device *dev)
 	inst->UFRS = 0x00;
 
 	/* Initialize UART FIFO if mode is interrupt driven */
-#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN) || defined(CONFIG_UART_ASYNC_API)
 	/* Enable the UART FIFO mode */
 	inst->UMDSL |= BIT(NPCX_UMDSL_FIFO_MD);
 
@@ -521,6 +1050,14 @@ static int uart_npcx_init(const struct device *dev)
 	config->irq_config_func(dev);
 #endif
 
+#ifdef CONFIG_UART_ASYNC_API
+	data->async.next_rx_buffer = NULL;
+	data->async.next_rx_buffer_len = 0;
+	data->async.uart_dev = dev;
+	k_work_init_delayable(&data->async.rx_dma_params.timeout_work, uart_npcx_async_rx_timeout);
+	k_work_init_delayable(&data->async.tx_dma_params.timeout_work, uart_npcx_async_tx_timeout);
+#endif
+
 	if (IS_ENABLED(CONFIG_PM)) {
 		/* Initialize a miwu device input and its callback function */
 		npcx_miwu_init_dev_callback(&data->uart_rx_cb, &config->uart_rx_wui,
@@ -548,7 +1085,7 @@ static int uart_npcx_init(const struct device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN) || defined(CONFIG_UART_ASYNC_API)
 #define NPCX_UART_IRQ_CONFIG_FUNC_DECL(inst)                                                       \
 	static void uart_npcx_irq_config_##inst(const struct device *dev)
 #define NPCX_UART_IRQ_CONFIG_FUNC_INIT(inst) .irq_config_func = uart_npcx_irq_config_##inst,
@@ -567,22 +1104,29 @@ static int uart_npcx_init(const struct device *dev)
 
 #define NPCX_UART_INIT(i)                                                                          \
 	NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                         \
-                                                                                                   \
+	                                                                                           \
 	PINCTRL_DT_INST_DEFINE(i);                                                                 \
-                                                                                                   \
+	                                                                                           \
 	static const struct uart_npcx_config uart_npcx_cfg_##i = {                                 \
 		.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                    \
 		.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                                \
-		.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                               \
+		.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(i, uart_rx),                               \
 		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                         \
-		NPCX_UART_IRQ_CONFIG_FUNC_INIT(i)};                                                \
-                                                                                                   \
+		NPCX_UART_IRQ_CONFIG_FUNC_INIT(i)                                                  \
+	                                                                                           \
+		IF_ENABLED(CONFIG_UART_ASYNC_API, (                                                \
+			.mdma_clk_cfg = NPCX_DT_CLK_CFG_ITEM_BY_IDX(i, 1),                         \
+			.mdma_reg_base = (struct mdma_reg *)DT_INST_REG_ADDR_BY_IDX(i, 1),         \
+		))                                                                                 \
+	};                                                                                         \
+	                                                                                           \
 	static struct uart_npcx_data uart_npcx_data_##i = {                                        \
-		.baud_rate = DT_INST_PROP(i, current_speed)};                                      \
-                                                                                                   \
+		.baud_rate = DT_INST_PROP(i, current_speed),                                       \
+	};                                                                                         \
+	                                                                                           \
 	DEVICE_DT_INST_DEFINE(i, &uart_npcx_init, NULL, &uart_npcx_data_##i, &uart_npcx_cfg_##i,   \
 			      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY, &uart_npcx_driver_api);   \
-                                                                                                   \
+												   \
 	NPCX_UART_IRQ_CONFIG_FUNC(i)
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_UART_INIT)
diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
index 1a02a70d2..b2f6a55a8 100644
--- a/dts/arm/nuvoton/npcx/npcx4.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -76,16 +76,20 @@
 
 		uart1: serial@400e0000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E0000 0x2000>;
+			/* Index 0: UART1 register, Index 1: MDMA1 register */
+			reg = <0x400E0000 0x2000 0x40011100 0x100>;
 			interrupts = <33 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4>;
+			/* Index 0: UART1 clock, Index 1: MDMA1 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 0>;
 			uart-rx = <&wui_cr_sin1>;
 			status = "disabled";
 		};
 
 		uart2: serial@400e2000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E2000 0x2000>;
+			/* Index 0: UART2 register, Index 1: MDMA2 register */
+			reg = <0x400E2000 0x2000 0x40011200 0x100>;
 			interrupts = <32 3>;
 			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 6>;
 			uart-rx = <&wui_cr_sin2>;
@@ -94,18 +98,24 @@
 
 		uart3: serial@400e4000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E4000 0x2000>;
+			/* Index 0: UART3 register, Index 1: MDMA3 register */
+			reg = <0x400E4000 0x2000 0x40011300 0x100>;
 			interrupts = <38 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4>;
+			/* Index 0: UART3 clock, Index 1: MDMA3 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 2>;
 			uart-rx = <&wui_cr_sin3>;
 			status = "disabled";
 		};
 
 		uart4: serial@400e6000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E6000 0x2000>;
+			/* Index 0: UART4 register, Index 1: MDMA4 register */
+			reg = <0x400E6000 0x2000 0x40011400 0x100>;
 			interrupts = <39 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3>;
+			/* Index 0: UART4 clock, Index 1: MDMA4 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 3>;
 			uart-rx = <&wui_cr_sin4>;
 			status = "disabled";
 		};
diff --git a/dts/arm/nuvoton/npcx/npcx9.dtsi b/dts/arm/nuvoton/npcx/npcx9.dtsi
index 4a49e2c27..a246918ac 100644
--- a/dts/arm/nuvoton/npcx/npcx9.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx9.dtsi
@@ -73,36 +73,48 @@
 
 		uart1: serial@400e0000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E0000 0x2000>;
+			/* Index 0: UART1 register, Index 1: MDMA1 register */
+			reg = <0x400E0000 0x2000 0x40011100 0x100>;
 			interrupts = <33 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4>;
+			/* Index 0: UART1 clock, Index 1: MDMA1 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 0>;
 			uart-rx = <&wui_cr_sin1>;
 			status = "disabled";
 		};
 
 		uart2: serial@400e2000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E2000 0x2000>;
+			/* Index 0: UART2 register, Index 1: MDMA2 register */
+			reg = <0x400E2000 0x2000 0x40011200 0x100>;
 			interrupts = <32 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 6>;
+			/* Index 0: UART2 clock, Index 1: MDMA2 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 6
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 1>;
 			uart-rx = <&wui_cr_sin2>;
 			status = "disabled";
 		};
 
 		uart3: serial@400e4000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E4000 0x2000>;
+			/* Index 0: UART3 register, Index 1: MDMA3 register */
+			reg = <0x400E4000 0x2000 0x40011300 0x100>;
 			interrupts = <38 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4>;
+			/* Index 0: UART3 clock, Index 1: MDMA3 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 2>;
 			uart-rx = <&wui_cr_sin3>;
 			status = "disabled";
 		};
 
 		uart4: serial@400e6000 {
 			compatible = "nuvoton,npcx-uart";
-			reg = <0x400E6000 0x2000>;
+			/* Index 0: UART4 register, Index 1: MDMA4 register */
+			reg = <0x400E6000 0x2000 0x40011400 0x100>;
 			interrupts = <39 3>;
-			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3>;
+			/* Index 0: UART4 clock, Index 1: MDMA4 clock */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3
+				  &pcc NPCX_CLOCK_BUS_CORE NPCX_PWDWN_CTL9 3>;
 			uart-rx = <&wui_cr_sin4>;
 			status = "disabled";
 		};
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index 01b4a365e..214eadd47 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -365,6 +365,9 @@ struct uart_reg {
 #define NPCX_UFRS_PSEL_FIELD                  FIELD(4, 2)
 #define NPCX_UFRS_PEN                         6
 #define NPCX_UMDSL_FIFO_MD                    0
+#define NPCX_UMDSL_ETD                        4
+#define NPCX_UMDSL_ERD                        5
+
 #define NPCX_UFTSTS_TEMPTY_LVL                FIELD(0, 5)
 #define NPCX_UFTSTS_TEMPTY_LVL_STS            5
 #define NPCX_UFTSTS_TFIFO_EMPTY_STS           6
-- 
2.17.1


From 0ced59561750d9eb8d4bae91bfea073efdeaa7a7 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Wed, 24 Apr 2024 10:31:54 +0800
Subject: [PATCH 17/42] drivers: uart: npcx: extend the UART baudrate support

1. support the baudrate = 3MHz.
2. add baudrate = 115200 setting when UART source clock = 25/30/48/50 MHz.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/serial/uart_npcx.c | 29 ++++++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

diff --git a/drivers/serial/uart_npcx.c b/drivers/serial/uart_npcx.c
index 8e25da50d..085f7cccd 100644
--- a/drivers/serial/uart_npcx.c
+++ b/drivers/serial/uart_npcx.c
@@ -119,14 +119,37 @@ static void uart_npcx_pm_policy_state_lock_put(struct uart_npcx_data *data,
 /* UART local functions */
 static int uart_set_npcx_baud_rate(struct uart_reg *const inst, int baud_rate, int src_clk)
 {
-	/* Fix baud rate to 115200 so far */
+	/*
+	 * Support two baud rate setting so far:
+	 *   -  115200
+	 *   - 3000000
+	 */
 	if (baud_rate == 115200) {
-		if (src_clk == 15000000) {
+		if (src_clk == MHZ(15)) {
 			inst->UPSR = 0x38;
 			inst->UBAUD = 0x01;
-		} else if (src_clk == 20000000) {
+		} else if (src_clk == MHZ(20)) {
 			inst->UPSR = 0x08;
 			inst->UBAUD = 0x0a;
+		} else if (src_clk == MHZ(25)) {
+			inst->UPSR = 0x10;
+			inst->UBAUD = 0x08;
+		} else if (src_clk == MHZ(30)) {
+			inst->UPSR = 0x10;
+			inst->UBAUD = 0x0a;
+		} else if (src_clk == MHZ(48)) {
+			inst->UPSR = 0x08;
+			inst->UBAUD = 0x19;
+		} else if (src_clk == MHZ(50)) {
+			inst->UPSR = 0x08;
+			inst->UBAUD = 0x1a;
+		} else {
+			return -EINVAL;
+		}
+	} else if (baud_rate == MHZ(3)) {
+		if (src_clk == MHZ(48)) {
+			inst->UPSR = 0x08;
+			inst->UBAUD = 0x0;
 		} else {
 			return -EINVAL;
 		}
-- 
2.17.1


From 31f12cd789c2287dc480f7b3780b2f6b089a3ac4 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Mon, 15 Jul 2024 10:17:52 +0800
Subject: [PATCH 18/42] drivers: espi: host_subs: npcx: fix LDN register
 definition of PMCH

The register offset definition of the I/O port Data Base Address
register (0x60, 0x61) and Command/Status Base Address register
(0x62, 0x63) are reversed. This commit fixes it to avoid confusion.

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/host_subs_npcx.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index 51802586c..d92516fa0 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -199,12 +199,12 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_LDN_HCMD  0x12 /* PM Channel 2 */
 
 /* Index of EC (4E/4F) Configuration Register */
-#define EC_CFG_IDX_LDN             0x07
-#define EC_CFG_IDX_CTRL            0x30
-#define EC_CFG_IDX_CMD_IO_ADDR_H   0x60
-#define EC_CFG_IDX_CMD_IO_ADDR_L   0x61
-#define EC_CFG_IDX_DATA_IO_ADDR_H  0x62
-#define EC_CFG_IDX_DATA_IO_ADDR_L  0x63
+#define EC_CFG_IDX_LDN            0x07
+#define EC_CFG_IDX_CTRL           0x30
+#define EC_CFG_IDX_DATA_IO_ADDR_H 0x60
+#define EC_CFG_IDX_DATA_IO_ADDR_L 0x61
+#define EC_CFG_IDX_CMD_IO_ADDR_H  0x62
+#define EC_CFG_IDX_CMD_IO_ADDR_L  0x63
 
 /* LDN Activation Enable */
 #define EC_CFG_IDX_CTRL_LDN_ENABLE 0x01
@@ -1029,15 +1029,15 @@ void npcx_host_init_subs_host_domain(void)
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_HCMD);
 #if defined(CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM)
 		/* Configure IO address of CMD portt (default: 0x200) */
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_H,
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_H,
 		 (CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM >> 8) & 0xff);
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_L,
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_L,
 		 CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM & 0xff);
 		/* Configure IO address of Data portt (default: 0x204) */
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_H,
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_H,
 		 ((CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM + 4) >> 8)
 		 & 0xff);
-		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_L,
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_L,
 		 (CONFIG_ESPI_PERIPHERAL_HOST_CMD_DATA_PORT_NUM + 4) & 0xff);
 #endif
 		/* Enable 'Host Command' io port (PM Channel 2) */
-- 
2.17.1


From 91a9750d3025dfffd9422b5c5564d0e1bbcb23c1 Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Fri, 19 Jul 2024 09:59:12 +0800
Subject: [PATCH 19/42] soc: npcx: scfg: select host interface type in global

The Host Interface Type in the DEVCNT register sets the HIF type
(either eSPI or LPC).
Currently, it is configured in the host-interface-related drivers like
eSPI or SHI. However, some I/O pads sourced from VHIF in the other
modules such as GPIO and I3C also rely on this field. It might be
problematic when using those I/Os without enabling eSPI or SHI drivers.
This commit moves the setting from the specific drivers to the global
system initialization function scfg_init().

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_npcx.c                                     | 5 -----
 soc/arm/nuvoton_npcx/common/scfg.c                           | 5 +++++
 .../mgmt/ec_host_cmd/backends/ec_host_cmd_backend_shi_npcx.c | 5 -----
 3 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 42e559a8b..9233b1708 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -1329,11 +1329,6 @@ static int espi_npcx_init(const struct device *dev)
 	const struct device *const clk_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE);
 	int i, ret;
 
-	/* If booter doesn't set the host interface type */
-	if (!NPCX_BOOTER_IS_HIF_TYPE_SET()) {
-		npcx_host_interface_sel(NPCX_HIF_TYPE_ESPI_SHI);
-	}
-
 	if (!device_is_ready(clk_dev)) {
 		LOG_ERR("clock control device not ready");
 		return -ENODEV;
diff --git a/soc/arm/nuvoton_npcx/common/scfg.c b/soc/arm/nuvoton_npcx/common/scfg.c
index fd287ce66..6dac027cb 100644
--- a/soc/arm/nuvoton_npcx/common/scfg.c
+++ b/soc/arm/nuvoton_npcx/common/scfg.c
@@ -145,6 +145,11 @@ void npcx_dbg_freeze_enable(bool enable)
 /* Pin-control driver registration */
 static int npcx_scfg_init(void)
 {
+	/* If booter doesn't set the host interface type */
+	if (!NPCX_BOOTER_IS_HIF_TYPE_SET()) {
+		npcx_host_interface_sel(NPCX_HIF_TYPE_ESPI_SHI);
+	}
+
 	/* Change all pads whose default functionality isn't IO to GPIO */
 	for (int i = 0; i < ARRAY_SIZE(def_alts); i++) {
 		npcx_pinctrl_alt_sel(&def_alts[i], 0);
diff --git a/subsys/mgmt/ec_host_cmd/backends/ec_host_cmd_backend_shi_npcx.c b/subsys/mgmt/ec_host_cmd/backends/ec_host_cmd_backend_shi_npcx.c
index a5bb9adad..e30de1295 100644
--- a/subsys/mgmt/ec_host_cmd/backends/ec_host_cmd_backend_shi_npcx.c
+++ b/subsys/mgmt/ec_host_cmd/backends/ec_host_cmd_backend_shi_npcx.c
@@ -875,11 +875,6 @@ static int shi_npcx_init_registers(const struct device *dev)
 		return ret;
 	}
 
-	/* If booter doesn't set the host interface type */
-	if (!NPCX_BOOTER_IS_HIF_TYPE_SET()) {
-		npcx_host_interface_sel(NPCX_HIF_TYPE_ESPI_SHI);
-	}
-
 	/*
 	 * SHICFG1 (SHI Configuration 1) setting
 	 * [7] - IWRAP	= 1: Wrap input buffer to the first address
-- 
2.17.1


From 8bc454b508964d100d657e0bfbee9bb908529334 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 13 Aug 2024 19:47:13 -0700
Subject: [PATCH 20/42] drivers: espi: npcx: Fix TAF driver dependency

Set correct dependency for TAF driver protected regions

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig.npcx | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index 035db2415..9a731426a 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -66,6 +66,8 @@ config ESPI_TAF_NPCX
 	  This option enables the Intel Enhanced Serial Peripheral Interface
 	  Target Attached Flash (eSPI TAF) for NPCX4 family of processors.
 
+if ESPI_TAF_NPCX
+
 choice ESPI_TAF_ACCESS_MODE_CHOICE
 	prompt "eSPI TAF Read Access Mode"
 	default ESPI_TAF_AUTO_MODE
@@ -88,6 +90,7 @@ config ESPI_TAF_PR_NUM
 	help
 	  This size is display how many group of slave attached flash protection
 	  region.
+endif
 
 # The default value 'y' for the existing options if ESPI_NPCX is selected.
 if ESPI_NPCX
-- 
2.17.1


From 259b2c0f9f3cef7958560ae5161e729d70dcbf57 Mon Sep 17 00:00:00 2001
From: Vijay Hiremath <vijay.p.hiremath@intel.com>
Date: Thu, 7 Nov 2024 18:48:29 -0800
Subject: [PATCH 21/42] eSPI: NPCX/ITE: Enable conditional virtual wire valid
 bit check

On the new Intel SoC, the "Valid" bit of the Virtual Wire is set only for
Virtual Wires that undergo changes. This behavior differs from previous
generations. Therefore, to maintain backward compatibility, a conditional
check for the virtual wire valid bit is added for processing the virtual
wire level.

Signed-off-by: Vijay Hiremath <vijay.p.hiremath@intel.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig        |  9 +++++++++
 drivers/espi/espi_it8xxx2.c | 12 ++++++++----
 drivers/espi/espi_npcx.c    | 11 +++++++++--
 3 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/drivers/espi/Kconfig b/drivers/espi/Kconfig
index 0a8f6173b..41b29901c 100644
--- a/drivers/espi/Kconfig
+++ b/drivers/espi/Kconfig
@@ -46,6 +46,15 @@ config ESPI_VWIRE_CHANNEL
 	help
 	  eSPI Controller supports virtual wires channel.
 
+config ESPI_VWIRE_VALID_BIT_CHECK
+	bool "eSPI virtual wire valid bit check"
+	default y
+	depends on ESPI_VWIRE_CHANNEL
+	help
+	  Enable the checking of the eSPI virtual wire valid bit. If this
+	  configuration is not set, treat the new values as the previously
+	  retained valid values and return the received virtual wire level.
+
 config ESPI_AUTOMATIC_WARNING_ACKNOWLEDGE
 	bool "Automatic acknowledge for eSPI HOST warnings"
 	default y
diff --git a/drivers/espi/espi_it8xxx2.c b/drivers/espi/espi_it8xxx2.c
index 6694cf013..e8bb5d581 100644
--- a/drivers/espi/espi_it8xxx2.c
+++ b/drivers/espi/espi_it8xxx2.c
@@ -719,11 +719,15 @@ static int espi_it8xxx2_receive_vwire(const struct device *dev,
 		return -EIO;
 	}
 
-	if (vw_reg->VW_INDEX[vw_index] & valid_mask) {
-		*level = !!(vw_reg->VW_INDEX[vw_index] & level_mask);
+	if (IS_ENABLED(CONFIG_ESPI_VWIRE_VALID_BIT_CHECK)) {
+		if (vw_reg->VW_INDEX[vw_index] & valid_mask) {
+			*level = !!(vw_reg->VW_INDEX[vw_index] & level_mask);
+		} else {
+			/* Not valid */
+			*level = 0;
+		}
 	} else {
-		/* Not valid */
-		*level = 0;
+		*level = !!(vw_reg->VW_INDEX[vw_index] & level_mask);
 	}
 
 	return 0;
diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 9233b1708..8c5ebb33c 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -821,8 +821,11 @@ static int espi_npcx_receive_vwire(const struct device *dev,
 
 			val = GET_FIELD(inst->VWEVMS[reg_idx],
 							NPCX_VWEVMS_WIRE);
-			val &= GET_FIELD(inst->VWEVMS[reg_idx],
+
+			if (IS_ENABLED(CONFIG_ESPI_VWIRE_VALID_BIT_CHECK)) {
+				val &= GET_FIELD(inst->VWEVMS[reg_idx],
 							NPCX_VWEVMS_VALID);
+			}
 
 			*level = !!(val & bitmask);
 			return 0;
@@ -836,8 +839,12 @@ static int espi_npcx_receive_vwire(const struct device *dev,
 
 			val = GET_FIELD(inst->VWEVSM[reg_idx],
 							NPCX_VWEVSM_WIRE);
-			val &= GET_FIELD(inst->VWEVSM[reg_idx],
+
+			if (IS_ENABLED(CONFIG_ESPI_VWIRE_VALID_BIT_CHECK)) {
+				val &= GET_FIELD(inst->VWEVSM[reg_idx],
 							NPCX_VWEVSM_VALID);
+			}
+
 			*level = !!(val & bitmask);
 			return 0;
 		}
-- 
2.17.1


From fd074000504b7d47bd816070f27cfbbc4d85546f Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Mon, 9 May 2022 10:59:51 +0530
Subject: [PATCH 22/42] drivers: peci: increased peci write time delay 2ms

peci delay is increased to 2ms as peci write is failing with 1ms

Signed-off-by: Venugopal Reddy <venugopalx.reddy@intel.com>
Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/peci/peci_mchp_xec.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index e03181e0f..202d0f0bb 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -284,8 +284,8 @@ static int peci_xec_write(const struct device *dev, struct peci_msg *msg)
 		return -ETIMEDOUT;
 	}
 #else
-	/* In worst case, overall timeout will be 1msec (100 * 10usec) */
-	uint8_t wait_timeout_cnt = 100;
+	/* In worst case, overall timeout will be 2msec (200 * 10usec) */
+	uint8_t wait_timeout_cnt = 200;
 
 	while (!(regs->STATUS1 & MCHP_PECI_STS1_EOF)) {
 		k_busy_wait(PECI_IO_DELAY);
-- 
2.17.1


From eaf72d6f8f3a3aca8077efcdd2cb57d234179898 Mon Sep 17 00:00:00 2001
From: NagarajuGundimi <nagaraju.gundimi@intel.com>
Date: Thu, 29 Dec 2022 03:29:54 -0500
Subject: [PATCH 23/42] ite: Defined GPIO ports and delta changes for Zephyr
 v3.2

Defined GPIO ports and delta changes for Zephyr v3.2

Signed-off-by: NagarajuGundimi <nagaraju.gundimi@intel.com>
---
 soc/riscv/riscv-ite/common/soc_gpio.h |  30 +++++
 soc/riscv/riscv-ite/common/soc_pins.h | 161 ++++++++++++++++++++++++++
 2 files changed, 191 insertions(+)
 create mode 100644 soc/riscv/riscv-ite/common/soc_gpio.h
 create mode 100644 soc/riscv/riscv-ite/common/soc_pins.h

diff --git a/soc/riscv/riscv-ite/common/soc_gpio.h b/soc/riscv/riscv-ite/common/soc_gpio.h
new file mode 100644
index 000000000..ba138750d
--- /dev/null
+++ b/soc/riscv/riscv-ite/common/soc_gpio.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2022 Intel Corporation
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/** @file
+ * @brief ITE 8XXX2 MCU family General Purpose Input Output (GPIO) defines.
+ *
+ */
+
+#ifndef _ITE_SOC_GPIO_H_
+#define _ITE_SOC_GPIO_H_
+
+#define ITE_GPIO_PORTA     0
+#define ITE_GPIO_PORTB     1
+#define ITE_GPIO_PORTC     2
+#define ITE_GPIO_PORTD     3
+#define ITE_GPIO_PORTE     4
+#define ITE_GPIO_PORTF     5
+#define ITE_GPIO_PORTG     6
+#define ITE_GPIO_PORTH     7
+#define ITE_GPIO_PORTI     8
+#define ITE_GPIO_PORTJ     9
+#define ITE_GPIO_PORTK     10
+#define ITE_GPIO_PORTL     11
+#define ITE_GPIO_PORTM     12
+#define ITE_GPIO_MAX_PORT    13
+#define ITE_NUM_GPIO_PORTS   13
+
+#endif /* _ITE_SOC_GPIO_H_ */
diff --git a/soc/riscv/riscv-ite/common/soc_pins.h b/soc/riscv/riscv-ite/common/soc_pins.h
new file mode 100644
index 000000000..38290ba40
--- /dev/null
+++ b/soc/riscv/riscv-ite/common/soc_pins.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2022 Intel Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _SOC_ITE_GPIOS_H_
+#define _SOC_ITE_GPIOS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Begin Port A */
+#define ITE_GPIO_GPA0	(0U)
+#define ITE_GPIO_GPA1	(1U)
+#define ITE_GPIO_GPA2	(2U)
+#define ITE_GPIO_GPA3	(3U)
+#define ITE_GPIO_GPA4	(4U)
+#define ITE_GPIO_GPA5	(5U)
+#define ITE_GPIO_GPA6	(6U)
+#define ITE_GPIO_GPA7	(7U)
+/* End Port A */
+
+/* Begin Port B */
+#define ITE_GPIO_GPB0	(0U)
+#define ITE_GPIO_GPB1	(1U)
+#define ITE_GPIO_GPB2	(2U)
+#define ITE_GPIO_GPB3	(3U)
+#define ITE_GPIO_GPB4	(4U)
+#define ITE_GPIO_GPB5	(5U)
+#define ITE_GPIO_GPB6	(6U)
+#define ITE_GPIO_GPB7	(7U)
+/* End Port B */
+
+/* Begin Port C */
+#define ITE_GPIO_GPC0	(0U)
+#define ITE_GPIO_GPC1	(1U)
+#define ITE_GPIO_GPC2	(2U)
+#define ITE_GPIO_GPC3	(3U)
+#define ITE_GPIO_GPC4	(4U)
+#define ITE_GPIO_GPC5	(5U)
+#define ITE_GPIO_GPC6	(6U)
+#define ITE_GPIO_GPC7	(7U)
+/* End Port C */
+
+/* Begin Port D */
+#define ITE_GPIO_GPD0	(0U)
+#define ITE_GPIO_GPD1	(1U)
+#define ITE_GPIO_GPD2	(2U)
+#define ITE_GPIO_GPD3	(3U)
+#define ITE_GPIO_GPD4	(4U)
+#define ITE_GPIO_GPD5	(5U)
+#define ITE_GPIO_GPD6	(6U)
+#define ITE_GPIO_GPD7	(7U)
+/* End Port D */
+
+/* Begin Port E */
+#define ITE_GPIO_GPE0	(0U)
+#define ITE_GPIO_GPE1	(1U)
+#define ITE_GPIO_GPE2	(2U)
+#define ITE_GPIO_GPE3	(3U)
+#define ITE_GPIO_GPE4	(4U)
+#define ITE_GPIO_GPE5	(5U)
+#define ITE_GPIO_GPE6	(6U)
+#define ITE_GPIO_GPE7	(7U)
+/* End Port E */
+
+/* Begin Port F */
+#define ITE_GPIO_GPF0	(0U)
+#define ITE_GPIO_GPF1	(1U)
+#define ITE_GPIO_GPF2	(2U)
+#define ITE_GPIO_GPF3	(3U)
+#define ITE_GPIO_GPF4	(4U)
+#define ITE_GPIO_GPF5	(5U)
+#define ITE_GPIO_GPF6	(6U)
+#define ITE_GPIO_GPF7	(7U)
+/* End Port F */
+
+/* Begin Port G */
+#define ITE_GPIO_GPG0	(0U)
+#define ITE_GPIO_GPG1	(1U)
+#define ITE_GPIO_GPG2	(2U)
+#define ITE_GPIO_GPG3	(3U)
+#define ITE_GPIO_GPG4	(4U)
+#define ITE_GPIO_GPG5	(5U)
+#define ITE_GPIO_GPG6	(6U)
+#define ITE_GPIO_GPG7	(7U)
+/* End Port G */
+
+/* Begin Port H */
+#define ITE_GPIO_GPH0	(0U)
+#define ITE_GPIO_GPH1	(1U)
+#define ITE_GPIO_GPH2	(2U)
+#define ITE_GPIO_GPH3	(3U)
+#define ITE_GPIO_GPH4	(4U)
+#define ITE_GPIO_GPH5	(5U)
+#define ITE_GPIO_GPH6	(6U)
+#define ITE_GPIO_GPH7	(7U)
+/* End Port H */
+
+/* Begin Port I */
+#define ITE_GPIO_GPI0	(0U)
+#define ITE_GPIO_GPI1	(1U)
+#define ITE_GPIO_GPI2	(2U)
+#define ITE_GPIO_GPI3	(3U)
+#define ITE_GPIO_GPI4	(4U)
+#define ITE_GPIO_GPI5	(5U)
+#define ITE_GPIO_GPI6	(6U)
+#define ITE_GPIO_GPI7	(7U)
+/* End Port I */
+
+/* Begin Port J */
+#define ITE_GPIO_GPJ0	(0U)
+#define ITE_GPIO_GPJ1	(1U)
+#define ITE_GPIO_GPJ2	(2U)
+#define ITE_GPIO_GPJ3	(3U)
+#define ITE_GPIO_GPJ4	(4U)
+#define ITE_GPIO_GPJ5	(5U)
+#define ITE_GPIO_GPJ6	(6U)
+#define ITE_GPIO_GPJ7	(7U)
+/* End Port J */
+
+/* Begin Port K */
+#define ITE_GPIO_GPK0	(0U)
+#define ITE_GPIO_GPK1	(1U)
+#define ITE_GPIO_GPK2	(2U)
+#define ITE_GPIO_GPK3	(3U)
+#define ITE_GPIO_GPK4	(4U)
+#define ITE_GPIO_GPK5	(5U)
+#define ITE_GPIO_GPK6	(6U)
+#define ITE_GPIO_GPK7	(7U)
+/* End Port K */
+
+/* Begin Port L */
+#define ITE_GPIO_GPL0	(0U)
+#define ITE_GPIO_GPL1	(1U)
+#define ITE_GPIO_GPL2	(2U)
+#define ITE_GPIO_GPL3	(3U)
+#define ITE_GPIO_GPL4	(4U)
+#define ITE_GPIO_GPL5	(5U)
+#define ITE_GPIO_GPL6	(6U)
+#define ITE_GPIO_GPL7	(7U)
+/* End Port L */
+
+/* Begin Port M */
+#define ITE_GPIO_GPM0	(0U)
+#define ITE_GPIO_GPM1	(1U)
+#define ITE_GPIO_GPM2	(2U)
+#define ITE_GPIO_GPM3	(3U)
+#define ITE_GPIO_GPM4	(4U)
+#define ITE_GPIO_GPM5	(5U)
+#define ITE_GPIO_GPM6	(6U)
+#define ITE_GPIO_GPM7	(7U)
+/* End Port M */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SOC_ITE_GPIOS_H_ */
-- 
2.17.1


From b3312c4c59791500d9f90e806484231f6d456320 Mon Sep 17 00:00:00 2001
From: NagarajuGundimi <nagaraju.gundimi@intel.com>
Date: Thu, 29 Dec 2022 04:29:40 -0500
Subject: [PATCH 24/42] ite: eSPI: WA for ACPI IBF flag clear at driver level

WA for ACPI IBF flag clear due to PM1DI read at driver.

Signed-off-by: NagarajuGundimi <nagaraju.gundimi@intel.com>
---
 drivers/espi/espi_it8xxx2.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/drivers/espi/espi_it8xxx2.c b/drivers/espi/espi_it8xxx2.c
index e8bb5d581..0a41b24b1 100644
--- a/drivers/espi/espi_it8xxx2.c
+++ b/drivers/espi/espi_it8xxx2.c
@@ -487,7 +487,10 @@ static void pmc1_it8xxx2_ibf_isr(const struct device *dev)
 	acpi_evt->type = !!(pmc_reg->PM1STS & PMC_PM1STS_A2_ADDR);
 	/* Set processing flag before reading command byte */
 	pmc_reg->PM1STS |= PMC_PM1STS_GPF;
-	acpi_evt->data = pmc_reg->PM1DI;
+	/*
+	 * Disabled below line deliberately because PM1DI read clearing ACPI IBF flag.
+	 * acpi_evt->data = pmc_reg->PM1DI;
+	 */
 
 	espi_send_callbacks(&data->callbacks, dev, evt);
 }
-- 
2.17.1


From fde8ca97ab780d82681575bba95b4242d716ed69 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Tue, 29 Nov 2022 20:52:52 +0530
Subject: [PATCH 25/42] drivers: espi: Nuvoton: Do not read Input Buffer

Reading the HIPMDI register will clear the IBF bit in ACPI
and Host command handling. This will end up breaking the EC
App functionality (as that looks out for IBF to be set to
proceed further). Hence this register read is removed.

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 drivers/espi/host_subs_npcx.c | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index d92516fa0..0eacd6911 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -127,7 +127,7 @@
 
 #include <zephyr/logging/log.h>
 #include <zephyr/irq.h>
-LOG_MODULE_REGISTER(host_sub_npcx, LOG_LEVEL_ERR);
+LOG_MODULE_REGISTER(host_sub_npcx, CONFIG_ESPI_LOG_LEVEL);
 
 struct host_sub_npcx_config {
 	/* host module instances */
@@ -472,14 +472,13 @@ static void host_pmch_ibf_isr(const void *arg)
 	ARG_UNUSED(arg);
 	struct pmch_reg *const inst_acpi = host_sub_cfg.inst_pm_acpi;
 	struct pmch_reg *const inst_hcmd = host_sub_cfg.inst_pm_hcmd;
-	uint8_t in_data;
+	uint8_t in_data = 0;
 
 	/* Host put data on input buffer of ACPI channel */
 	if (IS_BIT_SET(inst_acpi->HIPMST, NPCX_HIPMST_IBF)) {
 		/* Set processing flag before reading command byte */
 		inst_acpi->HIPMST |= BIT(NPCX_HIPMST_F0);
-		/* Read out input data and clear IBF pending bit */
-		in_data = inst_acpi->HIPMDI;
+
 #if defined(CONFIG_ESPI_PERIPHERAL_HOST_IO)
 		host_acpi_process_input_data(in_data);
 #endif
@@ -489,8 +488,7 @@ static void host_pmch_ibf_isr(const void *arg)
 	if (IS_BIT_SET(inst_hcmd->HIPMST, NPCX_HIPMST_IBF)) {
 		/* Set processing flag before reading command byte */
 		inst_hcmd->HIPMST |= BIT(NPCX_HIPMST_F0);
-		/* Read out input data and clear IBF pending bit */
-		in_data = inst_hcmd->HIPMDI;
+
 #if defined(CONFIG_ESPI_PERIPHERAL_EC_HOST_CMD)
 		host_hcmd_process_input_data(in_data);
 #endif
-- 
2.17.1


From eea0e4a9320ea76b104c5b41375e3699c48ef73c Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Fri, 15 Mar 2024 17:22:23 -0700
Subject: [PATCH 26/42] boards: mec172x: Do not enable KSCAN PM device pinctrl

Remove sleep pinctrl from KSCAN device

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 .../mec172xmodular_assy6930.dts               | 38 +++++++++++--------
 1 file changed, 23 insertions(+), 15 deletions(-)

diff --git a/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts b/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
index d355f19af..631f7ca15 100644
--- a/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
+++ b/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
@@ -194,21 +194,29 @@
 &kscan0 {
 	status = "okay";
 
-	pinctrl-0 = < &ksi0_gpio017 &ksi1_gpio020 &ksi2_gpio021 &ksi3_gpio026
-		      &ksi4_gpio027 &ksi5_gpio030 &ksi6_gpio031 &ksi7_gpio032
-		      &kso00_gpio040 &kso01_gpio045 &kso02_gpio046 &kso03_gpio047
-		      &kso04_gpio107 &kso05_gpio112 &kso06_gpio113 &kso07_gpio120
-		      &kso08_gpio121 &kso09_gpio122 &kso10_gpio123 &kso11_gpio124
-		      &kso12_gpio125 &kso13_gpio126 >;
-	pinctrl-1 = < &ksi0_gpio017_sleep &ksi1_gpio020_sleep &ksi2_gpio021_sleep
-		      &ksi3_gpio026_sleep &ksi4_gpio027_sleep &ksi5_gpio030_sleep
-		      &ksi6_gpio031_sleep &ksi7_gpio032_sleep &kso00_gpio040_sleep
-		      &kso01_gpio045_sleep &kso02_gpio046_sleep &kso03_gpio047_sleep
-		      &kso04_gpio107_sleep &kso05_gpio112_sleep &kso06_gpio113_sleep
-		      &kso07_gpio120_sleep &kso08_gpio121_sleep &kso09_gpio122_sleep
-		      &kso10_gpio123_sleep &kso11_gpio124_sleep &kso12_gpio125_sleep
-		      &kso13_gpio126_sleep >;
-	pinctrl-names = "default", "sleep";
+	pinctrl-0 = < &ksi0_gpio017
+		      &ksi1_gpio020
+		      &ksi2_gpio021
+		      &ksi3_gpio026
+		      &ksi4_gpio027
+		      &ksi5_gpio030
+		      &ksi6_gpio031
+		      &ksi7_gpio032
+		      &kso00_gpio040
+		      &kso01_gpio045
+		      &kso02_gpio046
+		      &kso03_gpio047
+		      &kso04_gpio107
+		      &kso05_gpio112
+		      &kso06_gpio113
+		      &kso07_gpio120
+		      &kso08_gpio121
+		      &kso09_gpio122
+		      &kso10_gpio123
+		      &kso11_gpio124
+		      &kso12_gpio125
+		      &kso13_gpio126 >;
+	pinctrl-names = "default";
 };
 
 &ksi0_gpio017 {
-- 
2.17.1


From 86fb6ab1a6e620ffa2fd9b99785deaef6c945b61 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 15 Apr 2024 12:15:52 -0700
Subject: [PATCH 27/42] soc: arm: npcx: ECST add support to generated
 bootloader header

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 soc/arm/nuvoton_npcx/common/ecst/ecst.py      | 56 ++++++++++++++++++-
 soc/arm/nuvoton_npcx/common/ecst/ecst_args.py | 20 ++++++-
 2 files changed, 72 insertions(+), 4 deletions(-)

diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst.py b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
index 1e05f479c..617142a5d 100755
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
@@ -57,6 +57,7 @@ FW_CRC_ENABLE = 0x02
 HDR_PTR_SIGNATURE = 0x55AA650E
 
 BOOTLOADER_TABLE_MODE = "bt"
+BOOTLOADER_HEADER_MODE = "bh"
 
 # SPI related values
 SPI_MAX_CLOCK_20_MHZ_VAL = "20"
@@ -123,6 +124,57 @@ SUPER_VERBOSE = 1
 EXIT_SUCCESS_STATUS = 0
 EXIT_FAILURE_STATUS = 1
 
+def _set_mode_handler(ecst_args):
+    """handler according to the "mode" argument
+
+    "bt" - bootloader table mode (default)
+    "bh" - bootloader header mode
+    :param ecst_args: the object representing the command line arguments.
+    """
+    mode = ecst_args.mode
+
+    if mode == BOOTLOADER_TABLE_MODE:
+        _bt_mode_handler(ecst_args)
+    elif mode == BOOTLOADER_HEADER_MODE:
+        _bh_mode_handler(ecst_args)
+    else:
+        exit_with_failure('Cannot Read operation mode - bt, bh!')
+
+def _bh_mode_handler(ecst_args):
+    """handles the bootloader table header mode using the provided arguments.
+
+    :param ecst_args: the object representing the command line arguments.
+    """
+    pointer = ecst_args.pointer
+    bh_offset = ecst_args.bh_offset
+
+    if pointer == INVALID_INPUT:
+        exit_with_failure("Cannot read pointer to the Firmware Header")
+    if bh_offset == INVALID_INPUT:
+        exit_with_failure("Cannot read BootLoader Header Offset")
+    if pointer & ADDR_16_BYTES_ALIGNED_MASK != 0:
+        pointer_to_print = _hex_print_format(pointer)
+        exit_with_failure(f'FW Header address ({pointer_to_print})'
+                          f' isn\'t 16-bytes aligned!')
+    if bh_offset:
+        if bh_offset & ADDR_4_BYTES_ALIGNED_MASK != 0:
+            bh_offset_to_print = _hex_print_format(bh_offset)
+            exit_with_failure(f'BootLoader Header Offset ({bh_offset_to_print})'
+                              f' isn\'t 4-bytes aligned!')
+    if pointer > MAX_FLASH_SIZE:
+        exit_with_failure(f'Pointer address ({pointer}) is higher '
+                          f'than flash size'
+                          f' ({_hex_print_format(MAX_FLASH_SIZE)})')
+
+    # if bh_offset argument is used, the image is merged with a BT header,
+    # otherwise a BT header is created in a different file
+    if bh_offset is not None:
+        _merge_file_with_bt_header(ecst_args)
+    else:
+        _create_bt_header(ecst_args)
+
+    _exit_with_success()
+
 def _bt_mode_handler(ecst_args):
     """creates the bootloader table using the provided arguments.
 
@@ -255,7 +307,6 @@ def _set_extended_anchor(output, ecst_args):
                   f' {HDR_EXTENDED_ANCHOR_OFFSET}  -  {anchor_to_print}')
         output_file.close()
 
-
 def _check_firmware_header_offset(output, ecst_args):
     """checks if the firmware header offset entered is valid.
     proportions:
@@ -997,8 +1048,7 @@ def main():
             exit_with_failure(message)
         sys.exit(EXIT_SUCCESS_STATUS)
 
-    # Start to handle booter header table
-    _bt_mode_handler(ecst_obj)
+    _set_mode_handler(ecst_obj)
 
 if __name__ == '__main__':
     main()
diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
index ab1aad770..f22f4011a 100755
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
@@ -124,7 +124,10 @@ def _populate_chip_fields(self):
 def _populate_args(self, argument_list):
     """populate the ecst arguments according to the command line/ args file"""
     for arg in vars(argument_list):
-        if (arg == "input") & (argument_list.input is not None):
+        if (arg == "mode") & (argument_list.mode is not None):
+            self.mode = argument_list.mode
+
+        elif (arg == "input") & (argument_list.input is not None):
             self.input = argument_list.input
 
         elif (arg == "output") & (argument_list.output is not None):
@@ -176,6 +179,18 @@ def _populate_args(self, argument_list):
             else:
                 self.paste_firmware_header = INVALID_INPUT
 
+        elif (arg == "pointer") & (argument_list.pointer is not None):
+            if _is_hex(argument_list.pointer):
+                self.pointer = int(argument_list.pointer, 16)
+            else:
+                self.pointer = INVALID_INPUT
+
+        elif (arg == "bh_offset") & (argument_list.bh_offset is not None):
+            if _is_hex(argument_list.bh_offset):
+                self.bh_offset = int(argument_list.bh_offset, 16)
+            else:
+                self.bh_offset = INVALID_INPUT
+
 def _create_parser(arg_list):
     """create argument parser according to pre-defined arguments
 
@@ -184,6 +199,7 @@ def _create_parser(arg_list):
     """
 
     parser = argparse.ArgumentParser(conflict_handler='resolve', allow_abbrev=False)
+    parser.add_argument("-mode", nargs='?', dest="mode")
     parser.add_argument("-i", nargs='?', dest="input")
     parser.add_argument("-o", nargs='?', dest="output")
     parser.add_argument("-chip", dest="chip")
@@ -197,6 +213,8 @@ def _create_parser(arg_list):
     parser.add_argument("-spiclkratio", nargs='?',
                         dest="spi_flash_clock_ratio")
     parser.add_argument("-spireadmode", nargs='?', dest="spi_read_mode")
+    parser.add_argument("-pointer", nargs='?', dest="pointer")
+    parser.add_argument("-bhoffset", nargs='?', dest="bh_offset")
     parser.add_argument("-flashsize", nargs='?', dest="flash_size")
     parser.add_argument("-ph", nargs='?', dest="paste_firmware_header")
 
-- 
2.17.1


From 1ba2340ffd66c29b5eaf5952a81f149d85921762 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 11 Jan 2024 21:54:10 -0800
Subject: [PATCH 28/42] boards: arm: npcx: Allow to generate EC region SPI
 layout

Add post build command to generate EC region SPI layout
based on spi_cfg.txt with 2 images

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 boards/arm/npcx4m8f_evb/CMakeLists.txt      | 17 ++++
 boards/arm/npcx4m8f_evb/npcx_spi_img_gen.sh | 96 +++++++++++++++++++++
 boards/arm/npcx4m8f_evb/support/spi_cfg.txt | 12 +++
 boards/arm/npcx9m6f_evb/CMakeLists.txt      | 10 +++
 4 files changed, 135 insertions(+)
 create mode 100644 boards/arm/npcx4m8f_evb/CMakeLists.txt
 create mode 100755 boards/arm/npcx4m8f_evb/npcx_spi_img_gen.sh
 create mode 100644 boards/arm/npcx4m8f_evb/support/spi_cfg.txt
 create mode 100644 boards/arm/npcx9m6f_evb/CMakeLists.txt

diff --git a/boards/arm/npcx4m8f_evb/CMakeLists.txt b/boards/arm/npcx4m8f_evb/CMakeLists.txt
new file mode 100644
index 000000000..c11f20796
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/CMakeLists.txt
@@ -0,0 +1,17 @@
+#
+# Copyright (c) 2024 Intel Corporation.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+find_file (NPCX_SPI_CFG NAMES spi_cfg.txt PATHS ${BOARD_DIR}/support)
+find_file (NPCX_SPI_GEN NAMES npcx_spi_img_gen.sh PATHS ${BOARD_DIR})
+
+set_property(GLOBAL APPEND PROPERTY extra_post_build_commands
+    COMMAND pwd
+    COMMAND echo "${NPCX_SPI_CFG}"
+    COMMAND echo "${NPCX_SPI_GEN}"
+    COMMAND echo "${PROJECT_BINARY_DIR}"
+    COMMAND echo "${NPCX_SPI_GEN} -i ${NPCX_SPI_CFG} -f ${PROJECT_BINARY_DIR}/zephyr.npcx.bin -o ${PROJECT_BINARY_DIR}/spi_image.bin"
+    COMMAND ${NPCX_SPI_GEN} ${NPCX_SPI_CFG} ${PROJECT_BINARY_DIR}/zephyr.npcx.bin ${PROJECT_BINARY_DIR}/spi_image.bin
+  )
diff --git a/boards/arm/npcx4m8f_evb/npcx_spi_img_gen.sh b/boards/arm/npcx4m8f_evb/npcx_spi_img_gen.sh
new file mode 100755
index 000000000..54046310e
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/npcx_spi_img_gen.sh
@@ -0,0 +1,96 @@
+#!/bin/bash
+
+function generate_ecfw_binary()
+{
+	# Location of SPI layout configuration
+	NPCX_SPI_CFG=$1
+	PROJECT_BINARY=$2
+	SPI_IMAGE_BIN=$3
+
+	# Validate parameters
+	if [ -f "$NPCX_SPI_CFG" ]; then
+		echo "SPI layout configuration: $NPCX_SPI_CFG"
+	else
+		echo "$NPCX_SPI_CFG does not exist"
+		return -1
+	fi
+
+	if [ -f "$NPCX_SPI_CFG" ]; then
+		echo "Zephyr input binary:  $PROJECT_BINARY"
+	else
+		echo "$PROJECT_BINARY does not exist"
+		return -1
+	fi
+	echo "SPI output binary:  $SPI_IMAGE_BIN"
+
+	# Extract parameters from SPI layout configuration file
+	local ec_region_start_str=$(sed -n -e 's/ECOffsetBytes = //p' $NPCX_SPI_CFG || -1)
+	local ec_region_size_str=$(sed -n -e 's/ECRegionSizeKB = //p' $NPCX_SPI_CFG || -1)
+	local ec_size_str=$(sed -n -e 's/ECFWSizeKB = //p' $NPCX_SPI_CFG || -1)
+	local ec_offset0_str=$(sed -n -e 's/ImageLocation0 = //p' $NPCX_SPI_CFG || -1)
+	local ec_offset1_str=$(sed -n -e 's/ImageLocation1 = //p' $NPCX_SPI_CFG || -1)
+
+	# Convert values to integers
+	local ec_offset0=$((ec_offset0_str))
+	local ec_offset1=$((ec_offset1_str))
+	local ecfw_image_size_kb=$((ec_size_str))
+	local EC_REGION_START=$((ec_region_start_str))
+	local EC_REGION_SIZE_KB=$((ec_region_size_str))
+	echo "EC REGION START : $ec_region_start_str"
+	echo "EC REGION SIZE : $EC_REGION_SIZE_KB KB"
+	echo "EC IMAGE SIZE : $ec_size_str KB"
+	echo "Offset image 0 : $ec_offset0_str"
+	echo "Offset image 1 : $ec_offset1_str"
+
+	local ifwi_offset0=$(expr $ec_offset0 + $EC_REGION_START)
+	local ifwi_offset1=$(expr $ec_offset1 + $EC_REGION_START)
+	local ifwi_offset1_boundary=$(expr $ifwi_offset1 % 65536)
+
+	if [ $ifwi_offset0 == $EC_REGION_START ] ; then
+		echo "Valid offset for primary image $ec_offset0"
+	else
+		echo "Invalid offset for primary image $ec_offset0 ($ifwi_offset0)"
+		return -1;
+	fi
+
+	# Validate 2nd offset is 64KB boundary
+	if [ $ifwi_offset1_boundary == 0 ] ; then
+		echo "Valid offset for primary image $ec_offset1"
+	else
+		echo "Invalid offset for redundant image $ec_offset1 ($ifwi_offset1) - $ifwi_offset1_boundary"
+		return -1;
+	fi
+
+	# Calculate primary partion size
+	local EC_REGION_SIZE=$(expr $EC_REGION_SIZE_KB \* 1024)
+	local primary_partition=$(expr $ec_offset1 - $ec_offset0)
+	local secondary_partition=$(expr $EC_REGION_SIZE - $ec_offset1)
+	local primary_partition_kb=$(expr $primary_partition / 1024)
+	local secondary_partition_kb=$(expr $secondary_partition / 1024)
+	echo "Primary partition : $primary_partition [$primary_partition_kb KB] at $ifwi_offset0"
+	echo "Secondary partition : $secondary_partition [$secondary_partition_kb KB] at $ifwi_offset1"
+
+	# Validate both partitions can allocate the EC FW image size
+	if [ $primary_partition -gt $secondary_partition ] ; then
+		partition_size=$secondary_partition
+	else
+		partition_size=$primary_partition
+	fi
+	local partition_size_kb=$(expr $partition_size / 1024)
+	if [ $ecfw_image_size_kb -gt $partition_size_kb ] ; then
+		echo "Partition size $partition_size_kb to small for EC image $ecfw_image_size_kb"
+		return -1
+	fi
+
+	# Truncate to offset 1 in KB
+	truncate -s ${primary_partition_kb}K ${PROJECT_BINARY}
+
+	# Copy and duplicate
+	cp ${PROJECT_BINARY} ${SPI_IMAGE_BIN}
+	cat ${PROJECT_BINARY} >> ${SPI_IMAGE_BIN}
+
+	# Truncate to desired EC region size
+	truncate -s ${EC_REGION_SIZE_KB}K ${SPI_IMAGE_BIN}
+}
+
+generate_ecfw_binary  $1 $2 $3
diff --git a/boards/arm/npcx4m8f_evb/support/spi_cfg.txt b/boards/arm/npcx4m8f_evb/support/spi_cfg.txt
new file mode 100644
index 000000000..711e9caed
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/support/spi_cfg.txt
@@ -0,0 +1,12 @@
+[SPI]
+ECOffsetBytes = 0x4000
+ECRegionSizeKB = 512
+ECFWSizeKB = 224
+
+[IMAGE "0"]
+ImageLocation0 = 0x0
+FwBinFile = zephyr.bin
+
+[IMAGE "1"]
+ImageLocation1 = 0x3C000
+FwBinFile = zephyr.bin
diff --git a/boards/arm/npcx9m6f_evb/CMakeLists.txt b/boards/arm/npcx9m6f_evb/CMakeLists.txt
new file mode 100644
index 000000000..d766972ca
--- /dev/null
+++ b/boards/arm/npcx9m6f_evb/CMakeLists.txt
@@ -0,0 +1,10 @@
+#
+# Copyright (c) 2024 Intel Corporation.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+# Allow users to define SPI config layout'
+set_property(GLOBAL APPEND PROPERTY extra_post_build_commands
+    COMMAND cp ${PROJECT_BINARY_DIR}/zephyr.npcx.bin ${PROJECT_BINARY_DIR}/spi_image.bin && truncate -s 256K ${PROJECT_BINARY_DIR}/spi_image.bin
+  )
-- 
2.17.1


From 257b825ce4d90bb31dcc7613cc57d60071fcdf79 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 23 Apr 2024 19:43:16 -0700
Subject: [PATCH 29/42] include: drivers: espi: Postcode multibyte support

Add structure for multi-byte support

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 include/zephyr/drivers/espi.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/include/zephyr/drivers/espi.h b/include/zephyr/drivers/espi.h
index d2f77622f..ca04f52e0 100644
--- a/include/zephyr/drivers/espi.h
+++ b/include/zephyr/drivers/espi.h
@@ -317,6 +317,14 @@ struct espi_evt_data_acpi {
 	uint32_t reserved:16;
 };
 
+struct espi_evt_post {
+	union {
+		uint32_t code32;
+		uint8_t code[4];
+	};
+};
+
+
 /**
  * @brief eSPI event
  */
-- 
2.17.1


From 846f60998feb15d90b187acbf738c5aa6a5b4063 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 11 Jul 2024 14:31:04 -0700
Subject: [PATCH 30/42] dts: arm: nuvoton: Add support for PM3 channel as ACPI

Enable PM3 channel as ACPI PVT interface

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/nuvoton/npcx/npcx.dtsi | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dts/arm/nuvoton/npcx/npcx.dtsi b/dts/arm/nuvoton/npcx/npcx.dtsi
index 6c9a82f01..b395c3802 100644
--- a/dts/arm/nuvoton/npcx/npcx.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx.dtsi
@@ -384,9 +384,10 @@
 			       0x4000e000 0x2000
 			       0x400c7000 0x2000
 			       0x400c9000 0x2000
-			       0x400cb000 0x2000>;
+			       0x400cb000 0x2000
+			       0x400cd000 0x2000>;
 			reg-names = "mswc", "shm", "c2h", "kbc", "pm_acpi",
-				    "pm_hcmd";
+				    "pm_hcmd", "pm_acpi2";
 
 			/* host sub-module IRQ and priority */
 			interrupts = <25 3>, /* KBC Input-Buf-Full (IBF) */
-- 
2.17.1


From b33da47725fdeeedabc95021c3b3ca9fc56375df Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 11 Jul 2024 14:49:51 -0700
Subject: [PATCH 31/42] drivers: espi: npcx: Add support for ACPI PVT port

Use PM3 channel as ACPI PVT interface

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/host_subs_npcx.c | 61 +++++++++++++++++++++++++++++++++++
 1 file changed, 61 insertions(+)

diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index 0eacd6911..ba692c034 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -136,6 +136,7 @@ struct host_sub_npcx_config {
 	struct c2h_reg *const inst_c2h;
 	struct kbc_reg *const inst_kbc;
 	struct pmch_reg *const inst_pm_acpi;
+	struct pmch_reg *const inst_pm_acpi2;
 	struct pmch_reg *const inst_pm_hcmd;
 	/* clock configuration */
 	const uint8_t clks_size;
@@ -172,6 +173,7 @@ struct host_sub_npcx_config host_sub_cfg = {
 	.inst_c2h = (struct c2h_reg *)DT_INST_REG_ADDR_BY_NAME(0, c2h),
 	.inst_kbc = (struct kbc_reg *)DT_INST_REG_ADDR_BY_NAME(0, kbc),
 	.inst_pm_acpi = (struct pmch_reg *)DT_INST_REG_ADDR_BY_NAME(0, pm_acpi),
+	.inst_pm_acpi2 = (struct pmch_reg *)DT_INST_REG_ADDR_BY_NAME(0, pm_acpi2),
 	.inst_pm_hcmd = (struct pmch_reg *)DT_INST_REG_ADDR_BY_NAME(0, pm_hcmd),
 	.host_acc_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, host_acc_wui),
 	.clks_size = ARRAY_SIZE(host_dev_clk_cfg),
@@ -197,6 +199,7 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_LDN_SHM   0x0F
 #define EC_CFG_LDN_ACPI  0x11 /* PM Channel 1 */
 #define EC_CFG_LDN_HCMD  0x12 /* PM Channel 2 */
+#define EC_CFG_LDN_ACPI2 0x17 /* PM Channel 3 */
 
 /* Index of EC (4E/4F) Configuration Register */
 #define EC_CFG_IDX_LDN            0x07
@@ -358,6 +361,30 @@ static void host_acpi_process_input_data(uint8_t data)
 							evt);
 }
 
+static void host_acpi_pvt_process_input_data(uint8_t data)
+{
+	struct pmch_reg *const inst_acpi2 = host_sub_cfg.inst_pm_acpi2;
+	struct espi_event evt = {
+		.evt_type = ESPI_BUS_PERIPHERAL_NOTIFICATION,
+		.evt_details = ESPI_PERIPHERAL_HOST_IO_PVT,
+		.evt_data = ESPI_PERIPHERAL_NODATA
+	};
+	struct espi_evt_data_acpi *acpi_evt =
+				(struct espi_evt_data_acpi *)&evt.evt_data;
+
+	/*
+	 * Indicates if the host sent a command or data.
+	 * 0 = data
+	 * 1 = Command.
+	 */
+	acpi_evt->type = IS_BIT_SET(inst_acpi2->HIPMST, NPCX_HIPMST_CMD);
+	acpi_evt->data = data;
+	LOG_INF("%s: acpi type %d", __func__, acpi_evt->type);
+
+	espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev,
+							evt);
+}
+
 static void host_acpi_init(void)
 {
 	struct pmch_reg *const inst_acpi = host_sub_cfg.inst_pm_acpi;
@@ -383,6 +410,23 @@ static void host_acpi_init(void)
 	 */
 	inst_acpi->HIPMCTL |= BIT(7) | BIT(NPCX_HIPMCTL_IBFIE);
 }
+
+static void host_acpi_pvt_init(void)
+{
+	struct pmch_reg *const inst_acpi2 = host_sub_cfg.inst_pm_acpi2;
+
+	inst_acpi2->HIPMCTL &= ~BIT(NPCX_HIPMCTL_SCIPOL);
+	inst_acpi2->HIPMIC &= ~BIT(NPCX_HIPMIC_SMIPOL);
+	inst_acpi2->HIPMIC |= BIT(NPCX_HIPMIC_SMIB) | BIT(NPCX_HIPMIC_SCIB);
+	inst_acpi2->HIPMIE |= BIT(NPCX_HIPMIE_SCIE);
+	inst_acpi2->HIPMIE |= BIT(NPCX_HIPMIE_SMIE);
+	inst_acpi2->HIPMCTL |= BIT(7) | BIT(NPCX_HIPMCTL_IBFIE);
+
+	LOG_DBG("PM3 HIPMCTL %x", inst_acpi2->HIPMCTL);
+	LOG_DBG("PM3 HIPMIC %x", inst_acpi2->HIPMIC);
+	LOG_DBG("PM3 HIPMIE %x", inst_acpi2->HIPMIE);
+	LOG_DBG("PM3 HIPMCTL %x", inst_acpi2->HIPMCTL);
+}
 #endif
 
 #if defined(CONFIG_ESPI_PERIPHERAL_EC_HOST_CMD)
@@ -472,8 +516,18 @@ static void host_pmch_ibf_isr(const void *arg)
 	ARG_UNUSED(arg);
 	struct pmch_reg *const inst_acpi = host_sub_cfg.inst_pm_acpi;
 	struct pmch_reg *const inst_hcmd = host_sub_cfg.inst_pm_hcmd;
+	struct pmch_reg *const inst_acpi2 = host_sub_cfg.inst_pm_acpi2;
 	uint8_t in_data = 0;
 
+	/* Host put data on input buffer of ACPI channel */
+	if (IS_BIT_SET(inst_acpi2->HIPMST, NPCX_HIPMST_IBF)) {
+		/* Set processing flag before reading command byte */
+		inst_acpi2->HIPMST |= BIT(NPCX_HIPMST_F0);
+#if defined(CONFIG_ESPI_PERIPHERAL_HOST_IO)
+		host_acpi_pvt_process_input_data(in_data);
+#endif
+	}
+
 	/* Host put data on input buffer of ACPI channel */
 	if (IS_BIT_SET(inst_acpi->HIPMST, NPCX_HIPMST_IBF)) {
 		/* Set processing flag before reading command byte */
@@ -1019,6 +1073,12 @@ void npcx_host_init_subs_host_domain(void)
 		 */
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_ACPI);
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_LDN, EC_CFG_LDN_ACPI2);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_H, 0x06);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CMD_IO_ADDR_L, 0xA4);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_H, 0x06);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_DATA_IO_ADDR_L, 0xA0);
+		host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, EC_CFG_IDX_CTRL_LDN_ENABLE);
 	}
 
 	if (IS_ENABLED(CONFIG_ESPI_PERIPHERAL_EC_HOST_CMD) ||
@@ -1144,6 +1204,7 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_HOST_IO)
 	host_acpi_init();
+	host_acpi_pvt_init();
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_EC_HOST_CMD)
 	host_hcmd_init();
-- 
2.17.1


From a8a0b2900ffcd608a70bc0bba7aca289289996fe Mon Sep 17 00:00:00 2001
From: "Veturi, Sameer" <sameer.veturi@intel.com>
Date: Mon, 7 Oct 2024 16:17:11 +0530
Subject: [PATCH 32/42] soc: ite: ITE Zephyr fork delta changes for v3.6

ITE Zephyr fork delta changes for v3.6

Signed-off-by: Veturi, Sameer <sameer.veturi@intel.com>
---
 soc/riscv/ite_ec/common/soc_gpio.h |  30 ++++++
 soc/riscv/ite_ec/common/soc_pins.h | 161 +++++++++++++++++++++++++++++
 soc/riscv/ite_ec/it8xxx2/soc.h     |   2 +
 3 files changed, 193 insertions(+)
 create mode 100755 soc/riscv/ite_ec/common/soc_gpio.h
 create mode 100755 soc/riscv/ite_ec/common/soc_pins.h

diff --git a/soc/riscv/ite_ec/common/soc_gpio.h b/soc/riscv/ite_ec/common/soc_gpio.h
new file mode 100755
index 000000000..ba138750d
--- /dev/null
+++ b/soc/riscv/ite_ec/common/soc_gpio.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2022 Intel Corporation
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/** @file
+ * @brief ITE 8XXX2 MCU family General Purpose Input Output (GPIO) defines.
+ *
+ */
+
+#ifndef _ITE_SOC_GPIO_H_
+#define _ITE_SOC_GPIO_H_
+
+#define ITE_GPIO_PORTA     0
+#define ITE_GPIO_PORTB     1
+#define ITE_GPIO_PORTC     2
+#define ITE_GPIO_PORTD     3
+#define ITE_GPIO_PORTE     4
+#define ITE_GPIO_PORTF     5
+#define ITE_GPIO_PORTG     6
+#define ITE_GPIO_PORTH     7
+#define ITE_GPIO_PORTI     8
+#define ITE_GPIO_PORTJ     9
+#define ITE_GPIO_PORTK     10
+#define ITE_GPIO_PORTL     11
+#define ITE_GPIO_PORTM     12
+#define ITE_GPIO_MAX_PORT    13
+#define ITE_NUM_GPIO_PORTS   13
+
+#endif /* _ITE_SOC_GPIO_H_ */
diff --git a/soc/riscv/ite_ec/common/soc_pins.h b/soc/riscv/ite_ec/common/soc_pins.h
new file mode 100755
index 000000000..38290ba40
--- /dev/null
+++ b/soc/riscv/ite_ec/common/soc_pins.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2022 Intel Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _SOC_ITE_GPIOS_H_
+#define _SOC_ITE_GPIOS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Begin Port A */
+#define ITE_GPIO_GPA0	(0U)
+#define ITE_GPIO_GPA1	(1U)
+#define ITE_GPIO_GPA2	(2U)
+#define ITE_GPIO_GPA3	(3U)
+#define ITE_GPIO_GPA4	(4U)
+#define ITE_GPIO_GPA5	(5U)
+#define ITE_GPIO_GPA6	(6U)
+#define ITE_GPIO_GPA7	(7U)
+/* End Port A */
+
+/* Begin Port B */
+#define ITE_GPIO_GPB0	(0U)
+#define ITE_GPIO_GPB1	(1U)
+#define ITE_GPIO_GPB2	(2U)
+#define ITE_GPIO_GPB3	(3U)
+#define ITE_GPIO_GPB4	(4U)
+#define ITE_GPIO_GPB5	(5U)
+#define ITE_GPIO_GPB6	(6U)
+#define ITE_GPIO_GPB7	(7U)
+/* End Port B */
+
+/* Begin Port C */
+#define ITE_GPIO_GPC0	(0U)
+#define ITE_GPIO_GPC1	(1U)
+#define ITE_GPIO_GPC2	(2U)
+#define ITE_GPIO_GPC3	(3U)
+#define ITE_GPIO_GPC4	(4U)
+#define ITE_GPIO_GPC5	(5U)
+#define ITE_GPIO_GPC6	(6U)
+#define ITE_GPIO_GPC7	(7U)
+/* End Port C */
+
+/* Begin Port D */
+#define ITE_GPIO_GPD0	(0U)
+#define ITE_GPIO_GPD1	(1U)
+#define ITE_GPIO_GPD2	(2U)
+#define ITE_GPIO_GPD3	(3U)
+#define ITE_GPIO_GPD4	(4U)
+#define ITE_GPIO_GPD5	(5U)
+#define ITE_GPIO_GPD6	(6U)
+#define ITE_GPIO_GPD7	(7U)
+/* End Port D */
+
+/* Begin Port E */
+#define ITE_GPIO_GPE0	(0U)
+#define ITE_GPIO_GPE1	(1U)
+#define ITE_GPIO_GPE2	(2U)
+#define ITE_GPIO_GPE3	(3U)
+#define ITE_GPIO_GPE4	(4U)
+#define ITE_GPIO_GPE5	(5U)
+#define ITE_GPIO_GPE6	(6U)
+#define ITE_GPIO_GPE7	(7U)
+/* End Port E */
+
+/* Begin Port F */
+#define ITE_GPIO_GPF0	(0U)
+#define ITE_GPIO_GPF1	(1U)
+#define ITE_GPIO_GPF2	(2U)
+#define ITE_GPIO_GPF3	(3U)
+#define ITE_GPIO_GPF4	(4U)
+#define ITE_GPIO_GPF5	(5U)
+#define ITE_GPIO_GPF6	(6U)
+#define ITE_GPIO_GPF7	(7U)
+/* End Port F */
+
+/* Begin Port G */
+#define ITE_GPIO_GPG0	(0U)
+#define ITE_GPIO_GPG1	(1U)
+#define ITE_GPIO_GPG2	(2U)
+#define ITE_GPIO_GPG3	(3U)
+#define ITE_GPIO_GPG4	(4U)
+#define ITE_GPIO_GPG5	(5U)
+#define ITE_GPIO_GPG6	(6U)
+#define ITE_GPIO_GPG7	(7U)
+/* End Port G */
+
+/* Begin Port H */
+#define ITE_GPIO_GPH0	(0U)
+#define ITE_GPIO_GPH1	(1U)
+#define ITE_GPIO_GPH2	(2U)
+#define ITE_GPIO_GPH3	(3U)
+#define ITE_GPIO_GPH4	(4U)
+#define ITE_GPIO_GPH5	(5U)
+#define ITE_GPIO_GPH6	(6U)
+#define ITE_GPIO_GPH7	(7U)
+/* End Port H */
+
+/* Begin Port I */
+#define ITE_GPIO_GPI0	(0U)
+#define ITE_GPIO_GPI1	(1U)
+#define ITE_GPIO_GPI2	(2U)
+#define ITE_GPIO_GPI3	(3U)
+#define ITE_GPIO_GPI4	(4U)
+#define ITE_GPIO_GPI5	(5U)
+#define ITE_GPIO_GPI6	(6U)
+#define ITE_GPIO_GPI7	(7U)
+/* End Port I */
+
+/* Begin Port J */
+#define ITE_GPIO_GPJ0	(0U)
+#define ITE_GPIO_GPJ1	(1U)
+#define ITE_GPIO_GPJ2	(2U)
+#define ITE_GPIO_GPJ3	(3U)
+#define ITE_GPIO_GPJ4	(4U)
+#define ITE_GPIO_GPJ5	(5U)
+#define ITE_GPIO_GPJ6	(6U)
+#define ITE_GPIO_GPJ7	(7U)
+/* End Port J */
+
+/* Begin Port K */
+#define ITE_GPIO_GPK0	(0U)
+#define ITE_GPIO_GPK1	(1U)
+#define ITE_GPIO_GPK2	(2U)
+#define ITE_GPIO_GPK3	(3U)
+#define ITE_GPIO_GPK4	(4U)
+#define ITE_GPIO_GPK5	(5U)
+#define ITE_GPIO_GPK6	(6U)
+#define ITE_GPIO_GPK7	(7U)
+/* End Port K */
+
+/* Begin Port L */
+#define ITE_GPIO_GPL0	(0U)
+#define ITE_GPIO_GPL1	(1U)
+#define ITE_GPIO_GPL2	(2U)
+#define ITE_GPIO_GPL3	(3U)
+#define ITE_GPIO_GPL4	(4U)
+#define ITE_GPIO_GPL5	(5U)
+#define ITE_GPIO_GPL6	(6U)
+#define ITE_GPIO_GPL7	(7U)
+/* End Port L */
+
+/* Begin Port M */
+#define ITE_GPIO_GPM0	(0U)
+#define ITE_GPIO_GPM1	(1U)
+#define ITE_GPIO_GPM2	(2U)
+#define ITE_GPIO_GPM3	(3U)
+#define ITE_GPIO_GPM4	(4U)
+#define ITE_GPIO_GPM5	(5U)
+#define ITE_GPIO_GPM6	(6U)
+#define ITE_GPIO_GPM7	(7U)
+/* End Port M */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SOC_ITE_GPIOS_H_ */
diff --git a/soc/riscv/ite_ec/it8xxx2/soc.h b/soc/riscv/ite_ec/it8xxx2/soc.h
index 527152601..d4fb6f68e 100644
--- a/soc/riscv/ite_ec/it8xxx2/soc.h
+++ b/soc/riscv/ite_ec/it8xxx2/soc.h
@@ -8,5 +8,7 @@
  */
 #include <soc_common.h>
 
+#include "../common/soc_gpio.h"
+#include "../common/soc_pins.h"
 
 #endif /* __RISCV_ITE_SOC_H_ */
-- 
2.17.1


From 3740bf9dea6f1a16452dc8964ec572dde1f4d997 Mon Sep 17 00:00:00 2001
From: Aditya Bhutada <aditya.bhutada@intel.com>
Date: Mon, 14 Apr 2025 15:27:37 -0700
Subject: [PATCH 33/42] drivers: espi: espi_mchp_xec: Fix the VW change check
 time

Adjusted the VW change check timings:
- Polling time changed from 100 uSec to 1 uSec.
- Timeout value changed from 10 mSec to 1 mSec.

This is to achieve the lowest possible pulse width for SCI VW in S0,
while ensuring that the VW change check is still reliable for S0iX
where SoC may take longer to process upstream events.

Also added -ETIMEDOUT error when failure.

Signed-off-by: Aditya Bhutada <aditya.bhutada@intel.com>
---
 drivers/espi/espi_mchp_xec.c    | 13 +++++++++----
 drivers/espi/espi_mchp_xec_v2.c | 13 +++++++++----
 2 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 586789148..8c1796ef5 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -19,9 +19,9 @@
 #define ESPI_XEC_VWIRE_ACK_DELAY    10ul
 
 /* Maximum timeout to transmit a virtual wire packet.
- * 10 ms expressed in multiples of 100us
+ * 1 ms expressed in multiples of 1us
  */
-#define ESPI_XEC_VWIRE_SEND_TIMEOUT 100ul
+#define ESPI_XEC_VWIRE_SEND_TIMEOUT 1000ul
 
 #define VW_MAX_GIRQS                2ul
 
@@ -461,10 +461,15 @@ static int espi_xec_send_vwire(const struct device *dev,
 		/* Ensure eSPI virtual wire packet is transmitted
 		 * There is no interrupt, so need to poll register
 		 */
-		uint8_t rd_cnt = ESPI_XEC_VWIRE_SEND_TIMEOUT;
+		uint16_t rd_cnt = ESPI_XEC_VWIRE_SEND_TIMEOUT;
 
 		while (reg->SRC_CHG && rd_cnt--) {
-			k_busy_wait(100);
+			k_busy_wait(1);
+		}
+
+		if (rd_cnt == 0) {
+			LOG_ERR("VW %d send timeout", signal);
+			return -ETIMEDOUT;
 		}
 	}
 
diff --git a/drivers/espi/espi_mchp_xec_v2.c b/drivers/espi/espi_mchp_xec_v2.c
index a1a5acefd..67e4d9a68 100644
--- a/drivers/espi/espi_mchp_xec_v2.c
+++ b/drivers/espi/espi_mchp_xec_v2.c
@@ -25,9 +25,9 @@
 #define ESPI_XEC_VWIRE_ACK_DELAY	10ul
 
 /* Maximum timeout to transmit a virtual wire packet.
- * 10 ms expressed in multiples of 100us
+ * 1 ms expressed in multiples of 1us
  */
-#define ESPI_XEC_VWIRE_SEND_TIMEOUT	100ul
+#define ESPI_XEC_VWIRE_SEND_TIMEOUT	1000ul
 
 #define VW_MAX_GIRQS			2ul
 
@@ -325,10 +325,15 @@ static int espi_xec_send_vwire(const struct device *dev,
 		/* Ensure eSPI virtual wire packet is transmitted
 		 * There is no interrupt, so need to poll register
 		 */
-		uint8_t rd_cnt = ESPI_XEC_VWIRE_SEND_TIMEOUT;
+		uint16_t rd_cnt = ESPI_XEC_VWIRE_SEND_TIMEOUT;
 
 		while (sys_read8(regaddr + SMVW_BI_SRC_CHG) && rd_cnt--) {
-			k_busy_wait(100);
+			k_busy_wait(1);
+		}
+
+		if (rd_cnt == 0) {
+			LOG_ERR("VW %d send timeout", signal);
+			return -ETIMEDOUT;
 		}
 	}
 
-- 
2.17.1


From 3a76f9e41f0253cd3f5549a6166c810d93740c3e Mon Sep 17 00:00:00 2001
From: Aditya Bhutada <aditya.bhutada@intel.com>
Date: Mon, 14 Apr 2025 15:29:26 -0700
Subject: [PATCH 34/42] drivers: espi: Add return value to eSPI send_vwire API

Added note about return value to the eSPI send_vwire API in the header:
-ETIMEDOUT & _EINVAL.

Signed-off-by: Aditya Bhutada <aditya.bhutada@intel.com>
---
 include/zephyr/drivers/espi.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/include/zephyr/drivers/espi.h b/include/zephyr/drivers/espi.h
index ca04f52e0..985bba316 100644
--- a/include/zephyr/drivers/espi.h
+++ b/include/zephyr/drivers/espi.h
@@ -706,6 +706,8 @@ static inline int z_impl_espi_write_lpc_request(const struct device *dev,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error, failed to send over the bus.
+ * @retval -EINVAL invalid signal.
+ * @retval -ETIMEDOUT timeout waiting for eSPI controller to process the VW.
  */
 __syscall int espi_send_vwire(const struct device *dev,
 			      enum espi_vwire_signal signal,
-- 
2.17.1


From 0aa84a11ba13809abc787044f269eae79d0bb27e Mon Sep 17 00:00:00 2001
From: Ederson de Souza <ederson.desouza@intel.com>
Date: Fri, 5 Jan 2024 13:29:20 -0800
Subject: [PATCH 35/42] kernel: Device deferred initialization

Currently, all devices are initialized at boot time (following their
level and priority order). This patch introduces deferred
initialization: by setting the property `zephyr,deferred-init` on a
device on the devicetree, Zephyr will not initialized the device.

To initialize such devices, one has to call `device_init()`.

Deferred initialization is done by grouping all deferred devices on a
different ELF section. In this way, there's no need to consume more
memory to keep track of deferred devices. When `device_init()` is
called, Zephyr will scan the deferred devices section and call the
initialization function for the matching device. As this scanning is
done only during deferred device initialization, its cost should be
bearable.

Signed-off-by: Ederson de Souza <ederson.desouza@intel.com>
---
 dts/bindings/base/base.yaml                   |  6 ++
 include/zephyr/device.h                       | 44 +++++++++-
 .../common-rom/common-rom-kernel-devices.ld   |  3 +
 kernel/init.c                                 | 82 +++++++++++++------
 4 files changed, 110 insertions(+), 25 deletions(-)

diff --git a/dts/bindings/base/base.yaml b/dts/bindings/base/base.yaml
index f1d1109a1..b2e670fb5 100644
--- a/dts/bindings/base/base.yaml
+++ b/dts/bindings/base/base.yaml
@@ -92,3 +92,9 @@ properties:
   mbox-names:
     type: string-array
     description: Provided names of mailbox / IPM channel specifiers
+
+  zephyr,deferred-init:
+    type: boolean
+    description: |
+      Do not initialize device automatically on boot. Device should be manually
+      initialized using device_init().
diff --git a/include/zephyr/device.h b/include/zephyr/device.h
index 00d1c1552..a50e8a2ba 100644
--- a/include/zephyr/device.h
+++ b/include/zephyr/device.h
@@ -149,6 +149,16 @@ typedef int16_t device_handle_t;
 #define DEVICE_DT_NAME(node_id)                                                \
 	DT_PROP_OR(node_id, label, DT_NODE_FULL_NAME(node_id))
 
+/**
+ * @brief Determine if a devicetree node initialization should be deferred.
+ *
+ * @param node_id The devicetree node identifier.
+ *
+ * @return Boolean stating if node initialization should be deferred.
+ */
+#define DEVICE_DT_DEFER(node_id)                                               \
+	DT_PROP(node_id, zephyr_deferred_init)
+
 /**
  * @brief Create a device object from a devicetree node identifier and set it up
  * for boot time initialization.
@@ -756,6 +766,22 @@ static inline bool z_impl_device_is_ready(const struct device *dev)
 	return z_device_is_ready(dev);
 }
 
+/**
+ * @brief Initialize a device.
+ *
+ * A device whose initialization was deferred (by marking it as
+ * ``zephyr,deferred-init`` on devicetree) needs to be initialized manually via
+ * this call. Note that only devices whose initialization was deferred can be
+ * initialized via this call - one can not try to initialize a non
+ * initialization deferred device that failed initialization with this call.
+ *
+ * @param dev device to be initialized.
+ *
+ * @retval -ENOENT If device was not found - or isn't a deferred one.
+ * @retval -errno For other errors.
+ */
+__syscall int device_init(const struct device *dev);
+
 /**
  * @}
  */
@@ -986,6 +1012,18 @@ static inline bool z_impl_device_is_ready(const struct device *dev)
 			},                                                                         \
 	}
 
+#define Z_DEFER_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id, init_fn_)                                \
+	static const Z_DECL_ALIGN(struct init_entry) __used __noasan                               \
+		__attribute__((__section__(".z_deferred_init")))                                   \
+		Z_INIT_ENTRY_NAME(DEVICE_NAME_GET(dev_id)) = {                                     \
+			.init_fn = {COND_CODE_1(Z_DEVICE_IS_MUTABLE(node_id), (.dev_rw), (.dev)) = \
+					    (init_fn_)},                                           \
+			{                                                                          \
+				COND_CODE_1(Z_DEVICE_IS_MUTABLE(node_id), (.dev_rw), (.dev)) =     \
+					&DEVICE_NAME_GET(dev_id),                                  \
+			},                                                                         \
+	}
+
 /**
  * @brief Define a @ref device and all other required objects.
  *
@@ -1017,7 +1055,11 @@ static inline bool z_impl_device_is_ready(const struct device *dev)
 	Z_DEVICE_BASE_DEFINE(node_id, dev_id, name, pm, data, config, level,   \
 			     prio, api, state, Z_DEVICE_DEPS_NAME(dev_id));    \
                                                                                \
-	Z_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id, init_fn, level, prio)
+	COND_CODE_1(DEVICE_DT_DEFER(node_id),                                  \
+		    (Z_DEFER_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id,         \
+						      init_fn)),               \
+		    (Z_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id, init_fn,      \
+						level, prio)));
 
 /**
  * @brief Declare a device for each status "okay" devicetree node.
diff --git a/include/zephyr/linker/common-rom/common-rom-kernel-devices.ld b/include/zephyr/linker/common-rom/common-rom-kernel-devices.ld
index dfa19d134..47f20cb00 100644
--- a/include/zephyr/linker/common-rom/common-rom-kernel-devices.ld
+++ b/include/zephyr/linker/common-rom/common-rom-kernel-devices.ld
@@ -18,6 +18,9 @@
 		CREATE_OBJ_LEVEL(init, APPLICATION)
 		CREATE_OBJ_LEVEL(init, SMP)
 		__init_end = .;
+		__deferred_init_list_start = .;
+		KEEP(*(.z_deferred_init))
+		__deferred_init_list_end = .;
 	} GROUP_ROM_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)
 
 	ITERABLE_SECTION_ROM_NUMERIC(device, 4)
diff --git a/kernel/init.c b/kernel/init.c
index e4637d3af..e41301956 100644
--- a/kernel/init.c
+++ b/kernel/init.c
@@ -35,6 +35,7 @@
 #include <zephyr/timing/timing.h>
 #include <zephyr/logging/log.h>
 #include <zephyr/pm/device_runtime.h>
+#include <zephyr/internal/syscall_handler.h>
 LOG_MODULE_REGISTER(os, CONFIG_KERNEL_LOG_LEVEL);
 
 BUILD_ASSERT(CONFIG_MP_NUM_CPUS == CONFIG_MP_MAX_NUM_CPUS,
@@ -249,6 +250,37 @@ extern volatile uintptr_t __stack_chk_guard;
 __pinned_bss
 bool z_sys_post_kernel;
 
+static int do_device_init(const struct init_entry *entry)
+{
+	const struct device *dev = entry->dev;
+	int rc = 0;
+
+	if (entry->init_fn.dev != NULL) {
+		rc = entry->init_fn.dev(dev);
+		/* Mark device initialized. If initialization
+		 * failed, record the error condition.
+		 */
+		if (rc != 0) {
+			if (rc < 0) {
+				rc = -rc;
+			}
+			if (rc > UINT8_MAX) {
+				rc = UINT8_MAX;
+			}
+			dev->state->init_res = rc;
+		}
+	}
+
+	dev->state->initialized = true;
+
+	if (rc == 0) {
+		/* Run automatic device runtime enablement */
+		(void)pm_device_runtime_auto_enable(dev);
+	}
+
+	return rc;
+}
+
 /**
  * @brief Execute all the init entry initialization functions at a given level
  *
@@ -280,36 +312,38 @@ static void z_sys_init_run_level(enum init_level level)
 		const struct device *dev = entry->dev;
 
 		if (dev != NULL) {
-			int rc = 0;
-
-			if (entry->init_fn.dev != NULL) {
-				rc = entry->init_fn.dev(dev);
-				/* Mark device initialized. If initialization
-				 * failed, record the error condition.
-				 */
-				if (rc != 0) {
-					if (rc < 0) {
-						rc = -rc;
-					}
-					if (rc > UINT8_MAX) {
-						rc = UINT8_MAX;
-					}
-					dev->state->init_res = rc;
-				}
-			}
-
-			dev->state->initialized = true;
-
-			if (rc == 0) {
-				/* Run automatic device runtime enablement */
-				(void)pm_device_runtime_auto_enable(dev);
-			}
+			do_device_init(entry);
 		} else {
 			(void)entry->init_fn.sys();
 		}
 	}
 }
 
+int z_impl_device_init(const struct device *dev)
+{
+	if (dev == NULL) {
+		return -ENOENT;
+	}
+
+	STRUCT_SECTION_FOREACH_ALTERNATE(_deferred_init, init_entry, entry) {
+		if (entry->dev == dev) {
+			return do_device_init(entry);
+		}
+	}
+
+	return -ENOENT;
+}
+
+#ifdef CONFIG_USERSPACE
+static inline int z_vrfy_device_init(const struct device *dev)
+{
+	K_OOPS(K_SYSCALL_OBJ_INIT(dev, K_OBJ_ANY));
+
+	return z_impl_device_init(dev);
+}
+#include <syscalls/device_init_mrsh.c>
+#endif
+
 extern void boot_banner(void);
 
 /**
-- 
2.17.1


From 4371bc4fc186863b502c2624a41876fffbae6331 Mon Sep 17 00:00:00 2001
From: Ederson de Souza <ederson.desouza@intel.com>
Date: Fri, 5 Jan 2024 13:33:25 -0800
Subject: [PATCH 36/42] tests/kernel/device: Add tests for device deferred init

Ensure that devices are not ready before calling `device_init()`, but
are after the call.

Signed-off-by: Ederson de Souza <ederson.desouza@intel.com>
---
 tests/kernel/device/app.overlay               | 14 ++++++
 .../device/boards/hifive_unmatched.overlay    | 14 ++++++
 .../device/dts/bindings/fakedeferdriver.yml   |  8 ++++
 tests/kernel/device/src/main.c                | 48 ++++++++++++++++++-
 4 files changed, 83 insertions(+), 1 deletion(-)
 create mode 100644 tests/kernel/device/dts/bindings/fakedeferdriver.yml

diff --git a/tests/kernel/device/app.overlay b/tests/kernel/device/app.overlay
index d7426f2b6..108f14bdb 100644
--- a/tests/kernel/device/app.overlay
+++ b/tests/kernel/device/app.overlay
@@ -52,6 +52,20 @@
 		status = "okay";
 	};
 
+	fakedeferdriver@E7000000 {
+		compatible = "fakedeferdriver";
+		reg = <0xE7000000 0x2000>;
+		status = "okay";
+		zephyr,deferred-init;
+	};
+
+	fakedeferdriver@E8000000 {
+		compatible = "fakedeferdriver";
+		reg = <0xE8000000 0x2000>;
+		status = "okay";
+		zephyr,deferred-init;
+	};
+
 	fakedomain_0: fakedomain_0 {
 		compatible = "fakedomain";
 		status = "okay";
diff --git a/tests/kernel/device/boards/hifive_unmatched.overlay b/tests/kernel/device/boards/hifive_unmatched.overlay
index 40fa5e74a..05f9992d8 100644
--- a/tests/kernel/device/boards/hifive_unmatched.overlay
+++ b/tests/kernel/device/boards/hifive_unmatched.overlay
@@ -49,6 +49,20 @@
 		status = "okay";
 	};
 
+	fakedeferdriver@E7000000 {
+		compatible = "fakedeferdriver";
+		reg = <0x0 0xE7000000 0x0 0x2000>;
+		status = "okay";
+		zephyr,deferred-init;
+	};
+
+	fakedeferdriver@E8000000 {
+		compatible = "fakedeferdriver";
+		reg = <0x0 0xE8000000 0x0 0x2000>;
+		status = "okay";
+		zephyr,deferred-init;
+	};
+
 	fakedomain_0: fakedomain_0 {
 		compatible = "fakedomain";
 		status = "okay";
diff --git a/tests/kernel/device/dts/bindings/fakedeferdriver.yml b/tests/kernel/device/dts/bindings/fakedeferdriver.yml
new file mode 100644
index 000000000..672ed99d1
--- /dev/null
+++ b/tests/kernel/device/dts/bindings/fakedeferdriver.yml
@@ -0,0 +1,8 @@
+# Copyright (c) 2023 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+description: Properties for fake deferred driver.
+
+compatible: "fakedeferdriver"
+
+include: base.yaml
diff --git a/tests/kernel/device/src/main.c b/tests/kernel/device/src/main.c
index 4c02a52ce..437f2ae05 100644
--- a/tests/kernel/device/src/main.c
+++ b/tests/kernel/device/src/main.c
@@ -6,6 +6,7 @@
 
 #include <zephyr/kernel.h>
 #include <zephyr/device.h>
+#include <zephyr/drivers/gpio.h>
 #include <zephyr/init.h>
 #include <zephyr/ztest.h>
 #include <zephyr/sys/printk.h>
@@ -21,10 +22,23 @@
 #define MY_DRIVER_A     "my_driver_A"
 #define MY_DRIVER_B     "my_driver_B"
 
+#define FAKEDEFERDRIVER0	DEVICE_DT_GET(DT_PATH(fakedeferdriver_e7000000))
+#define FAKEDEFERDRIVER1	DEVICE_DT_GET(DT_PATH(fakedeferdriver_e8000000))
+
 /* A device without init call */
 DEVICE_DEFINE(dummy_noinit, DUMMY_NOINIT, NULL, NULL, NULL, NULL,
 	      POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);
 
+/* To access from userspace, the device needs an API. Use a dummy GPIO one */
+static const struct gpio_driver_api fakedeferdriverapi;
+
+/* Fake deferred devices */
+DEVICE_DT_DEFINE(DT_INST(0, fakedeferdriver), NULL, NULL, NULL, NULL,
+	      POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);
+DEVICE_DT_DEFINE(DT_INST(1, fakedeferdriver), NULL, NULL, NULL, NULL,
+	      POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,
+	      &fakedeferdriverapi);
+
 /**
  * @brief Test cases to verify device objects
  *
@@ -387,9 +401,41 @@ ZTEST(device, test_abstraction_driver_common)
 	zassert_true(baz == 2, "common API do_that fail");
 }
 
+ZTEST(device, test_deferred_init)
+{
+	int ret;
+
+	zassert_false(device_is_ready(FAKEDEFERDRIVER0));
+
+	ret = device_init(FAKEDEFERDRIVER0);
+	zassert_true(ret == 0);
+
+	zassert_true(device_is_ready(FAKEDEFERDRIVER0));
+}
+
+ZTEST_USER(device, test_deferred_init_user)
+{
+	int ret;
+
+	zassert_false(device_is_ready(FAKEDEFERDRIVER1));
+
+	ret = device_init(FAKEDEFERDRIVER1);
+	zassert_true(ret == 0);
+
+	zassert_true(device_is_ready(FAKEDEFERDRIVER1));
+}
+
+void *user_setup(void)
+{
+#ifdef CONFIG_USERSPACE
+	k_object_access_grant(FAKEDEFERDRIVER1, k_current_get());
+#endif
+
+	return NULL;
+}
 
 /**
  * @}
  */
 
-ZTEST_SUITE(device, NULL, NULL, NULL, NULL, NULL);
+ZTEST_SUITE(device, NULL, user_setup, NULL, NULL, NULL);
-- 
2.17.1


From b2b50f480687c23a6504c6cf821ec13d857c8efd Mon Sep 17 00:00:00 2001
From: Adrien Ricciardi <aricciardi@baylibre.com>
Date: Wed, 15 May 2024 11:28:34 +0200
Subject: [PATCH 37/42] sys: util: Add SIZEOF_FIELD() macro

This macro allows to know the size of a struct member at compile time.

Several parts of the Zephyr code are currently using directly the macro
code.

Also added a unit test.

Signed-off-by: Adrien Ricciardi <aricciardi@baylibre.com>
---
 include/zephyr/sys/util.h | 10 ++++++++++
 tests/unit/util/main.c    | 15 +++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/include/zephyr/sys/util.h b/include/zephyr/sys/util.h
index 71ed1f7f4..12855aaa6 100644
--- a/include/zephyr/sys/util.h
+++ b/include/zephyr/sys/util.h
@@ -268,6 +268,16 @@ extern "C" {
 		((type *)(((char *)(ptr)) - offsetof(type, field))); \
 	})
 
+/**
+ * @brief Report the size of a struct field in bytes.
+ *
+ * @param type The structure containing the field of interest.
+ * @param member The field to return the size of.
+ *
+ * @return The field size.
+ */
+#define SIZEOF_FIELD(type, member) sizeof((((type *)0)->member))
+
 /**
  * @brief Concatenate input arguments
  *
diff --git a/tests/unit/util/main.c b/tests/unit/util/main.c
index 3ae9778ae..1299d5567 100644
--- a/tests/unit/util/main.c
+++ b/tests/unit/util/main.c
@@ -762,4 +762,19 @@ ZTEST(util, test_CONCAT)
 	zassert_equal(CONCAT(CAT_PART1, CONCAT(CAT_PART2, CAT_PART3)), 123);
 }
 
+ZTEST(util, test_SIZEOF_FIELD)
+{
+	struct test_t {
+		uint32_t a;
+		uint8_t b;
+		uint8_t c[17];
+		int16_t d;
+	};
+
+	BUILD_ASSERT(SIZEOF_FIELD(struct test_t, a) == 4, "The a member is 4-byte wide.");
+	BUILD_ASSERT(SIZEOF_FIELD(struct test_t, b) == 1, "The b member is 1-byte wide.");
+	BUILD_ASSERT(SIZEOF_FIELD(struct test_t, c) == 17, "The c member is 17-byte wide.");
+	BUILD_ASSERT(SIZEOF_FIELD(struct test_t, d) == 2, "The d member is 2-byte wide.");
+}
+
 ZTEST_SUITE(util, NULL, NULL, NULL, NULL, NULL);
-- 
2.17.1


From d22afe0b99680d8b638a316cd1ddd8b0b3b2c6fd Mon Sep 17 00:00:00 2001
From: Jun Lin <CHLin56@nuvoton.com>
Date: Fri, 1 Nov 2024 16:40:27 +0800
Subject: [PATCH 38/42] board: npcx: remove CONFIG_PINCTRL from defconfig of
 npcx boards

The CONFIG_PINCTRL is removed from the board's defconfig files.
Drivers which use pin control function should add "select PINCTRL"
in their Kconfig files.

Fixes #78619

Signed-off-by: Jun Lin <CHLin56@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig   | 3 ---
 boards/arm/npcx7m6fb_evb/npcx7m6fb_evb_defconfig | 3 ---
 boards/arm/npcx9m6f_evb/npcx9m6f_evb_defconfig   | 3 ---
 drivers/adc/Kconfig.npcx                         | 1 +
 drivers/espi/Kconfig.npcx                        | 1 +
 drivers/flash/Kconfig.npcx_fiu                   | 1 +
 drivers/i2c/Kconfig.npcx                         | 1 +
 drivers/input/Kconfig.npcx                       | 1 +
 drivers/peci/Kconfig.npcx                        | 1 +
 drivers/ps2/Kconfig.npcx                         | 1 +
 drivers/pwm/Kconfig.npcx                         | 1 +
 drivers/serial/Kconfig.npcx                      | 1 +
 drivers/spi/Kconfig.npcx                         | 1 +
 subsys/mgmt/ec_host_cmd/backends/Kconfig         | 1 +
 14 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig b/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
index 4ec779de4..c04cf39d7 100644
--- a/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
@@ -30,9 +30,6 @@ CONFIG_UART_INTERRUPT_DRIVEN=y
 # GPIO Driver
 CONFIG_GPIO=y
 
-# Pin Controller Driver
-CONFIG_PINCTRL=y
-
 # Console Driver
 CONFIG_CONSOLE=y
 CONFIG_UART_CONSOLE=y
diff --git a/boards/arm/npcx7m6fb_evb/npcx7m6fb_evb_defconfig b/boards/arm/npcx7m6fb_evb/npcx7m6fb_evb_defconfig
index c1abbbb44..6e592f0b5 100644
--- a/boards/arm/npcx7m6fb_evb/npcx7m6fb_evb_defconfig
+++ b/boards/arm/npcx7m6fb_evb/npcx7m6fb_evb_defconfig
@@ -30,9 +30,6 @@ CONFIG_UART_INTERRUPT_DRIVEN=y
 # GPIO Driver
 CONFIG_GPIO=y
 
-# Pin Controller Driver
-CONFIG_PINCTRL=y
-
 # Console Driver
 CONFIG_CONSOLE=y
 CONFIG_UART_CONSOLE=y
diff --git a/boards/arm/npcx9m6f_evb/npcx9m6f_evb_defconfig b/boards/arm/npcx9m6f_evb/npcx9m6f_evb_defconfig
index ae8b83cf8..ca5f1f256 100644
--- a/boards/arm/npcx9m6f_evb/npcx9m6f_evb_defconfig
+++ b/boards/arm/npcx9m6f_evb/npcx9m6f_evb_defconfig
@@ -30,9 +30,6 @@ CONFIG_UART_INTERRUPT_DRIVEN=y
 # GPIO Driver
 CONFIG_GPIO=y
 
-# Pin Controller Driver
-CONFIG_PINCTRL=y
-
 # Console Driver
 CONFIG_CONSOLE=y
 CONFIG_UART_CONSOLE=y
diff --git a/drivers/adc/Kconfig.npcx b/drivers/adc/Kconfig.npcx
index 0209fd845..a61266ffe 100644
--- a/drivers/adc/Kconfig.npcx
+++ b/drivers/adc/Kconfig.npcx
@@ -7,6 +7,7 @@ config ADC_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) ADC driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_ADC_ENABLED
+	select PINCTRL
 	help
 	  This option enables the ADC driver for NPCX family of
 	  processors.
diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index 9a731426a..b46af552d 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -8,6 +8,7 @@ config ESPI_NPCX
 	default y
 	depends on SOC_FAMILY_NPCX
 	depends on DT_HAS_NUVOTON_NPCX_ESPI_ENABLED
+	select PINCTRL
 	help
 	  This option enables the Intel Enhanced Serial Peripheral Interface
 	  (eSPI) for NPCX family of processors.
diff --git a/drivers/flash/Kconfig.npcx_fiu b/drivers/flash/Kconfig.npcx_fiu
index e4ac74c9d..0569f51a2 100644
--- a/drivers/flash/Kconfig.npcx_fiu
+++ b/drivers/flash/Kconfig.npcx_fiu
@@ -7,6 +7,7 @@ config FLASH_NPCX_FIU_QSPI
 	bool "Nuvoton NPCX QSPI Bus Flash driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_FIU_QSPI_ENABLED
+	select PINCTRL
 	help
 	  This option enables the QSPI Bus Flash driver for NPCX family of
 	  processors.
diff --git a/drivers/i2c/Kconfig.npcx b/drivers/i2c/Kconfig.npcx
index c02f54440..2ac4880eb 100644
--- a/drivers/i2c/Kconfig.npcx
+++ b/drivers/i2c/Kconfig.npcx
@@ -7,6 +7,7 @@ config I2C_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) I2C driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_I2C_PORT_ENABLED
+	select PINCTRL
 	help
 	  This option enables the I2C driver for NPCX family of
 	  processors.
diff --git a/drivers/input/Kconfig.npcx b/drivers/input/Kconfig.npcx
index 07c2e3019..1c5a08a33 100644
--- a/drivers/input/Kconfig.npcx
+++ b/drivers/input/Kconfig.npcx
@@ -8,6 +8,7 @@ config INPUT_NPCX_KBD
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_KBD_ENABLED
 	select INPUT_KBD_MATRIX
+	select PINCTRL
 	help
 	  This option enables the keyboard scan driver for NPCX family of
 	  processors.
diff --git a/drivers/peci/Kconfig.npcx b/drivers/peci/Kconfig.npcx
index 4b1e01274..e79114c54 100644
--- a/drivers/peci/Kconfig.npcx
+++ b/drivers/peci/Kconfig.npcx
@@ -8,5 +8,6 @@ config PECI_NPCX
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_PECI_ENABLED
 	select PECI_INTERRUPT_DRIVEN
+	select PINCTRL
 	help
 	  Enable the NPCX PECI IO driver.
diff --git a/drivers/ps2/Kconfig.npcx b/drivers/ps2/Kconfig.npcx
index afbec76d9..5d8c515c9 100644
--- a/drivers/ps2/Kconfig.npcx
+++ b/drivers/ps2/Kconfig.npcx
@@ -6,6 +6,7 @@
 menuconfig PS2_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) PS2 driver"
 	depends on DT_HAS_NUVOTON_NPCX_PS2_CHANNEL_ENABLED
+	select PINCTRL
 	default y
 	help
 	  Enable the NPCX family PS2 driver. It provides four PS/2 channels.
diff --git a/drivers/pwm/Kconfig.npcx b/drivers/pwm/Kconfig.npcx
index e8869c2ef..2e8bdc9be 100644
--- a/drivers/pwm/Kconfig.npcx
+++ b/drivers/pwm/Kconfig.npcx
@@ -7,6 +7,7 @@ config PWM_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) PWM driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_PWM_ENABLED
+	select PINCTRL
 	help
 	  This option enables the PWM driver for NPCX family of
 	  processors.
diff --git a/drivers/serial/Kconfig.npcx b/drivers/serial/Kconfig.npcx
index 6284ed3a3..78f4dd16e 100644
--- a/drivers/serial/Kconfig.npcx
+++ b/drivers/serial/Kconfig.npcx
@@ -11,6 +11,7 @@ config UART_NPCX
 	depends on DT_HAS_NUVOTON_NPCX_UART_ENABLED
 	select SERIAL_HAS_DRIVER
 	select SERIAL_SUPPORT_INTERRUPT
+	select PINCTRL
 	help
 	  This option enables the UART driver for NPCX family of
 	  processors.
diff --git a/drivers/spi/Kconfig.npcx b/drivers/spi/Kconfig.npcx
index 196e85cf0..1c04bab44 100644
--- a/drivers/spi/Kconfig.npcx
+++ b/drivers/spi/Kconfig.npcx
@@ -7,6 +7,7 @@ menuconfig SPI_NPCX_SPIP
 	bool "Nuvoton NPCX embedded controller (EC) SPI driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_SPIP_ENABLED
+	select PINCTRL
 	help
 	  Enable the SPI peripherals on NPCX MCU.
 
diff --git a/subsys/mgmt/ec_host_cmd/backends/Kconfig b/subsys/mgmt/ec_host_cmd/backends/Kconfig
index de9ec9205..396e3146f 100644
--- a/subsys/mgmt/ec_host_cmd/backends/Kconfig
+++ b/subsys/mgmt/ec_host_cmd/backends/Kconfig
@@ -55,6 +55,7 @@ config EC_HOST_CMD_BACKEND_SHI_NPCX
 	bool "SHI by Nuvoton"
 	depends on DT_HAS_NUVOTON_NPCX_SHI_ENABLED || \
 		   DT_HAS_NUVOTON_NPCX_SHI_ENHANCED_ENABLED
+	select PINCTRL
 	help
 	  This option enables the driver for SHI backend in the
 	  Nuvoton NPCX chip.
-- 
2.17.1


From 07941634e605ca1b97f9b3d09111c67ce5d435e6 Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Wed, 17 Apr 2024 10:28:16 +0800
Subject: [PATCH 39/42] drivers: clock_control: npcx: add MCLKD as i3c source
 clock

1. The only valid values of MCLKD clock frequency
   are between 40Mhz to 50Mhz.
2. If DMA is used, the APB4_CLK clock frequency must
   be equal to or higher than 20Mhz.

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/clock_control/clock_control_npcx.c    | 11 +++++++++++
 include/zephyr/dt-bindings/clock/npcx_clock.h |  4 +++-
 soc/arm/nuvoton_npcx/common/soc_clock.h       | 12 ++++++++++++
 3 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/drivers/clock_control/clock_control_npcx.c b/drivers/clock_control/clock_control_npcx.c
index dcc4a925c..eec3604aa 100644
--- a/drivers/clock_control/clock_control_npcx.c
+++ b/drivers/clock_control/clock_control_npcx.c
@@ -105,6 +105,9 @@ static int npcx_clock_control_get_subsys_rate(const struct device *dev,
 	case NPCX_CLOCK_BUS_FMCLK:
 		*rate = FMCLK;
 		break;
+	case NPCX_CLOCK_BUS_MCLKD:
+		*rate = OFMCLK/(MCLKD_SL + 1);
+		break;
 	default:
 		*rate = 0U;
 		/* Invalid parameters */
@@ -185,6 +188,13 @@ BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) <= MAX_OFMCLK &&
 	     (APB4DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB4_CLK setting");
 #endif
+#if defined(CONFIG_I3C_NPCX)
+BUILD_ASSERT(OFMCLK / (MCLKD_SL + 1) <= MHZ(50) &&
+	     OFMCLK / (MCLKD_SL + 1) >= MHZ(40),
+	     "Invalid MCLKD_SL setting");
+BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) >= MHZ(20),
+	     "Invalid PDMA CLK setting");
+#endif
 
 static int npcx_clock_control_init(const struct device *dev)
 {
@@ -222,6 +232,7 @@ static int npcx_clock_control_init(const struct device *dev)
 	inst_cdcg->HFCBCD  = VAL_HFCBCD;
 	inst_cdcg->HFCBCD1 = VAL_HFCBCD1;
 	inst_cdcg->HFCBCD2 = VAL_HFCBCD2;
+	inst_cdcg->HFCBCD3 = VAL_HFCBCD3;
 
 	/*
 	 * Power-down (turn off clock) the modules initially for better
diff --git a/include/zephyr/dt-bindings/clock/npcx_clock.h b/include/zephyr/dt-bindings/clock/npcx_clock.h
index 713a05c57..d522478d2 100644
--- a/include/zephyr/dt-bindings/clock/npcx_clock.h
+++ b/include/zephyr/dt-bindings/clock/npcx_clock.h
@@ -20,6 +20,7 @@
 #define NPCX_CLOCK_BUS_FMCLK       10
 #define NPCX_CLOCK_BUS_FIU0        NPCX_CLOCK_BUS_FIU
 #define NPCX_CLOCK_BUS_FIU1        11
+#define NPCX_CLOCK_BUS_MCLKD       12
 
 /* clock enable/disable references */
 #define NPCX_PWDWN_CTL1            0
@@ -30,6 +31,7 @@
 #define NPCX_PWDWN_CTL6            5
 #define NPCX_PWDWN_CTL7            6
 #define NPCX_PWDWN_CTL8            7
-#define NPCX_PWDWN_CTL_COUNT       8
+#define NPCX_PWDWN_CTL9            8
+#define NPCX_PWDWN_CTL_COUNT       9
 
 #endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCX_CLOCK_H_ */
diff --git a/soc/arm/nuvoton_npcx/common/soc_clock.h b/soc/arm/nuvoton_npcx/common/soc_clock.h
index d43a70d45..4ec4c591b 100644
--- a/soc/arm/nuvoton_npcx/common/soc_clock.h
+++ b/soc/arm/nuvoton_npcx/common/soc_clock.h
@@ -105,6 +105,16 @@ struct npcx_clk_cfg {
 #endif
 #endif /* CONFIG_CLOCK_CONTROL_NPCX_SUPP_FIU1 */
 
+/* I3C clock divider */
+#if (OFMCLK == MHZ(120)) /* MCLkD must between 40 mhz to 50 mhz*/
+#define MCLKD_SL 2    /* I3C_CLK = (MCLK / 3) */
+#elif (OFMCLK <= MHZ(100) && OFMCLK >= MHZ(80))
+#define MCLKD_SL 1    /* I3C_CLK = (MCLK / 2) */
+#else
+#define MCLKD_SL 0    /* I3C_CLK = MCLK */
+#endif
+
+
 /* Get APB clock freq */
 #define NPCX_APB_CLOCK(no) (APBSRC_CLK / (APB##no##DIV_VAL + 1))
 
@@ -158,6 +168,8 @@ struct npcx_clk_cfg {
 #else
 #define VAL_HFCBCD2 APB3DIV_VAL
 #endif /* APB4DIV_VAL */
+/* I3C1~I3C3 share the same configuration */
+#define VAL_HFCBCD3 MCLKD_SL
 
 /**
  * @brief Function to notify clock driver that backup the counter value of
-- 
2.17.1


From 56b54981dfe223167b1b4e293efd3834a6e88c9a Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Mon, 22 Apr 2024 14:24:44 +0800
Subject: [PATCH 40/42] drivers: i3c: npcx: introduce NPCX I3C driver

This implements basic driver to utilize the I3C IP block
on NPCX.

1. I3C mode: Main controller mode only.
2. Transfer: Support SDR only.
3. IBI: Support Hot-Join, IBI(MDB).
   Controller request is not supported.
4. Support 3 I3C modules:
   I3C1(3.3V), I3C2(1.8V, espi mode), (I3C3 1.8V or 3.3V)

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/i3c/CMakeLists.txt                |    5 +
 drivers/i3c/Kconfig                       |    1 +
 drivers/i3c/Kconfig.npcx                  |   35 +
 drivers/i3c/i3c_npcx.c                    | 2052 +++++++++++++++++++++
 dts/arm/nuvoton/npcx/npcx4.dtsi           |    2 +-
 dts/bindings/i3c/nuvoton,npcx-i3c.yaml    |   52 +
 soc/arm/nuvoton_npcx/common/reg/reg_def.h |  224 ++-
 soc/arm/nuvoton_npcx/common/registers.c   |   27 +
 soc/arm/nuvoton_npcx/common/soc_dt.h      |   14 +
 9 files changed, 2410 insertions(+), 2 deletions(-)
 create mode 100644 drivers/i3c/Kconfig.npcx
 create mode 100644 drivers/i3c/i3c_npcx.c
 create mode 100644 dts/bindings/i3c/nuvoton,npcx-i3c.yaml

diff --git a/drivers/i3c/CMakeLists.txt b/drivers/i3c/CMakeLists.txt
index 71a7dc6eb..252b81669 100644
--- a/drivers/i3c/CMakeLists.txt
+++ b/drivers/i3c/CMakeLists.txt
@@ -31,6 +31,11 @@ zephyr_library_sources_ifdef(
   i3c_cdns.c
 )
 
+zephyr_library_sources_ifdef(
+  CONFIG_I3C_NPCX
+  i3c_npcx.c
+)
+
 zephyr_library_sources_ifdef(
   CONFIG_I3C_TEST
   i3c_test.c
diff --git a/drivers/i3c/Kconfig b/drivers/i3c/Kconfig
index 2b524c2bf..9d6b89141 100644
--- a/drivers/i3c/Kconfig
+++ b/drivers/i3c/Kconfig
@@ -100,6 +100,7 @@ comment "Device Drivers"
 
 rsource "Kconfig.nxp"
 rsource "Kconfig.cdns"
+rsource "Kconfig.npcx"
 rsource "Kconfig.test"
 
 endif # I3C
diff --git a/drivers/i3c/Kconfig.npcx b/drivers/i3c/Kconfig.npcx
new file mode 100644
index 000000000..b3b317a6f
--- /dev/null
+++ b/drivers/i3c/Kconfig.npcx
@@ -0,0 +1,35 @@
+# NPCX I3C driver configuration options
+
+# Copyright (c) 2024 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+DT_I3C_NPCX := $(dt_nodelabel_path,i3c0)
+
+config I3C_NPCX
+	bool "Nuvoton NPCX embedded controller (EC) I3C driver"
+	depends on DT_HAS_NUVOTON_NPCX_I3C_ENABLED
+	select RESET
+	select I3C_IBI_WORKQUEUE if I3C_USE_IBI
+	default y
+	help
+	  This option enables the I3C driver for NPCX family of
+	  processors.
+	  Say y if you wish to use I3C channels on NPCX MCU.
+
+# Expose this option when the 'reg' property includes the MDMA base address
+# as the second group in the phandle-array.
+# i.e. I3C node example in dtsi file.
+# i3c0: i3c@400f0000 {
+#	....
+#	/* reg[0]: I3C_1 register, reg[1]: MDMA5 register */
+#	reg-names = "i3c1", "mdma5";
+#	reg = <0x400f0000 0x2000>,
+#	      <0x40011500 0x100>;
+#  	....
+# }
+config I3C_NPCX_DMA
+	bool "Nuvoton NPCX embedded controller (EC) serial driver DMA support"
+	depends on I3C_NPCX && "$(dt_node_reg_addr_hex,$(DT_I3C_NPCX),1)" != 0
+	default y
+	help
+	  Enable support for npcx I3C DMA mode.
diff --git a/drivers/i3c/i3c_npcx.c b/drivers/i3c/i3c_npcx.c
new file mode 100644
index 000000000..9790e5939
--- /dev/null
+++ b/drivers/i3c/i3c_npcx.c
@@ -0,0 +1,2052 @@
+/*
+ * Copyright (c) 2024 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+/*132*/
+#define DT_DRV_COMPAT nuvoton_npcx_i3c
+
+#include <string.h>
+
+#include <zephyr/device.h>
+#include <zephyr/irq.h>
+#include <zephyr/sys/__assert.h>
+#include <zephyr/sys/sys_io.h>
+
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/i3c.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/drivers/reset.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(npcx_i3c, CONFIG_I3C_LOG_LEVEL);
+
+#define NPCX_I3C_CHK_TIMEOUT_US 10000 /* Timeout for checking register status */
+#define I3C_SCL_PP_FREQ_MAX_MHZ 12500000
+#define I3C_SCL_OD_FREQ_MAX_MHZ 4170000
+
+#define I3C_BUS_TLOW_PP_MIN_NS  24  /* T_LOW period in push-pull mode */
+#define I3C_BUS_THigh_PP_MIN_NS 24  /* T_High period in push-pull mode */
+#define I3C_BUS_TLOW_OD_MIN_NS  200 /* T_LOW period in open-drain mode */
+
+#define PPBAUD_DIV_MAX (BIT(GET_FIELD_SZ(NPCX_I3C_MCONFIG_PPBAUD)) - 1) /* PPBAUD divider max */
+
+#define DAA_TGT_INFO_SZ 0x8 /* 8 bytes = PID(6) + BCR(1) + DCR(1) */
+#define BAMATCH_DIV     0x4 /* BAMATCH = APB4_CLK divided by four */
+
+/* Default maximum time we allow for an I3C transfer */
+#define I3C_TRANS_TIMEOUT_MS K_MSEC(100)
+
+#define MCLKD_FREQ_45_MHZ MHZ(45)
+
+#define I3C_STATUS_CLR_MASK                                                 \
+	(BIT(NPCX_I3C_MSTATUS_TGTSTART) | BIT(NPCX_I3C_MSTATUS_MCTRLDONE) | \
+	 BIT(NPCX_I3C_MSTATUS_COMPLETE) | BIT(NPCX_I3C_MSTATUS_IBIWON) |    \
+	 BIT(NPCX_I3C_MSTATUS_NOWCNTLR))
+
+/* Supported I3C MCLKD frequency */
+enum npcx_i3c_speed {
+	NPCX_I3C_BUS_SPEED_45MHZ,
+};
+
+/* Operation type */
+enum npcx_i3c_oper_state {
+	NPCX_I3C_IDLE,
+	NPCX_I3C_WR,
+	NPCX_I3C_RD,
+};
+
+/* I3C timing configuration for each i3c speed */
+struct npcx_i3c_timing_cfg {
+	uint8_t ppbaud; /* Push-Pull high period */
+	uint8_t pplow;  /* Push-Pull low period */
+	uint8_t odhpp;  /* Open-Drain high period */
+	uint8_t odbaud; /* Open-Drain low period */
+};
+
+/* Recommended I3C timing values are based on MCLKD 45 MHz */
+static const struct npcx_i3c_timing_cfg npcx_def_speed_cfg[] = {
+	/* PP = 12.5 mhz, OD = 4.17 Mhz */
+	[NPCX_I3C_BUS_SPEED_45MHZ] = {.ppbaud = 1, .pplow = 0, .odhpp = 1, .odbaud = 4},
+};
+
+struct npcx_i3c_config {
+	/* Common I3C Driver Config */
+	struct i3c_driver_config common;
+
+	/* Pointer to controller registers. */
+	struct i3c_reg *base;
+
+	/* Pointer to the clock device. */
+	const struct device *clock_dev;
+
+	/* Reset controller */
+	struct reset_dt_spec reset;
+
+	/* Clock control subsys related struct. */
+	struct npcx_clk_cfg clock_subsys;
+
+	/* Reference clock to determine 1 s bus available time */
+	struct npcx_clk_cfg ref_clk_subsys;
+
+	/* Pointer to pin control device. */
+	const struct pinctrl_dev_config *pincfg;
+
+	/* Interrupt configuration function. */
+	void (*irq_config_func)(const struct device *dev);
+
+	struct {
+		uint32_t i3c_pp_scl_hz; /* I3C push pull clock frequency in Hz. */
+		uint32_t i3c_od_scl_hz; /* I3C open drain clock frequency in Hz. */
+	} clocks;
+
+#ifdef CONFIG_I3C_NPCX_DMA
+	struct npcx_clk_cfg mdma_clk_subsys;
+	struct mdma_reg *mdma_base;
+#endif
+};
+
+struct npcx_i3c_data {
+	struct i3c_driver_data common;       /* Common i3c driver data */
+	struct k_mutex lock_mutex;           /* Mutex of i3c controller */
+	struct k_sem sync_sem;               /* Semaphore used for synchronization */
+	struct k_sem ibi_lock_sem;           /* Semaphore used for ibi */
+	enum npcx_i3c_oper_state oper_state; /* controller operation state */
+
+#ifdef CONFIG_I3C_USE_IBI
+	struct {
+		/* List of addresses used in the MIBIRULES register. */
+		uint8_t addr[5];
+
+		/* Number of valid addresses in MIBIRULES. */
+		uint8_t num_addr;
+
+		/* True if all addresses have MSB set. */
+		bool msb;
+
+		/*
+		 * True if all target devices require mandatory byte
+		 * for IBI.
+		 */
+		bool has_mandatory_byte;
+	} ibi;
+#endif
+};
+
+static void npcx_i3c_mutex_lock(const struct device *dev)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	k_mutex_lock(&data->lock_mutex, K_FOREVER);
+}
+
+static void npcx_i3c_mutex_unlock(const struct device *dev)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	k_mutex_unlock(&data->lock_mutex);
+}
+
+#ifdef CONFIG_I3C_NPCX_DMA
+static void i3c_ctrl_notify(const struct device *dev)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	k_sem_give(&data->sync_sem);
+}
+
+static int i3c_ctrl_wait_completion(const struct device *dev)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	return k_sem_take(&data->sync_sem, I3C_TRANS_TIMEOUT_MS);
+}
+
+static enum npcx_i3c_oper_state get_oper_state(const struct device *dev)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	return data->oper_state;
+}
+#endif /* CONFIG_I3C_NPCX_DMA */
+
+static void set_oper_state(const struct device *dev, enum npcx_i3c_oper_state state)
+{
+	struct npcx_i3c_data *const data = dev->data;
+
+	data->oper_state = state;
+}
+
+/*
+ * brief:  Wait for status bit done and clear the status
+ *
+ * param[in] inst  Pointer to I3C register.
+ *
+ * return  0, success
+ *         -ETIMEDOUT: check status timeout.
+ */
+static inline int npcx_i3c_status_wait_clear(struct i3c_reg *inst, uint8_t bit_offset)
+{
+	if (WAIT_FOR(IS_BIT_SET(inst->MSTATUS, bit_offset), NPCX_I3C_CHK_TIMEOUT_US, NULL) ==
+	    false) {
+		return -ETIMEDOUT;
+	}
+
+	inst->MSTATUS = BIT(bit_offset); /* W1C */
+
+	return 0;
+}
+
+static inline uint32_t npcx_i3c_state_get(struct i3c_reg *inst)
+{
+	return GET_FIELD(inst->MSTATUS, NPCX_I3C_MSTATUS_STATE);
+}
+
+static inline void npcx_i3c_interrupt_all_disable(struct i3c_reg *inst)
+{
+	uint32_t intmask = inst->MINTSET;
+
+	inst->MINTCLR = intmask;
+}
+
+static inline void npcx_i3c_interrupt_enable(struct i3c_reg *inst, uint32_t mask)
+{
+	inst->MINTSET = mask;
+}
+
+static bool npcx_i3c_has_error(struct i3c_reg *inst)
+{
+	if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_ERRWARN)) {
+		LOG_WRN("ERROR: MSTATUS 0x%08x MERRWARN 0x%08x", inst->MSTATUS, inst->MERRWARN);
+
+		return true;
+	}
+
+	return false;
+}
+
+static inline void npcx_i3c_status_clear_all(struct i3c_reg *inst)
+{
+	uint32_t mask = I3C_STATUS_CLR_MASK;
+
+	inst->MSTATUS = mask;
+}
+
+static inline void npcx_i3c_errwarn_clear_all(struct i3c_reg *inst)
+{
+	inst->MERRWARN = inst->MERRWARN;
+}
+
+static inline void npcx_i3c_fifo_flush(struct i3c_reg *inst)
+{
+	inst->MDATACTRL |= (BIT(NPCX_I3C_MDATACTRL_FLUSHTB) | BIT(NPCX_I3C_MDATACTRL_FLUSHFB));
+}
+
+/*
+ * brief:  Send request and check the request is valid
+ *
+ * param[in] inst  Pointer to I3C register.
+ *
+ * return  0, success
+ *         -ETIMEDOUT check MCTRLDONE timeout.
+ *         -ENOSYS    invalid use of request.
+ */
+static inline int npcx_i3c_send_request(struct i3c_reg *inst, uint32_t mctrl_val)
+{
+	inst->MCTRL = mctrl_val;
+
+	if (npcx_i3c_status_wait_clear(inst, NPCX_I3C_MSTATUS_MCTRLDONE) != 0) {
+		return -ETIMEDOUT;
+	}
+
+	/* Check invalid use of request */
+	if (IS_BIT_SET(inst->MERRWARN, NPCX_I3C_MERRWARN_INVERQ)) {
+		LOG_ERR("%s: Invalid request, merrwarn: %#x", __func__, inst->MERRWARN);
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/* Start DAA procedure and continue the DAA with a Repeated START */
+static inline int npcx_i3c_request_daa(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	int ret;
+
+	/* Set IBI response NACK while processing DAA */
+	SET_FIELD(val, NPCX_I3C_MCTRL_IBIRESP, MCTRL_IBIRESP_NACK);
+
+	/* Send DAA request */
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_PROCESSDAA);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request DAA error, %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/* Tell controller to start auto IBI */
+static inline int npcx_i3c_request_auto_ibi(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	int ret;
+
+	SET_FIELD(val, NPCX_I3C_MCTRL_IBIRESP, MCTRL_IBIRESP_ACK);
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_AUTOIBI);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request auto ibi error, %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * brief:  Controller emit start and send address
+ *
+ * param[in] inst     Pointer to I3C register.
+ * param[in] addr     Dyamic address for xfer or 0x7E for CCC command.
+ * param[in] op_type  Request type.
+ * param[in] is_read  Read(true) or write(false) operation.
+ * param[in] read_sz  Read size.
+ *
+ * return  0, success
+ *         else, error
+ */
+static int npcx_i3c_request_emit_start(struct i3c_reg *inst, uint8_t addr,
+				       enum npcx_i3c_mctrl_type op_type, bool is_read,
+				       size_t read_sz)
+{
+	uint32_t mctrl = 0;
+	int ret;
+
+	/* Set request and target address*/
+	SET_FIELD(mctrl, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_EMITSTARTADDR);
+
+	/* Set operation type */
+	SET_FIELD(mctrl, NPCX_I3C_MCTRL_TYPE, op_type);
+
+	/* Set IBI response NACK in emit start */
+	SET_FIELD(mctrl, NPCX_I3C_MCTRL_IBIRESP, MCTRL_IBIRESP_NACK);
+
+	/* Set dynamic address */
+	SET_FIELD(mctrl, NPCX_I3C_MCTRL_ADDR, addr);
+
+	/* Set read(1) or write(0) */
+	if (is_read) {
+		mctrl |= BIT(NPCX_I3C_MCTRL_DIR);
+		SET_FIELD(mctrl, NPCX_I3C_MCTRL_RDTERM, read_sz); /* Set read length */
+	} else {
+		mctrl &= ~BIT(NPCX_I3C_MCTRL_DIR);
+	}
+
+	ret = npcx_i3c_send_request(inst, mctrl);
+	if (ret != 0) {
+		LOG_ERR("Request start error, %d", ret);
+		return ret;
+	}
+
+	/* Check NACK after MCTRLDONE is get */
+	if (IS_BIT_SET(inst->MERRWARN, NPCX_I3C_MERRWARN_NACK)) {
+		LOG_DBG("%s: nack", __func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*
+ * brief:  Controller emit STOP.
+ *
+ * This emits STOP when controller is in NORMACT state.
+ *
+ * param[in] inst  Pointer to I3C register.
+ *
+ * return  0 success
+ *         -ECANCELED i3c state not as expected.
+ *         -ETIMEDOUT check MCTRLDONE timeout.
+ *         -ENOSYS    invalid use of request.
+ */
+static inline int npcx_i3c_request_emit_stop(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	int ret;
+	uint32_t i3c_state = npcx_i3c_state_get(inst);
+
+	/* Make sure we are in a state where we can emit STOP */
+	if ((i3c_state != MSTATUS_STATE_NORMACT) && (i3c_state != MSTATUS_STATE_DAA)) {
+		LOG_ERR("Request stop state error, state= %#x", i3c_state);
+		return -ECANCELED;
+	}
+
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_EMITSTOP);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request stop error, %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int npcx_i3c_ibi_respond_nack(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	int ret;
+
+	SET_FIELD(val, NPCX_I3C_MCTRL_IBIRESP, MCTRL_IBIRESP_NACK);
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_IBIACKNACK);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request ibi_rsp nack error, %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int npcx_i3c_ibi_respond_ack(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	int ret;
+
+	SET_FIELD(val, NPCX_I3C_MCTRL_IBIRESP, MCTRL_IBIRESP_ACK);
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_IBIACKNACK);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request ibi_rsp ack error %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * brief:  Find a registered I3C target device.
+ *
+ * This returns the I3C device descriptor of the I3C device
+ * matching the incoming id.
+ *
+ * param[in] dev  Pointer to controller device driver instance.
+ * param[in] id   Pointer to I3C device ID.
+ *
+ * return  see i3c_device_find.
+ */
+static inline struct i3c_device_desc *npcx_i3c_device_find(const struct device *dev,
+							   const struct i3c_device_id *id)
+{
+	const struct npcx_i3c_config *config = dev->config;
+
+	return i3c_dev_list_find(&config->common.dev_list, id);
+}
+
+/*
+ * brief:  Perform bus recovery.
+ *
+ * param[in] dev  Pointer to controller device driver instance.
+ *
+ * return 0 success, otherwise error
+ */
+static int npcx_i3c_recover_bus(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *inst = config->base;
+
+	/*
+	 * If the controller is in NORMACT state, tells it to emit STOP
+	 * so it can return to IDLE, or is ready to clear any pending
+	 * target initiated IBIs.
+	 */
+	if (npcx_i3c_state_get(inst) == MSTATUS_STATE_NORMACT) {
+		npcx_i3c_request_emit_stop(inst);
+	};
+
+	/* Exhaust all target initiated IBI */
+	while (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_TGTSTART)) {
+		/* Tell the controller to perform auto IBI. */
+		npcx_i3c_request_auto_ibi(inst);
+
+		if (WAIT_FOR(IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE),
+			     NPCX_I3C_CHK_TIMEOUT_US, NULL) == false) {
+			break;
+		}
+
+		/* Once auto IBI is done, discard bytes in FIFO. */
+		while (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_RXPEND)) {
+			/* Flush FIFO as long as RXPEND is set. */
+			npcx_i3c_fifo_flush(inst);
+		}
+
+		/*
+		 * There might be other IBIs waiting.
+		 * So pause a bit to let other targets initiates
+		 * their IBIs.
+		 */
+		k_busy_wait(100);
+	}
+
+	/* Check IDLE state */
+	if (WAIT_FOR((npcx_i3c_state_get(inst) == MSTATUS_STATE_IDLE), NPCX_I3C_CHK_TIMEOUT_US,
+		     NULL) == false) {
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static inline void npcx_i3c_xfer_reset(struct i3c_reg *inst)
+{
+	npcx_i3c_status_clear_all(inst);
+	npcx_i3c_errwarn_clear_all(inst);
+	npcx_i3c_fifo_flush(inst);
+}
+
+/*
+ * brief:  Perform one write transaction.
+ *
+ * This writes all data in buf to TX FIFO or time out
+ * waiting for FIFO spaces.
+ *
+ * param[in] inst       Pointer to controller registers.
+ * param[in] buf        Buffer containing data to be sent.
+ * param[in] buf_sz     Number of bytes in buf to send.
+ * param[in] no_ending  True, not including ending byte in message.
+ *                       False, including ending byte in message
+ *
+ * return  Number of bytes written, or negative if error.
+ *
+ */
+static int npcx_i3c_xfer_write_fifo(struct i3c_reg *inst, uint8_t *buf, uint8_t buf_sz,
+				    bool no_ending)
+{
+	int offset = 0;
+	int remaining = buf_sz;
+
+	while (remaining > 0) {
+		/* Check tx fifo not full */
+		if (WAIT_FOR(!IS_BIT_SET(inst->MDATACTRL, NPCX_I3C_MDATACTRL_TXFULL),
+			     NPCX_I3C_CHK_TIMEOUT_US, NULL) == false) {
+			LOG_DBG("%s: Check tx fifo not full timed out", __func__);
+			return -ETIMEDOUT;
+		}
+
+		if ((remaining > 1) || no_ending) {
+			inst->MWDATAB = (uint32_t)buf[offset];
+		} else {
+			inst->MWDATABE = (uint32_t)buf[offset]; /* Set last byte */
+		}
+
+		offset += 1;
+		remaining -= 1;
+	}
+
+	return offset;
+}
+
+/*
+ * brief:  Perform read transaction.
+ *
+ * This reads from RX FIFO until COMPLETE bit is set in MSTATUS
+ * or time out.
+ *
+ * param[in] inst    Pointer to controller registers.
+ * param[in] buf     Buffer to store data.
+ * param[in] buf_sz  Number of bytes to read.
+ *
+ * return  Number of bytes read, or negative if error.
+ *
+ */
+static int npcx_i3c_xfer_read_fifo(struct i3c_reg *inst, uint8_t *buf, uint8_t rd_sz)
+{
+	bool is_done = false;
+	int offset = 0;
+
+	while (is_done == false) {
+		/* Check message is terminated */
+		if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE)) {
+			is_done = true;
+		}
+
+		/* Check I3C bus error */
+		if (npcx_i3c_has_error(inst)) {
+			/* Check timeout*/
+			if (IS_BIT_SET(inst->MERRWARN, NPCX_I3C_MERRWARN_TIMEOUT)) {
+				LOG_WRN("%s: ERR: timeout", __func__);
+			}
+
+			inst->MERRWARN = inst->MERRWARN;
+
+			return -EIO;
+		}
+
+		/* Check rx not empty */
+		if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_RXPEND)) {
+
+			/* Receive all the data in this round.
+			 * Read in a tight loop to reduce chance of losing
+			 * FIFO data when the i3c speed is high.
+			 */
+			while (offset < rd_sz) {
+				if (GET_FIELD(inst->MDATACTRL, NPCX_I3C_MDATACTRL_RXCOUNT) == 0) {
+					break;
+				}
+
+				buf[offset++] = (uint8_t)inst->MRDATAB;
+			}
+		}
+	}
+
+	return offset;
+}
+
+#ifdef CONFIG_I3C_NPCX_DMA
+/*
+ * brief:  Perform DMA write transaction.
+ *
+ * For write end, use the interrupt generated by COMPLETE bit in MSTATUS register.
+ *
+ * param[in] dev     Pointer to controller device driver instance.
+ * param[in] buf     Buffer to store data.
+ * param[in] buf_sz  Number of bytes to read.
+ *
+ * return  Number of bytes read, or negative if error.
+ *
+ */
+static int npcx_i3c_xfer_write_fifo_dma(const struct device *dev, uint8_t *buf, uint8_t buf_sz)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *i3c_inst = config->base;
+	struct mdma_reg *mdma_inst = config->mdma_base;
+	int ret;
+
+	set_oper_state(dev, NPCX_I3C_WR);
+
+	/* Enable I3C MDMA write for one frame */
+	SET_FIELD(i3c_inst->MDMACTRL, NPCX_I3C_MDMACTRL_DMATB, MDMA_DMATB_EN_ONE_FRAME);
+	i3c_inst->MINTSET |= BIT(NPCX_I3C_MINTCLR_COMPLETE); /* Enable I3C complete interrupt */
+
+	/* Write Operation (MDMA CH_1) */
+	mdma_inst->MDMA_TCNT1 = buf_sz;                    /* Set MDMA transfer count */
+	mdma_inst->MDMA_SRCB1 = (uint32_t)buf;             /* Set source address */
+	mdma_inst->MDMA_CTL1 |= BIT(NPCX_MDMA_CTL_MDMAEN); /* Start DMA transfer */
+
+	/* Wait I3C COMPLETE */
+	ret = i3c_ctrl_wait_completion(dev);
+	if (ret < 0) {
+		LOG_DBG("%s: Check complete time out, buf_size:%d", __func__, buf_sz);
+		goto out_wr_fifo_dma;
+	}
+
+	/* Check and clear DMA TC after complete */
+	if (!IS_BIT_SET(mdma_inst->MDMA_CTL1, NPCX_MDMA_CTL_TC)) {
+		LOG_DBG("%s: DMA busy, TC=%d", __func__,
+			IS_BIT_SET(mdma_inst->MDMA_CTL1, NPCX_MDMA_CTL_TC));
+		ret = -EBUSY;
+		goto out_wr_fifo_dma;
+	}
+
+	mdma_inst->MDMA_CTL1 &= ~BIT(NPCX_MDMA_CTL_TC); /* Clear TC, W0C */
+	ret = buf_sz - mdma_inst->MDMA_CTCNT1;          /* Set transferred count */
+	LOG_DBG("Write cnt=%d", ret);
+
+out_wr_fifo_dma:
+	i3c_inst->MINTCLR |= BIT(NPCX_I3C_MINTCLR_COMPLETE); /* Disable I3C complete interrupt */
+	npcx_i3c_fifo_flush(i3c_inst);
+	set_oper_state(dev, NPCX_I3C_IDLE);
+
+	return ret;
+}
+
+/*
+ * brief:  Perform DMA read transaction.
+ *
+ * For read end, use the MDMA end-of-transfer interrupt(SIEN bit)
+ * instead of using the I3CI interrupt generated by COMPLETE bit in MSTATUS register.
+ *
+ * param[in] dev     Pointer to controller device driver instance.
+ * param[in] buf     Buffer to store data.
+ * param[in] buf_sz  Number of bytes to read.
+ *
+ * return  Number of bytes read, or negative if error.
+ *
+ */
+static int npcx_i3c_xfer_read_fifo_dma(const struct device *dev, uint8_t *buf, uint8_t buf_sz)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *i3c_inst = config->base;
+	struct mdma_reg *mdma_inst = config->mdma_base;
+	int ret;
+
+	set_oper_state(dev, NPCX_I3C_RD);
+
+	/* Enable DMA until DMA is disabled by setting DMAFB to 00 */
+	SET_FIELD(i3c_inst->MDMACTRL, NPCX_I3C_MDMACTRL_DMAFB, MDMA_DMAFB_EN_MANUAL);
+
+	/* Read Operation (MDMA CH_0) */
+	mdma_inst->MDMA_TCNT0 = buf_sz;                    /* Set MDMA transfer count */
+	mdma_inst->MDMA_DSTB0 = (uint32_t)buf;             /* Set destination address */
+	mdma_inst->MDMA_CTL0 |= BIT(NPCX_MDMA_CTL_SIEN);   /* Enable stop interrupt */
+	mdma_inst->MDMA_CTL0 |= BIT(NPCX_MDMA_CTL_MDMAEN); /* Start DMA transfer */
+
+	/* Wait MDMA TC */
+	ret = i3c_ctrl_wait_completion(dev);
+	if (ret < 0) {
+		LOG_DBG("%s: Check DMA done time out", __func__);
+	} else {
+		ret = buf_sz - mdma_inst->MDMA_CTCNT0; /* Set transferred count */
+		LOG_DBG("Read cnt=%d", ret);
+	}
+
+	mdma_inst->MDMA_CTL0 &= ~BIT(NPCX_MDMA_CTL_SIEN); /* Disable stop interrupt */
+	/* Disable I3C MDMA read */
+	SET_FIELD(i3c_inst->MDMACTRL, NPCX_I3C_MDMACTRL_DMAFB, MDMA_DMAFB_DISABLE);
+	npcx_i3c_fifo_flush(i3c_inst);
+	set_oper_state(dev, NPCX_I3C_IDLE);
+
+	return ret;
+}
+
+/*
+ * brief:  Perform one transfer transaction by DMA.
+ *
+ * param[in] inst        Pointer to controller registers.
+ * param[in] addr        Target address.
+ * param[in] op_type     Request type.
+ * param[in] buf         Buffer for data to be sent or received.
+ * param[in] buf_sz      Buffer size in bytes.
+ * param[in] is_read     True if this is a read transaction, false if write.
+ * param[in] emit_start  True if START is needed before read/write.
+ * param[in] emit_stop   True if STOP is needed after read/write.
+ *
+ * return  Number of bytes read/written, or negative if error.
+ */
+static int npcx_i3c_do_one_xfer_dma(const struct device *dev, uint8_t addr,
+				    enum npcx_i3c_mctrl_type op_type, uint8_t *buf, size_t buf_sz,
+				    bool is_read, bool emit_start, bool emit_stop)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *inst = config->base;
+	int ret = 0;
+
+	npcx_i3c_status_clear_all(inst);
+	npcx_i3c_errwarn_clear_all(inst);
+
+	/* Emit START if needed */
+	if (emit_start) {
+		ret = npcx_i3c_request_emit_start(inst, addr, op_type, is_read, buf_sz);
+		if (ret != 0) {
+			LOG_ERR("%s: emit start fail", __func__);
+			goto out_do_one_xfer_dma;
+		}
+	}
+
+	/* No data to be transferred */
+	if ((buf == NULL) || (buf_sz == 0)) {
+		goto out_do_one_xfer_dma;
+	}
+
+	/* Select read or write operation */
+	if (is_read) {
+		ret = npcx_i3c_xfer_read_fifo_dma(dev, buf, buf_sz);
+	} else {
+		ret = npcx_i3c_xfer_write_fifo_dma(dev, buf, buf_sz);
+	}
+
+	if (ret < 0) {
+		LOG_ERR("%s: %s fifo fail", __func__, is_read ? "read" : "write");
+		goto out_do_one_xfer_dma;
+	}
+
+	/* Check I3C bus error */
+	if (npcx_i3c_has_error(inst)) {
+		ret = -EIO;
+		LOG_ERR("%s: I3C bus error", __func__);
+	}
+
+out_do_one_xfer_dma:
+	/* Emit STOP if needed */
+	if (emit_stop) {
+		npcx_i3c_request_emit_stop(inst);
+	}
+
+	return ret;
+}
+#endif /* End of CONFIG_I3C_NPCX_DMA */
+
+/*
+ * brief:  Perform one transfer transaction.
+ *
+ * param[in] inst        Pointer to controller registers.
+ * param[in] addr        Target address.
+ * param[in] op_type     Request type.
+ * param[in] buf         Buffer for data to be sent or received.
+ * param[in] buf_sz      Buffer size in bytes.
+ * param[in] is_read     True if this is a read transaction, false if write.
+ * param[in] emit_start  True if START is needed before read/write.
+ * param[in] emit_stop   True if STOP is needed after read/write.
+ * param[in] no_ending   True if not to signal end of write message.
+ *
+ * return  Number of bytes read/written, or negative if error.
+ */
+static int npcx_i3c_do_one_xfer(struct i3c_reg *inst, uint8_t addr,
+				enum npcx_i3c_mctrl_type op_type, uint8_t *buf, size_t buf_sz,
+				bool is_read, bool emit_start, bool emit_stop, bool no_ending)
+{
+	int ret = 0;
+
+	npcx_i3c_status_clear_all(inst);
+	npcx_i3c_errwarn_clear_all(inst);
+
+	/* Emit START if needed */
+	if (emit_start) {
+		ret = npcx_i3c_request_emit_start(inst, addr, op_type, is_read, buf_sz);
+		if (ret != 0) {
+			LOG_ERR("%s: emit start fail", __func__);
+			goto out_do_one_xfer;
+		}
+	}
+
+	/* No data to be transferred */
+	if ((buf == NULL) || (buf_sz == 0)) {
+		goto out_do_one_xfer;
+	}
+
+	/* Select read or write operation */
+	if (is_read) {
+		ret = npcx_i3c_xfer_read_fifo(inst, buf, buf_sz);
+	} else {
+		ret = npcx_i3c_xfer_write_fifo(inst, buf, buf_sz, no_ending);
+	}
+
+	if (ret < 0) {
+		LOG_ERR("%s: %s fifo fail", __func__, is_read ? "read" : "write");
+		goto out_do_one_xfer;
+	}
+
+	/* Check message complete if is a read transaction or
+	 * ending byte of a write transaction.
+	 */
+	if (is_read || !no_ending) {
+		/* Wait message transfer complete */
+		if (WAIT_FOR(IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE),
+			     NPCX_I3C_CHK_TIMEOUT_US, NULL) == false) {
+			LOG_DBG("%s: timed out addr 0x%02x, buf_sz %u", __func__, addr, buf_sz);
+
+			ret = -ETIMEDOUT;
+			emit_stop = true;
+
+			goto out_do_one_xfer;
+		}
+
+		inst->MSTATUS = BIT(NPCX_I3C_MSTATUS_COMPLETE); /* W1C */
+	}
+
+	/* Check I3C bus error */
+	if (npcx_i3c_has_error(inst)) {
+		ret = -EIO;
+		LOG_ERR("%s: I3C bus error", __func__);
+	}
+
+out_do_one_xfer:
+	/* Emit STOP if needed */
+	if (emit_stop) {
+		npcx_i3c_request_emit_stop(inst);
+	}
+
+	return ret;
+}
+
+/*
+ * brief:  Transfer messages in I3C mode.
+ *
+ * see i3c_transfer
+ *
+ * param[in] dev       Pointer to device driver instance.
+ * param[in] target    Pointer to target device descriptor.
+ * param[in] msgs      Pointer to I3C messages.
+ * param[in] num_msgs  Number of messages to transfers.
+ *
+ * return  see i3c_transfer
+ */
+static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *target,
+			     struct i3c_msg *msgs, uint8_t num_msgs)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *inst = config->base;
+	uint32_t intmask;
+	int xfered_len, ret = 0;
+	bool send_broadcast = true;
+	bool is_xfer_done = true;
+
+	if (msgs == NULL) {
+		return -EINVAL;
+	}
+
+	if (target->dynamic_addr == 0U) {
+		return -EINVAL;
+	}
+
+	npcx_i3c_mutex_lock(dev);
+
+	/* Check bus in idle state */
+	if (WAIT_FOR((npcx_i3c_state_get(inst) == MSTATUS_STATE_IDLE), NPCX_I3C_CHK_TIMEOUT_US,
+		     NULL) == false) {
+		LOG_ERR("%s: xfer state error: %d", __func__, npcx_i3c_state_get(inst));
+		npcx_i3c_mutex_unlock(dev);
+		return -ETIMEDOUT;
+	}
+
+	/* Disable interrupt */
+	intmask = inst->MINTSET;
+	npcx_i3c_interrupt_all_disable(inst);
+
+	npcx_i3c_xfer_reset(inst);
+
+	/* Iterate over all the messages */
+	for (int i = 0; i < num_msgs; i++) {
+
+		/*
+		 * Check message is read or write operaion.
+		 * For write operation, check the last data byte of a transmit message.
+		 */
+		bool is_read = (msgs[i].flags & I3C_MSG_RW_MASK) == I3C_MSG_READ;
+		bool no_ending = false;
+
+		/*
+		 * Emit start if this is the first message or that
+		 * the RESTART flag is set in message.
+		 */
+		bool emit_start =
+			(i == 0) || ((msgs[i].flags & I3C_MSG_RESTART) == I3C_MSG_RESTART);
+
+		bool emit_stop = (msgs[i].flags & I3C_MSG_STOP) == I3C_MSG_STOP;
+
+		/*
+		 * The controller requires special treatment of last byte of
+		 * a write message. Since the API permits having a bunch of
+		 * write messages without RESTART in between, this is just some
+		 * logic to determine whether to treat the last byte of this
+		 * message to be the last byte of a series of write mssages.
+		 * If not, tell the write function not to treat it that way.
+		 */
+		if (!is_read && !emit_stop && ((i + 1) != num_msgs)) {
+			bool next_is_write = (msgs[i + 1].flags & I3C_MSG_RW_MASK) == I3C_MSG_WRITE;
+			bool next_is_restart =
+				((msgs[i + 1].flags & I3C_MSG_RESTART) == I3C_MSG_RESTART);
+
+			/* Check next msg is still write operation and not including Sr */
+			if (next_is_write && !next_is_restart) {
+				no_ending = true;
+			}
+		}
+
+#ifdef CONFIG_I3C_NPCX_DMA
+		/* Current DMA not support multi-message write */
+		if (!is_read && no_ending) {
+			LOG_ERR("I3C DMA transfer not support multi-message write");
+			ret = -EINVAL;
+			break;
+		}
+#endif
+
+		/*
+		 * Two ways to do read/write transfer .
+		 * 1. [S] + [0x7E]    + [address] + [data] + [Sr or P]
+		 * 2. [S] + [address] + [data]    + [Sr or P]
+		 *
+		 * Send broadcast header(0x7E) on first transfer or after a STOP,
+		 * unless flag is set not to.
+		 */
+		if (!(msgs[i].flags & I3C_MSG_NBCH) && (send_broadcast)) {
+			ret = npcx_i3c_request_emit_start(inst, I3C_BROADCAST_ADDR,
+							  NPCX_I3C_MCTRL_TYPE_I3C, false, 0);
+			if (ret < 0) {
+				LOG_ERR("%s: emit start of broadcast addr failed, error (%d)",
+					__func__, ret);
+				break;
+			}
+			send_broadcast = false;
+		}
+
+#ifdef CONFIG_I3C_NPCX_DMA
+		/* Do transfer with target device */
+		xfered_len = npcx_i3c_do_one_xfer_dma(dev, target->dynamic_addr,
+						      NPCX_I3C_MCTRL_TYPE_I3C, msgs[i].buf,
+						      msgs[i].len, is_read, emit_start, emit_stop);
+#else
+		xfered_len = npcx_i3c_do_one_xfer(inst, target->dynamic_addr,
+						  NPCX_I3C_MCTRL_TYPE_I3C, msgs[i].buf, msgs[i].len,
+						  is_read, emit_start, emit_stop, no_ending);
+#endif
+		if (xfered_len < 0) {
+			LOG_ERR("%s: do xfer fail", __func__);
+			ret = xfered_len; /* Set error code to ret */
+			break;
+		}
+
+		/* Write back the total number of bytes transferred */
+		msgs[i].num_xfer = xfered_len;
+
+		if (emit_stop) {
+			/* After a STOP, send broadcast header before next msg */
+			send_broadcast = true;
+		}
+
+		/* Check emit stop flag including in the final msg */
+		if ((i == num_msgs - 1) && (emit_stop == false)) {
+			is_xfer_done = false;
+		}
+	}
+
+	/* Emit stop if error occurs or stop flag not in the msg */
+	if ((ret != 0) || (is_xfer_done == false)) {
+		npcx_i3c_request_emit_stop(inst);
+	}
+
+	npcx_i3c_errwarn_clear_all(inst);
+	npcx_i3c_status_clear_all(inst);
+
+	npcx_i3c_interrupt_enable(inst, intmask);
+
+	npcx_i3c_mutex_unlock(dev);
+
+	return ret;
+}
+
+/*
+ * brief:  Perform Dynamic Address Assignment.
+ *
+ * param[in] dev  Pointer to controller device driver instance.
+ *
+ * return  0 If successful.
+ *         -EBUSY Bus is busy.
+ *         -EIO General input / output error.
+ *         -ENODEV If a provisioned ID does not match to any target devices
+ *                 in the registered device list.
+ *         -ENOSPC No more free addresses can be assigned to target.
+ *         -ENOSYS Dynamic address assignment is not supported by
+ *                 the controller driver.
+ */
+static int npcx_i3c_do_daa(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_reg *inst = config->base;
+	int ret = 0;
+	uint8_t rx_buf[8];
+	size_t rx_count;
+	uint32_t intmask;
+
+	npcx_i3c_mutex_lock(dev);
+
+	memset(rx_buf, 0xff, sizeof(rx_buf));
+
+	/* Check bus in idle state */
+	if (WAIT_FOR((npcx_i3c_state_get(inst) == MSTATUS_STATE_IDLE), NPCX_I3C_CHK_TIMEOUT_US,
+		     NULL) == false) {
+		LOG_ERR("%s: DAA state error: %d", __func__, npcx_i3c_state_get(inst));
+		npcx_i3c_mutex_unlock(dev);
+		return -ETIMEDOUT;
+	}
+
+	LOG_DBG("DAA: ENTDAA");
+
+	/* Disable interrupt */
+	intmask = inst->MINTSET;
+	npcx_i3c_interrupt_all_disable(inst);
+
+	npcx_i3c_xfer_reset(inst);
+
+	/* Emit process DAA */
+	if (npcx_i3c_request_daa(inst) != 0) {
+		ret = -ETIMEDOUT;
+		LOG_ERR("Emit process DAA error");
+		goto out_do_daa;
+	}
+
+	/* Loop until no more responses from devices */
+	do {
+		/* Check ERRWARN bit set */
+		if (npcx_i3c_has_error(inst)) {
+			ret = -EIO;
+			LOG_ERR("DAA recv error");
+			break;
+		}
+
+		/* Receive Provisioned ID, BCR and DCR (total 8 bytes) */
+		rx_count = GET_FIELD(inst->MDATACTRL, NPCX_I3C_MDATACTRL_RXCOUNT);
+
+		if (rx_count == DAA_TGT_INFO_SZ) {
+			for (int i = 0; i < rx_count; i++) {
+				rx_buf[i] = (uint8_t)inst->MRDATAB;
+			}
+		} else {
+			/* Data count not as expected, exit DAA */
+			ret = -EBADMSG;
+			LOG_DBG("Rx count not as expected %d, abort DAA", rx_count);
+			break;
+		}
+
+		/* Start assign dynamic address */
+		if ((npcx_i3c_state_get(inst) == MSTATUS_STATE_DAA) &&
+		    IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_BETWEEN)) {
+			struct i3c_device_desc *target;
+			uint16_t vendor_id;
+			uint32_t part_no;
+			uint64_t pid;
+			uint8_t dyn_addr = 0;
+
+			/* PID[47:33] = manufacturer ID */
+			vendor_id = (((uint16_t)rx_buf[0] << 8U) | (uint16_t)rx_buf[1]) & 0xFFFEU;
+
+			/* PID[31:0] = vendor fixed falue or random value */
+			part_no = (uint32_t)rx_buf[2] << 24U | (uint32_t)rx_buf[3] << 16U |
+				  (uint32_t)rx_buf[4] << 8U | (uint32_t)rx_buf[5];
+
+			/* Combine into one Provisioned ID */
+			pid = (uint64_t)vendor_id << 32U | (uint64_t)part_no;
+
+			LOG_DBG("DAA: Rcvd PID 0x%04x%08x", vendor_id, part_no);
+
+			/* Find a usable address during ENTDAA */
+			ret = i3c_dev_list_daa_addr_helper(&data->common.attached_dev.addr_slots,
+							   &config->common.dev_list, pid, false,
+							   false, &target, &dyn_addr);
+			if (ret != 0) {
+				LOG_ERR("%s: Assign new DA error", __func__);
+				break;
+			}
+
+			if (target == NULL) {
+				LOG_INF("%s: PID 0x%04x%08x is not in registered device "
+					"list, given dynamic address 0x%02x",
+					dev->name, vendor_id, part_no, dyn_addr);
+			} else {
+				/* Update target descriptor */
+				target->dynamic_addr = dyn_addr;
+				target->bcr = rx_buf[6];
+				target->dcr = rx_buf[7];
+			}
+
+			/* Mark the address as I3C device */
+			i3c_addr_slots_mark_i3c(&data->common.attached_dev.addr_slots, dyn_addr);
+
+			/*
+			 * If the device has static address, after address assignment,
+			 * the device will not respond to the static address anymore.
+			 * So free the static one from address slots if different from
+			 * newly assigned one.
+			 */
+			if ((target != NULL) && (target->static_addr != 0U) &&
+			    (dyn_addr != target->static_addr)) {
+				i3c_addr_slots_mark_free(&data->common.attached_dev.addr_slots,
+							 dyn_addr);
+			}
+
+			/* Emit process DAA again to send the address to the device */
+			inst->MWDATAB = dyn_addr;
+			ret = npcx_i3c_request_daa(inst);
+			if (ret != 0) {
+				LOG_ERR("%s: Assign DA timeout", __func__);
+				break;
+			}
+
+			LOG_DBG("PID 0x%04x%08x assigned dynamic address 0x%02x", vendor_id,
+				part_no, dyn_addr);
+
+			/* Target did not accept the assigned DA, exit DAA */
+			if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_NACKED)) {
+				ret = -EFAULT;
+				LOG_DBG("TGT NACK assigned DA %#x", dyn_addr);
+
+				/* Free the reserved DA */
+				i3c_addr_slots_mark_free(&data->common.attached_dev.addr_slots,
+							 dyn_addr);
+
+				/* 0 if address has not been assigned */
+				if (target != NULL) {
+					target->dynamic_addr = 0;
+				}
+
+				break;
+			}
+		}
+
+		/* Check all targets have been assigned DA and DAA complete */
+	} while ((!IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE)) &&
+		 npcx_i3c_state_get(inst) != MSTATUS_STATE_IDLE);
+
+out_do_daa:
+	/* Exit DAA mode when error occurs */
+	if (ret != 0) {
+		npcx_i3c_request_emit_stop(inst);
+	}
+
+	/* Clear all flags. */
+	npcx_i3c_errwarn_clear_all(inst);
+	npcx_i3c_status_clear_all(inst);
+
+	/* Re-Enable I3C IRQ sources. */
+	npcx_i3c_interrupt_enable(inst, intmask);
+
+	npcx_i3c_fifo_flush(inst);
+	npcx_i3c_mutex_unlock(dev);
+
+	return ret;
+}
+
+/*
+ * brief:  Send Common Command Code (CCC).
+ *
+ * param[in] dev      Pointer to controller device driver instance.
+ * param[in] payload  Pointer to CCC payload.
+ *
+ * return:  The same as i3c_do_ccc()
+ *          0 If successful.
+ *          -EBUSY Bus is busy.
+ *          -EIO General Input / output error.
+ *          -EINVAL Invalid valid set in the payload structure.
+ *          -ENOSYS Not implemented.
+ */
+static int npcx_i3c_do_ccc(const struct device *dev, struct i3c_ccc_payload *payload)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	int ret;
+	struct i3c_reg *inst = config->base;
+	uint32_t intmask;
+	int xfered_len;
+
+	if (dev == NULL || payload == NULL) {
+		return -EINVAL;
+	}
+
+	npcx_i3c_mutex_lock(dev);
+
+	/* Disable interrupt */
+	intmask = inst->MINTSET;
+	npcx_i3c_interrupt_all_disable(inst);
+
+	/* Clear status and flush fifo */
+	npcx_i3c_xfer_reset(inst);
+
+	LOG_DBG("CCC[0x%02x]", payload->ccc.id);
+
+	/* Write emit START and broadcast address (0x7E) */
+	ret = npcx_i3c_request_emit_start(inst, I3C_BROADCAST_ADDR, NPCX_I3C_MCTRL_TYPE_I3C, false,
+					  0);
+	if (ret < 0) {
+		LOG_ERR("CCC[0x%02x] %s START error (%d)", payload->ccc.id,
+			i3c_ccc_is_payload_broadcast(payload) ? "broadcast" : "direct", ret);
+
+		goto out_do_ccc;
+	}
+
+	/* Write CCC command */
+	npcx_i3c_status_clear_all(inst);
+	npcx_i3c_errwarn_clear_all(inst);
+	xfered_len = npcx_i3c_xfer_write_fifo(inst, &payload->ccc.id, 1, payload->ccc.data_len > 0);
+	if (xfered_len < 0) {
+		LOG_ERR("CCC[0x%02x] %s command error (%d)", payload->ccc.id,
+			i3c_ccc_is_payload_broadcast(payload) ? "broadcast" : "direct", ret);
+		ret = xfered_len;
+
+		goto out_do_ccc;
+	}
+
+	/* Write data (defining byte or data bytes) for CCC if needed */
+	if (payload->ccc.data_len > 0) {
+		npcx_i3c_status_clear_all(inst);
+		npcx_i3c_errwarn_clear_all(inst);
+		xfered_len = npcx_i3c_xfer_write_fifo(inst, payload->ccc.data,
+						      payload->ccc.data_len, false);
+		if (xfered_len < 0) {
+			LOG_ERR("CCC[0x%02x] %s command payload error (%d)", payload->ccc.id,
+				i3c_ccc_is_payload_broadcast(payload) ? "broadcast" : "direct",
+				ret);
+			ret = xfered_len;
+
+			goto out_do_ccc;
+		}
+
+		/* Write back the transferred bytes */
+		payload->ccc.num_xfer = xfered_len;
+	}
+
+	/* Wait message transfer complete */
+	if (WAIT_FOR(IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE), NPCX_I3C_CHK_TIMEOUT_US,
+		     NULL) == false) {
+		ret = -ETIMEDOUT;
+		LOG_DBG("Check complete timeout");
+		goto out_do_ccc;
+	}
+
+	inst->MSTATUS = BIT(NPCX_I3C_MSTATUS_COMPLETE); /* W1C */
+
+	/* For direct CCC */
+	if (!i3c_ccc_is_payload_broadcast(payload)) {
+		/*
+		 * If there are payload(s) for each target,
+		 * RESTART and then send payload for each target.
+		 */
+		for (int idx = 0; idx < payload->targets.num_targets; idx++) {
+			struct i3c_ccc_target_payload *tgt_payload =
+				&payload->targets.payloads[idx];
+
+			bool is_read = (tgt_payload->rnw == 1U);
+
+			xfered_len = npcx_i3c_do_one_xfer(
+				inst, tgt_payload->addr, NPCX_I3C_MCTRL_TYPE_I3C, tgt_payload->data,
+				tgt_payload->data_len, is_read, true, false, false);
+			if (xfered_len < 0) {
+				LOG_ERR("CCC[0x%02x] target payload error (%d)", payload->ccc.id,
+					ret);
+				ret = xfered_len;
+
+				goto out_do_ccc;
+			}
+
+			/* Write back the total number of bytes transferred */
+			tgt_payload->num_xfer = xfered_len;
+		}
+	}
+
+out_do_ccc:
+	npcx_i3c_request_emit_stop(inst);
+
+	npcx_i3c_interrupt_enable(inst, intmask);
+
+	npcx_i3c_mutex_unlock(dev);
+
+	return ret;
+}
+
+#ifdef CONFIG_I3C_USE_IBI
+/*
+ * brief  Callback to service target initiated IBIs in workqueue.
+ *
+ * param[in] work  Pointer to k_work item.
+ */
+static void npcx_i3c_ibi_work(struct k_work *work)
+{
+	uint8_t payload[CONFIG_I3C_IBI_MAX_PAYLOAD_SIZE];
+	size_t payload_sz = 0;
+
+	struct i3c_ibi_work *i3c_ibi_work = CONTAINER_OF(work, struct i3c_ibi_work, work);
+	const struct device *dev = i3c_ibi_work->controller;
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_dev_attached_list *dev_list = &data->common.attached_dev;
+	struct i3c_reg *inst = config->base;
+	struct i3c_device_desc *target = NULL;
+	uint32_t ibitype, ibiaddr;
+	int ret;
+
+	k_sem_take(&data->ibi_lock_sem, K_FOREVER);
+
+	if (npcx_i3c_state_get(inst) != MSTATUS_STATE_TGTREQ) {
+		LOG_DBG("IBI work %p running not because of IBI", work);
+		LOG_ERR("%s: MSTATUS 0x%08x MERRWARN 0x%08x", __func__, inst->MSTATUS,
+			inst->MERRWARN);
+
+		npcx_i3c_request_emit_stop(inst);
+
+		goto out_ibi_work;
+	};
+
+	/* Use auto IBI to service the IBI */
+	npcx_i3c_request_auto_ibi(inst);
+
+	/* Wait for target to win address arbitration (ibitype and ibiaddr) */
+	if (WAIT_FOR(IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_IBIWON), NPCX_I3C_CHK_TIMEOUT_US,
+		     NULL) == false) {
+		LOG_ERR("IBI work, IBIWON timeout");
+
+		goto out_ibi_work;
+	}
+
+	ibitype = GET_FIELD(inst->MSTATUS, NPCX_I3C_MSTATUS_IBITYPE);
+	ibiaddr = GET_FIELD(inst->MSTATUS, NPCX_I3C_MSTATUS_IBIADDR);
+
+	switch (ibitype) {
+	case MSTATUS_IBITYPE_IBI:
+		target = i3c_dev_list_i3c_addr_find(dev_list, (uint8_t)ibiaddr);
+		if (target != NULL) {
+			ret = npcx_i3c_xfer_read_fifo(inst, &payload[0], sizeof(payload));
+			if (ret >= 0) {
+				payload_sz = (size_t)ret;
+			} else {
+				LOG_ERR("Error reading IBI payload");
+
+				npcx_i3c_request_emit_stop(inst);
+
+				goto out_ibi_work;
+			}
+		} else {
+			/* NACK IBI coming from unknown device */
+			npcx_i3c_ibi_respond_nack(inst);
+		}
+		break;
+	case MSTATUS_IBITYPE_HJ:
+		npcx_i3c_ibi_respond_ack(inst);
+		npcx_i3c_request_emit_stop(inst);
+		break;
+	case MSTATUS_IBITYPE_CR:
+		LOG_DBG("Controller role handoff not supported");
+		npcx_i3c_ibi_respond_nack(inst);
+		break;
+	default:
+		break;
+	}
+
+	if (npcx_i3c_has_error(inst)) {
+		/*
+		 * If the controller detects any errors, simply
+		 * emit a STOP to abort the IBI. The target will
+		 * raise IBI again if so desired.
+		 */
+		npcx_i3c_request_emit_stop(inst);
+
+		goto out_ibi_work;
+	}
+
+	switch (ibitype) {
+	case MSTATUS_IBITYPE_IBI:
+		if (target != NULL) {
+			if (i3c_ibi_work_enqueue_target_irq(target, &payload[0], payload_sz) != 0) {
+				LOG_ERR("Error enqueue IBI IRQ work");
+			}
+		}
+
+		/* Finishing the IBI transaction */
+		npcx_i3c_request_emit_stop(inst);
+		break;
+	case MSTATUS_IBITYPE_HJ:
+		if (i3c_ibi_work_enqueue_hotjoin(dev) != 0) {
+			LOG_ERR("Error enqueue IBI HJ work");
+		}
+		break;
+	case MSTATUS_IBITYPE_CR:
+		/* Not supported */
+		break;
+	default:
+		break;
+	}
+
+out_ibi_work:
+	npcx_i3c_xfer_reset(inst);
+
+	k_sem_give(&data->ibi_lock_sem);
+
+	/* Re-enable target initiated IBI interrupt. */
+	inst->MINTSET = BIT(NPCX_I3C_MINTSET_TGTSTART);
+}
+
+/* Set local IBI information to IBIRULES register */
+static void npcx_i3c_ibi_rules_setup(struct npcx_i3c_data *data, struct i3c_reg *inst)
+{
+	uint32_t ibi_rules;
+	int idx;
+
+	ibi_rules = 0;
+
+	for (idx = 0; idx < ARRAY_SIZE(data->ibi.addr); idx++) {
+		uint32_t addr_6bit;
+
+		/* Extract the lower 6-bit of target address */
+		addr_6bit = (uint32_t)data->ibi.addr[idx] & IBIRULES_ADDR_MSK;
+
+		/* Shift into correct place */
+		addr_6bit <<= idx * IBIRULES_ADDR_SHIFT;
+
+		/* Put into the temporary IBI Rules register */
+		ibi_rules |= addr_6bit;
+	}
+
+	if (!data->ibi.msb) {
+		/* The MSB0 field is 1 if MSB is 0 */
+		ibi_rules |= BIT(NPCX_I3C_IBIRULES_MSB0);
+	}
+
+	if (!data->ibi.has_mandatory_byte) {
+		/* The NOBYTE field is 1 if there is no mandatory byte */
+		ibi_rules |= BIT(NPCX_I3C_IBIRULES_NOBYTE);
+	}
+
+	/* Update the register */
+	inst->IBIRULES = ibi_rules;
+
+	LOG_DBG("MIBIRULES 0x%08x", ibi_rules);
+}
+
+static int npcx_i3c_ibi_enable(const struct device *dev, struct i3c_device_desc *target)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_reg *inst = config->base;
+	struct i3c_ccc_events i3c_events;
+	uint8_t idx;
+	bool msb, has_mandatory_byte;
+	int ret;
+
+	/* Check target IBI request capable */
+	if (!i3c_device_is_ibi_capable(target)) {
+		LOG_ERR("%s: device is not ibi capable", __func__);
+		return -EINVAL;
+	}
+
+	if (data->ibi.num_addr >= ARRAY_SIZE(data->ibi.addr)) {
+		/* No more free entries in the IBI Rules table */
+		LOG_ERR("%s: no more free space in the IBI rules table", __func__);
+		return -ENOMEM;
+	}
+
+	/* Check whether the selected target is already in the list */
+	for (idx = 0; idx < ARRAY_SIZE(data->ibi.addr); idx++) {
+		if (data->ibi.addr[idx] == target->dynamic_addr) {
+			LOG_ERR("%s: selected target is already in the list", __func__);
+			return -EINVAL;
+		}
+	}
+
+	/* Disable controller interrupt while we configure IBI rules. */
+	inst->MINTCLR = BIT(NPCX_I3C_MINTCLR_TGTSTART);
+
+	LOG_DBG("IBI enabling for 0x%02x (BCR 0x%02x)", target->dynamic_addr, target->bcr);
+
+	msb = (target->dynamic_addr & BIT(6)) == BIT(6); /* Check addess(7-bit) MSB enable */
+	has_mandatory_byte = i3c_ibi_has_payload(target);
+
+	/*
+	 * If there are already addresses in the table, we must
+	 * check if the incoming entry is compatible with
+	 * the existing ones.
+	 *
+	 * All targets in the list should follow the same IBI rules.
+	 */
+	if (data->ibi.num_addr > 0) {
+		/*
+		 * 1. All devices in the table must all use mandatory
+		 *    bytes, or do not.
+		 *
+		 * 2. Each address in entry only captures the lowest 6-bit.
+		 *    The MSB (7th bit) is captured separated in another bit
+		 *    in the register. So all addresses must have the same MSB.
+		 */
+		if ((has_mandatory_byte != data->ibi.has_mandatory_byte) ||
+		    (msb != data->ibi.msb)) {
+			ret = -EINVAL;
+			LOG_ERR("%s: New IBI does not have same mandatory byte or msb"
+				" as previous IBI", __func__);
+			goto out_ibi_enable;
+		}
+
+		/* Find an empty address slot */
+		for (idx = 0; idx < ARRAY_SIZE(data->ibi.addr); idx++) {
+			if (data->ibi.addr[idx] == 0U) {
+				break;
+			}
+		}
+
+		if (idx >= ARRAY_SIZE(data->ibi.addr)) {
+			ret = -ENOTSUP;
+			LOG_ERR("Cannot support more IBIs");
+			goto out_ibi_enable;
+		}
+	} else {
+		/*
+		 * If the incoming address is the first in the table,
+		 * it dictates future compatibilities.
+		 */
+		data->ibi.has_mandatory_byte = has_mandatory_byte;
+		data->ibi.msb = msb;
+
+		idx = 0;
+	}
+
+	data->ibi.addr[idx] = target->dynamic_addr;
+	data->ibi.num_addr += 1U;
+
+	npcx_i3c_ibi_rules_setup(data, inst);
+
+	/* Enable target IBI event by ENEC command */
+	i3c_events.events = I3C_CCC_EVT_INTR;
+	ret = i3c_ccc_do_events_set(target, true, &i3c_events);
+	if (ret != 0) {
+		LOG_ERR("Error sending IBI ENEC for 0x%02x (%d)", target->dynamic_addr, ret);
+	}
+
+out_ibi_enable:
+	if (data->ibi.num_addr > 0U) {
+		/*
+		 * If there is more than 1 target in the list,
+		 * enable controller to raise interrupt when a target
+		 * initiates IBI.
+		 */
+		inst->MINTSET = BIT(NPCX_I3C_MINTSET_TGTSTART);
+	}
+
+	return ret;
+}
+
+static int npcx_i3c_ibi_disable(const struct device *dev, struct i3c_device_desc *target)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_reg *inst = config->base;
+	struct i3c_ccc_events i3c_events;
+	int ret;
+	int idx;
+
+	if (!i3c_device_is_ibi_capable(target)) {
+		LOG_ERR("%s: device is not ibi capable", __func__);
+		return -EINVAL;
+	}
+
+	for (idx = 0; idx < ARRAY_SIZE(data->ibi.addr); idx++) {
+		if (target->dynamic_addr == data->ibi.addr[idx]) {
+			break;
+		}
+	}
+
+	if (idx == ARRAY_SIZE(data->ibi.addr)) {
+		LOG_ERR("%s: target is not in list of registered addresses", __func__);
+		return -ENODEV;
+	}
+
+	/* Disable controller interrupt while we configure IBI rules. */
+	inst->MINTCLR = BIT(NPCX_I3C_MINTCLR_TGTSTART);
+
+	/* Clear the ibi rule data */
+	data->ibi.addr[idx] = 0U;
+	data->ibi.num_addr -= 1U;
+
+	/* Disable disable target IBI */
+	i3c_events.events = I3C_CCC_EVT_INTR;
+	ret = i3c_ccc_do_events_set(target, false, &i3c_events);
+	if (ret != 0) {
+		LOG_ERR("Error sending IBI DISEC for 0x%02x (%d)", target->dynamic_addr, ret);
+	}
+
+	npcx_i3c_ibi_rules_setup(data, inst);
+
+	if (data->ibi.num_addr > 0U) {
+		/*
+		 * Enable controller to raise interrupt when a target
+		 * initiates IBI.
+		 */
+		inst->MINTSET = BIT(NPCX_I3C_MINTSET_TGTSTART);
+	}
+
+	return ret;
+}
+#endif /* CONFIG_I3C_USE_IBI */
+
+static void npcx_i3c_isr(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *inst = config->base;
+
+#ifdef CONFIG_I3C_NPCX_DMA
+	struct mdma_reg *mdma_inst = config->mdma_base;
+
+	if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_COMPLETE)) {
+		inst->MSTATUS = BIT(NPCX_I3C_MSTATUS_COMPLETE); /* W1C */
+
+		/* MDMA write */
+		if (get_oper_state(dev) == NPCX_I3C_WR) {
+			return i3c_ctrl_notify(dev);
+		}
+	}
+
+	if (IS_BIT_SET(mdma_inst->MDMA_CTL0, NPCX_MDMA_CTL_TC)) {
+		mdma_inst->MDMA_CTL0 &= ~BIT(NPCX_MDMA_CTL_TC); /* W0C */
+
+		/* MDMA read */
+		if (get_oper_state(dev) == NPCX_I3C_RD) {
+			return i3c_ctrl_notify(dev);
+		}
+
+	}
+#endif /* CONFIG_I3C_NPCX_DMA */
+
+#ifdef CONFIG_I3C_USE_IBI
+	/* Target start detected */
+	if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_TGTSTART)) {
+		/* Disable further target initiated IBI interrupt */
+		inst->MINTCLR = BIT(NPCX_I3C_MINTCLR_TGTSTART);
+
+		/* Handle IBI in workqueue */
+		i3c_ibi_work_enqueue_cb(dev, npcx_i3c_ibi_work);
+	}
+#endif /* CONFIG_I3C_USE_IBI */
+
+}
+
+static int npcx_i3c_get_scl_config(struct npcx_i3c_timing_cfg *cfg, uint32_t i3c_src_clk,
+				   uint32_t pp_baudrate_hz, uint32_t od_baudrate_hz)
+{
+	uint32_t i3c_div, freq;
+	uint32_t ppbaud, odbaud;
+	uint32_t pplow_ns, odlow_ns;
+
+	if (cfg == NULL) {
+		LOG_ERR("Freq config NULL");
+		return -EINVAL;
+	}
+
+	if ((pp_baudrate_hz == 0) || (pp_baudrate_hz > I3C_SCL_PP_FREQ_MAX_MHZ) ||
+	    (od_baudrate_hz == 0) || (od_baudrate_hz > I3C_SCL_OD_FREQ_MAX_MHZ)) {
+		LOG_ERR("I3C PP_SCL should within 12.5 Mhz, input: %d", pp_baudrate_hz);
+		LOG_ERR("I3C OD_SCL should within 4.17 Mhz, input: %d", od_baudrate_hz);
+		return -EINVAL;
+	}
+
+	/* Fixed PPLOW = 0 to achieve 50% duty cycle */
+	/* pp_freq = ((f_mclkd / 2) / (PPBAUD+1)) */
+	freq = i3c_src_clk / 2UL;
+
+	i3c_div = freq / pp_baudrate_hz;
+	i3c_div = (i3c_div == 0UL) ? 1UL : i3c_div;
+	if (freq / i3c_div > pp_baudrate_hz) {
+		i3c_div++;
+	}
+
+	if (i3c_div > PPBAUD_DIV_MAX) {
+		LOG_ERR("PPBAUD out of range");
+		return -EINVAL;
+	}
+
+	ppbaud = i3c_div - 1UL;
+	freq /= i3c_div;
+
+	/* Check PP low period in spec (should be the same as PPHIGH) */
+	pplow_ns = (uint32_t)(NSEC_PER_SEC / (2UL * freq));
+	if (pplow_ns < I3C_BUS_TLOW_PP_MIN_NS) {
+		LOG_ERR("PPLOW ns out of spec");
+		return -EINVAL;
+	}
+
+	/* Fixed odhpp = 1 configuration */
+	/* odFreq = (2*freq) / (ODBAUD + 2), 1 <= ODBAUD <= 255 */
+	i3c_div = (2UL * freq) / od_baudrate_hz;
+	i3c_div = i3c_div < 2UL ? 2UL : i3c_div;
+	if ((2UL * freq / i3c_div) > od_baudrate_hz) {
+		i3c_div++;
+	}
+
+	odbaud = i3c_div - 2UL;
+	freq = (2UL * freq) / i3c_div; /* For I2C usage in the future */
+
+	/* Check OD low period in spec */
+	odlow_ns = (odbaud + 1UL) * pplow_ns;
+	if (odlow_ns < I3C_BUS_TLOW_OD_MIN_NS) {
+		LOG_ERR("ODBAUD ns out of spec");
+		return -EINVAL;
+	}
+
+	cfg->pplow = 0;
+	cfg->odhpp = 1;
+	cfg->ppbaud = ppbaud;
+	cfg->odbaud = odbaud;
+
+	return 0;
+}
+
+static int npcx_i3c_freq_init(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_reg *inst = config->base;
+	const struct device *const clk_dev = config->clock_dev;
+	struct i3c_config_controller *ctrl_config = &data->common.ctrl_config;
+	uint32_t scl_pp = ctrl_config->scl.i3c;
+	uint32_t scl_od = config->clocks.i3c_od_scl_hz;
+	struct npcx_i3c_timing_cfg timing_cfg;
+	uint32_t mclkd;
+	int ret;
+
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clock_subsys,
+				     &mclkd);
+	if (ret != 0x0) {
+		LOG_ERR("Get I3C source clock fail %d", ret);
+		return -EINVAL;
+	}
+
+	LOG_DBG("MCLKD: %d", mclkd);
+	LOG_DBG("SCL_PP_FEQ MAX: %d", I3C_SCL_PP_FREQ_MAX_MHZ);
+	LOG_DBG("SCL_OD_FEQ MAX: %d", I3C_SCL_OD_FREQ_MAX_MHZ);
+	LOG_DBG("scl_pp: %d", scl_pp);
+	LOG_DBG("scl_od: %d", scl_od);
+	LOG_DBG("hdr: %d", ctrl_config->supported_hdr);
+
+	/* MCLKD = MCLK / I3C_DIV(1 or 2)
+	 * MCLKD must between 40 mhz to 50 mhz.
+	 */
+	if (mclkd == MCLKD_FREQ_45_MHZ) {
+		/* Set default I3C_SCL configuration */
+		timing_cfg = npcx_def_speed_cfg[NPCX_I3C_BUS_SPEED_45MHZ];
+	} else {
+		LOG_ERR("Unsupported MCLKD freq for %s.", dev->name);
+		return -EINVAL;
+	}
+
+	ret = npcx_i3c_get_scl_config(&timing_cfg, mclkd, scl_pp, scl_od);
+	if (ret != 0x0) {
+		LOG_ERR("Adjust I3C frequency fail");
+		return -EINVAL;
+	}
+
+	/* Apply SCL_PP and SCL_OD */
+	SET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_PPBAUD, timing_cfg.ppbaud);
+	SET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_PPLOW, timing_cfg.pplow);
+	SET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_ODBAUD, timing_cfg.odbaud);
+	if (timing_cfg.odhpp != 0) {
+		inst->MCONFIG |= BIT(NPCX_I3C_MCONFIG_ODHPP);
+	} else {
+		inst->MCONFIG &= ~BIT(NPCX_I3C_MCONFIG_ODHPP);
+	}
+
+	LOG_DBG("ppbaud: %d", GET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_PPBAUD));
+	LOG_DBG("odbaud: %d", GET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_ODBAUD));
+	LOG_DBG("pplow: %d", GET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_PPLOW));
+	LOG_DBG("odhpp: %d", IS_BIT_SET(inst->MCONFIG, NPCX_I3C_MCONFIG_ODHPP));
+
+	return 0;
+}
+
+static int npcx_i3c_cntlr_init(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct i3c_reg *inst = config->base;
+	const struct device *const clk_dev = config->clock_dev;
+	uint32_t apb4_rate;
+	uint8_t bamatch;
+	int ret;
+
+	/* Reset I3C module */
+	reset_line_toggle_dt(&config->reset);
+
+	/* Disable all interrupts */
+	npcx_i3c_interrupt_all_disable(inst);
+
+	/* Initial baudrate. PPLOW=1, PPBAUD, ODHPP=1, ODBAUD */
+	if (npcx_i3c_freq_init(dev) != 0x0) {
+		return -EINVAL;
+	}
+
+	/* Enable main controller mode */
+	SET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_CTRENA, MCONFIG_CTRENA_ON);
+	/* Enable external high-keeper */
+	SET_FIELD(inst->MCONFIG, NPCX_I3C_MCONFIG_HKEEP, MCONFIG_HKEEP_EXT_SDA_SCL);
+	/* Enable open-drain stop */
+	inst->MCONFIG |= BIT(NPCX_I3C_MCONFIG_ODSTOP);
+	/* Enable timeout */
+	inst->MCONFIG &= ~BIT(NPCX_I3C_MCONFIG_DISTO);
+	/* Flush tx and tx FIFO buffer */
+	npcx_i3c_fifo_flush(inst);
+
+	/* Set bus available match value in target register */
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->ref_clk_subsys,
+				     &apb4_rate);
+	LOG_DBG("APB4_CLK: %d", apb4_rate);
+
+	if (ret != 0x0) {
+		LOG_ERR("Get APb4 source clock fail %d", ret);
+		return -EINVAL;
+	}
+
+	bamatch = DIV_ROUND_UP(apb4_rate, MHZ(1));
+	bamatch = DIV_ROUND_UP(bamatch, BAMATCH_DIV);
+	LOG_DBG("BAMATCH: %d", bamatch);
+
+	SET_FIELD(inst->CONFIG, NPCX_I3C_CONFIG_BAMATCH, bamatch);
+
+	return 0;
+}
+
+static int npcx_i3c_configure(const struct device *dev, enum i3c_config_type type, void *config)
+{
+	struct npcx_i3c_data *dev_data = dev->data;
+	struct i3c_config_controller *cntlr_cfg = config;
+
+	if (type == I3C_CONFIG_CONTROLLER) {
+		/*
+		 * Check for valid configuration parameters.
+		 * Currently, must be the primary controller.
+		 */
+		if ((cntlr_cfg->is_secondary) || (cntlr_cfg->scl.i3c == 0U)) {
+			return -EINVAL;
+		}
+
+		/* Save requested config to dev */
+		(void)memcpy(&dev_data->common.ctrl_config, cntlr_cfg, sizeof(*cntlr_cfg));
+
+		/* Controller init */
+		return npcx_i3c_cntlr_init(dev);
+	}
+
+	LOG_ERR("Support controller mode only");
+	return -EINVAL;
+}
+
+static int npcx_i3c_config_get(const struct device *dev, enum i3c_config_type type, void *config)
+{
+	struct npcx_i3c_data *data = dev->data;
+
+	if ((type != I3C_CONFIG_CONTROLLER) || (config == NULL)) {
+		return -EINVAL;
+	}
+
+	(void)memcpy(config, &data->common.ctrl_config, sizeof(data->common.ctrl_config));
+
+	return 0;
+}
+
+static int npcx_i3c_init(const struct device *dev)
+{
+	const struct npcx_i3c_config *config = dev->config;
+	struct npcx_i3c_data *data = dev->data;
+	struct i3c_config_controller *ctrl_config = &data->common.ctrl_config;
+	const struct device *const clk_dev = config->clock_dev;
+	int ret;
+
+	/* Check clock device ready */
+	if (!device_is_ready(clk_dev)) {
+		LOG_ERR("%s Clk device not ready", clk_dev->name);
+		return -ENODEV;
+	}
+
+	/* Set I3C_PD operational */
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->clock_subsys);
+	if (ret < 0) {
+		LOG_ERR("Turn on I3C clock fail %d", ret);
+		return ret;
+	}
+
+#ifdef CONFIG_I3C_NPCX_DMA
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->mdma_clk_subsys);
+	if (ret < 0) {
+		LOG_ERR("Turn on I3C MDMA clock fail %d", ret);
+		return ret;
+	}
+#endif
+
+	/* Apply pin-muxing */
+	ret = pinctrl_apply_state(config->pincfg, PINCTRL_STATE_DEFAULT);
+	if (ret != 0) {
+		LOG_ERR("Apply pinctrl fail %d", ret);
+		return ret;
+	}
+
+	k_mutex_init(&data->lock_mutex);
+	k_sem_init(&data->sync_sem, 0, 1);
+	k_sem_init(&data->ibi_lock_sem, 1, 1);
+
+	ret = i3c_addr_slots_init(dev);
+	if (ret != 0) {
+		LOG_ERR("Addr slots init fail %d", ret);
+		return ret;
+	}
+
+	ctrl_config->is_secondary = false; /* Currently can only act as primary controller. */
+	ctrl_config->supported_hdr = 0U;   /* HDR mode not supported at the moment. */
+	ctrl_config->scl.i3c = config->clocks.i3c_pp_scl_hz; /* Set I3C frequency */
+
+	ret = npcx_i3c_configure(dev, I3C_CONFIG_CONTROLLER, ctrl_config);
+	if (ret != 0) {
+		LOG_ERR("Apply i3c_configure() fail %d", ret);
+		return ret;
+	}
+
+	/* Just in case the bus is not in idle. */
+	ret = npcx_i3c_recover_bus(dev);
+	if (ret != 0) {
+		LOG_ERR("Apply i3c_recover_bus() fail %d", ret);
+		return ret;
+	}
+
+	/* Configure interrupt */
+	config->irq_config_func(dev);
+
+	/* Initialize driver status machine */
+	set_oper_state(dev, NPCX_I3C_IDLE);
+
+	/* Check I3C target device exist in device tree */
+	if (config->common.dev_list.num_i3c > 0) {
+		/* Perform bus initialization */
+		ret = i3c_bus_init(dev, &config->common.dev_list);
+		if (ret != 0) {
+			LOG_ERR("Apply i3c_bus_init() fail %d", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static const struct i3c_driver_api npcx_i3c_driver_api = {
+	.configure = npcx_i3c_configure,
+	.config_get = npcx_i3c_config_get,
+
+	.recover_bus = npcx_i3c_recover_bus,
+
+	.do_daa = npcx_i3c_do_daa,
+	.do_ccc = npcx_i3c_do_ccc,
+
+	.i3c_device_find = npcx_i3c_device_find,
+
+	.i3c_xfers = npcx_i3c_transfer,
+
+#ifdef CONFIG_I3C_USE_IBI
+	.ibi_enable = npcx_i3c_ibi_enable,
+	.ibi_disable = npcx_i3c_ibi_disable,
+#endif
+};
+
+#define I3C_NPCX_DEVICE(id)                                                                        \
+	PINCTRL_DT_INST_DEFINE(id);                                                                \
+	static void npcx_i3c_config_func_##id(const struct device *dev)                            \
+	{                                                                                          \
+		IRQ_CONNECT(DT_INST_IRQN(id), DT_INST_IRQ(id, priority), npcx_i3c_isr,             \
+			    DEVICE_DT_INST_GET(id), 0);                                            \
+		irq_enable(DT_INST_IRQN(id));                                                      \
+	};                                                                                         \
+	static struct i3c_device_desc npcx_i3c_device_array_##id[] = I3C_DEVICE_ARRAY_DT_INST(id); \
+	static struct i3c_i2c_device_desc npcx_i3c_i2c_device_array_##id[] =                       \
+		I3C_I2C_DEVICE_ARRAY_DT_INST(id);                                                  \
+	static const struct npcx_i3c_config npcx_i3c_config_##id = {                               \
+		.base = (struct i3c_reg *)DT_INST_REG_ADDR(id),                                    \
+		.clock_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE),                                    \
+		.reset = RESET_DT_SPEC_INST_GET(id),                                               \
+		.clock_subsys = NPCX_DT_CLK_CFG_ITEM_BY_NAME(id, mclkd),                           \
+		.ref_clk_subsys = NPCX_DT_CLK_CFG_ITEM_BY_NAME(id, apb4),                          \
+		.irq_config_func = npcx_i3c_config_func_##id,                                      \
+		.common.dev_list.i3c = npcx_i3c_device_array_##id,                                 \
+		.common.dev_list.num_i3c = ARRAY_SIZE(npcx_i3c_device_array_##id),                 \
+		.common.dev_list.i2c = npcx_i3c_i2c_device_array_##id,                             \
+		.common.dev_list.num_i2c = ARRAY_SIZE(npcx_i3c_i2c_device_array_##id),             \
+		.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),                                      \
+		.clocks.i3c_pp_scl_hz = DT_INST_PROP_OR(id, i3c_scl_hz, 0),                        \
+		.clocks.i3c_od_scl_hz = DT_INST_PROP_OR(id, i3c_od_scl_hz, 0),                     \
+		IF_ENABLED(CONFIG_I3C_NPCX_DMA, (                                                  \
+			.mdma_clk_subsys = NPCX_DT_CLK_CFG_ITEM_BY_IDX(id, 2),                     \
+		))                                                                                 \
+		IF_ENABLED(CONFIG_I3C_NPCX_DMA, (                                                  \
+			.mdma_base = (struct mdma_reg *)DT_INST_REG_ADDR_BY_IDX(id, 1),            \
+		))                                                                                 \
+	};                                                                                         \
+	static struct npcx_i3c_data npcx_i3c_data_##id;                                            \
+	DEVICE_DT_INST_DEFINE(id, npcx_i3c_init, NULL, &npcx_i3c_data_##id, &npcx_i3c_config_##id, \
+			      POST_KERNEL, CONFIG_I3C_CONTROLLER_INIT_PRIORITY,                    \
+			      &npcx_i3c_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(I3C_NPCX_DEVICE)
diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
index b2f6a55a8..c9be91140 100644
--- a/dts/arm/nuvoton/npcx/npcx4.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -14,7 +14,7 @@
 #include "npcx4/npcx4-espi-vws-map.dtsi"
 /* npcx4 series low-voltage io controls mapping table */
 #include "npcx4/npcx4-lvol-ctrl-map.dtsi"
-/* npcx4 series reset mapping table*/
+/* npcx4 series reset mapping table */
 #include "zephyr/dt-bindings/reset/npcx4_reset.h"
 
 /* Device tree declarations of npcx soc family */
diff --git a/dts/bindings/i3c/nuvoton,npcx-i3c.yaml b/dts/bindings/i3c/nuvoton,npcx-i3c.yaml
new file mode 100644
index 000000000..0633da8e9
--- /dev/null
+++ b/dts/bindings/i3c/nuvoton,npcx-i3c.yaml
@@ -0,0 +1,52 @@
+# Copyright (c) 2024 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+description: |
+    Nuvoton I3C controller
+
+    Representation:
+
+    /* If CONFIG_I3C_NPCX is enabled, the suggested clock configuration is as follows: */
+    &pcc {
+      clock-frequency = <DT_FREQ_M(90)>; /* OFMCLK runs at 90MHz */
+      core-prescaler = <3>; /* CORE_CLK runs at 30MHz */
+      apb1-prescaler = <6>; /* APB1_CLK runs at 15MHz */
+      apb2-prescaler = <6>; /* APB2_CLK runs at 15MHz */
+      apb3-prescaler = <6>; /* APB3_CLK runs at 15MHz */
+      apb4-prescaler = <3>; /* APB4_CLK runs at 30MHz */
+    };
+
+    &rst {
+      status = "okay";
+    };
+
+    &i3c0 {
+      status = "okay";
+
+      /* I3C clock frequency suggestion = <PP_SCL, OD_SCL> */
+       * Full speed = <12500000, 4170000>
+       * Normal speed = <7500000, 1500000>
+       */
+      i3c-scl-hz = <12500000>;
+      i3c-od-scl-hz = <4170000>;
+    };
+
+compatible: "nuvoton,npcx-i3c"
+
+include: [i3c-controller.yaml, pinctrl-device.yaml, reset-device.yaml]
+
+properties:
+  reg:
+    required: true
+
+  interrupts:
+    required: true
+
+  resets:
+    required: true
+
+  i3c-od-scl-hz:
+    type: int
+    description: |
+      Open Drain Frequency for the I3C controller. When undefined, use
+      the controller default or as specified by the I3C specification.
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index 214eadd47..78abce3c6 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -78,7 +78,10 @@ struct cdcg_reg {
 	volatile uint8_t reserved7;
 	/* 0x014: HFCG Bus Clock Dividers */
 	volatile uint8_t HFCBCD2;
-	volatile uint8_t reserved8[235];
+	volatile uint8_t reserved12[8];
+	/* 0x01d: HFCG Bus Clock Dividers */
+	volatile uint8_t HFCBCD3;
+	volatile uint8_t reserved8[226];
 
 	/* Low Frequency Clock Generator (LFCG) registers */
 	/* 0x100: LFCG Control */
@@ -1757,4 +1760,223 @@ struct swrst_reg {
 	volatile uint32_t SWRST_CTL[4];
 };
 
+/* Improved Inter Integrated Circuit  (I3C) device registers */
+struct i3c_reg {
+	/* 0x000: Controller Configuration */
+	volatile uint32_t MCONFIG;
+	/* 0x004: Target Configuration */
+	volatile uint32_t CONFIG;
+	volatile uint32_t reserved1[31];
+	/* 0x084: Controller Control  */
+	volatile uint32_t MCTRL;
+	/* 0x088: Controller Status */
+	volatile uint32_t MSTATUS;
+	/* 0x08C: IBI Registry and Rules */
+	volatile uint32_t IBIRULES;
+	/* 0x090: Controller Interrupt Enable Set  */
+	volatile uint32_t MINTSET;
+	/* 0x094: Controller Interrupt Enable Clear */
+	volatile uint32_t MINTCLR;
+	/* 0x098: Controller Interrupt Masked */
+	volatile uint32_t MINTMASKED;
+	/* 0x09C: Controller Error and Warning */
+	volatile uint32_t MERRWARN;
+	/* 0x0A0: Controller DMA Control */
+	volatile uint32_t MDMACTRL;
+	volatile uint32_t reserved2[2];
+	/* 0x0AC: Controller Data Control */
+	volatile uint32_t MDATACTRL;
+	/* 0x0B0: Controller Write Byte Data */
+	volatile uint32_t MWDATAB;
+	/* 0x0B4: Controller Write Byte Data as End */
+	volatile uint32_t MWDATABE;
+	/* 0x0B8: Controller Write Half-Word Data */
+	volatile uint32_t MWDATAH;
+	/* 0x0BC: Controller Write Half-Word Data as End */
+	volatile uint32_t MWDATAHE;
+	/* 0x0C0: Controller Read Byte Data */
+	volatile uint32_t MRDATAB;
+	volatile uint32_t reserved3;
+	/* 0x0C8: Controller Read Half-Word Data */
+	volatile uint32_t MRDATAH;
+	volatile uint32_t reserved4[3];
+	/* 0x0D8: Start or Continue DDR Message */
+	volatile uint32_t MWMSG_DDR;
+	/* 0x0DC: Read DDR Message Data */
+	volatile uint32_t MRMSG_DDR;
+	volatile uint32_t reserved5;
+	/* 0x0E4: Controller Dynamic Address */
+	volatile uint32_t MDYNADDR;
+};
+
+/* I3C register fields */
+#define NPCX_I3C_CONFIG_BAMATCH    FIELD(16, 7)
+#define NPCX_I3C_MCONFIG_CTRENA    FIELD(0, 2)
+#define NPCX_I3C_MCONFIG_DISTO     3
+#define NPCX_I3C_MCONFIG_HKEEP     FIELD(4, 2) /* Must be '11' */
+#define NPCX_I3C_MCONFIG_ODSTOP    6
+#define NPCX_I3C_MCONFIG_PPBAUD    FIELD(8, 4)
+#define NPCX_I3C_MCONFIG_PPLOW     FIELD(12, 4)
+#define NPCX_I3C_MCONFIG_ODBAUD    FIELD(16, 8)
+#define NPCX_I3C_MCONFIG_ODHPP     24
+#define NPCX_I3C_MCONFIG_SKEW      FIELD(25, 3)
+#define NPCX_I3C_MCONFIG_I2CBAUD   FIELD(28, 4)
+#define NPCX_I3C_MCTRL_REQUEST     FIELD(0, 3)
+#define NPCX_I3C_MCTRL_TYPE        FIELD(4, 2)
+#define NPCX_I3C_MCTRL_IBIRESP     FIELD(6, 2)
+#define NPCX_I3C_MCTRL_DIR         8
+#define NPCX_I3C_MCTRL_ADDR        FIELD(9, 7)
+#define NPCX_I3C_MCTRL_RDTERM      FIELD(16, 8)
+#define NPCX_I3C_MSTATUS_STATE     FIELD(0, 3)
+#define NPCX_I3C_MSTATUS_BETWEEN   4
+#define NPCX_I3C_MSTATUS_NACKED    5
+#define NPCX_I3C_MSTATUS_IBITYPE   FIELD(6, 2)
+#define NPCX_I3C_MSTATUS_TGTSTART  8
+#define NPCX_I3C_MSTATUS_MCTRLDONE 9
+#define NPCX_I3C_MSTATUS_COMPLETE  10
+#define NPCX_I3C_MSTATUS_RXPEND    11
+#define NPCX_I3C_MSTATUS_TXNOTFULL 12
+#define NPCX_I3C_MSTATUS_IBIWON    13
+#define NPCX_I3C_MSTATUS_ERRWARN   15
+#define NPCX_I3C_MSTATUS_NOWCNTLR  19
+#define NPCX_I3C_MSTATUS_IBIADDR   FIELD(24, 7)
+#define NPCX_I3C_IBIRULES_MSB0     30
+#define NPCX_I3C_IBIRULES_NOBYTE   31
+#define NPCX_I3C_MINTSET_TGTSTART  8
+#define NPCX_I3C_MINTSET_MCTRLDONE 9
+#define NPCX_I3C_MINTSET_COMPLETE  10
+#define NPCX_I3C_MINTSET_RXPEND    11
+#define NPCX_I3C_MINTSET_TXNOTFULL 12
+#define NPCX_I3C_MINTSET_IBIWON    13
+#define NPCX_I3C_MINTSET_ERRWARN   15
+#define NPCX_I3C_MINTSET_NOWCNTLR  19
+#define NPCX_I3C_MINTCLR_TGTSTART  8
+#define NPCX_I3C_MINTCLR_MCTRLDONE 9
+#define NPCX_I3C_MINTCLR_COMPLETE  10
+#define NPCX_I3C_MINTCLR_RXPEND    11
+#define NPCX_I3C_MINTCLR_TXNOTFULL 12
+#define NPCX_I3C_MINTCLR_IBIWON    13
+#define NPCX_I3C_MINTCLR_ERRWARN   15
+#define NPCX_I3C_MINTCLR_NOWCNTLR  19
+#define NPCX_I3C_MDATACTRL_FLUSHTB 0
+#define NPCX_I3C_MDATACTRL_FLUSHFB 1
+#define NPCX_I3C_MDATACTRL_UNLOCK  3
+#define NPCX_I3C_MDATACTRL_TXTRIG  FIELD(4, 2)
+#define NPCX_I3C_MDATACTRL_RXTRIG  FIELD(6, 2)
+#define NPCX_I3C_MDATACTRL_TXCOUNT FIELD(16, 5)
+#define NPCX_I3C_MDATACTRL_RXCOUNT FIELD(24, 5)
+#define NPCX_I3C_MDATACTRL_TXFULL  30
+#define NPCX_I3C_MDATACTRL_RXEMPTY 31
+#define NPCX_I3C_MERRWARN_NACK     2
+#define NPCX_I3C_MERRWARN_WRABT    3
+#define NPCX_I3C_MERRWARN_TERM     4
+#define NPCX_I3C_MERRWARN_HPAR     9
+#define NPCX_I3C_MERRWARN_HCRC     10
+#define NPCX_I3C_MERRWARN_OREAD    16
+#define NPCX_I3C_MERRWARN_OWRITE   17
+#define NPCX_I3C_MERRWARN_MSGERR   18
+#define NPCX_I3C_MERRWARN_INVERQ   19
+#define NPCX_I3C_MERRWARN_TIMEOUT  20
+#define NPCX_I3C_MDMACTRL_DMAFB    FIELD(0, 2)
+#define NPCX_I3C_MDMACTRL_DMATB    FIELD(2, 2)
+
+
+/* MCONFIG options */
+#define MCONFIG_CTRENA_OFF        0x0
+#define MCONFIG_CTRENA_ON         0x1
+#define MCONFIG_CTRENA_CAPABLE    0x2
+#define MCONFIG_HKEEP_EXT_SDA_SCL 0x3
+
+/* MCTRL options */
+#define MCTRL_REQUEST_NONE          0 /* None */
+#define MCTRL_REQUEST_EMITSTARTADDR 1 /* Emit a START */
+#define MCTRL_REQUEST_EMITSTOP      2 /* Emit a STOP */
+#define MCTRL_REQUEST_IBIACKNACK    3 /* Manually ACK or NACK an IBI */
+#define MCTRL_REQUEST_PROCESSDAA    4 /* Starts the DAA process */
+#define MCTRL_REQUEST_FORCEEXIT     6 /* Emit HDR Exit Pattern  */
+/* Emits a START with address 7Eh when a slave pulls I3C_SDA low to request an IBI */
+#define MCTRL_REQUEST_AUTOIBI       7
+
+/* ACK with mandatory byte determined by IBIRULES or ACK with no mandatory byte */
+#define MCTRL_IBIRESP_ACK           0
+#define MCTRL_IBIRESP_NACK          1 /* NACK */
+#define MCTRL_IBIRESP_ACK_MANDATORY 2 /* ACK with mandatory byte  */
+#define MCTRL_IBIRESP_MANUAL        3
+
+enum npcx_i3c_mctrl_type {
+	NPCX_I3C_MCTRL_TYPE_I3C,
+	NPCX_I3C_MCTRL_TYPE_I2C,
+	NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR,
+};
+
+/* MSTATUS options */
+#define MSTATUS_STATE_IDLE    0x0
+#define MSTATUS_STATE_TGTREQ  0x1
+#define MSTATUS_STATE_NORMACT 0x3 /* SDR message mode */
+#define MSTATUS_STATE_MSGDDR  0x4
+#define MSTATUS_STATE_DAA     0x5
+#define MSTATUS_STATE_IBIACK  0x6
+#define MSTATUS_STATE_IBIRCV  0x7
+#define MSTATUS_IBITYPE_NONE  0x0
+#define MSTATUS_IBITYPE_IBI   0x1
+#define MSTATUS_IBITYPE_CR    0x2
+#define MSTATUS_IBITYPE_HJ    0x3
+
+/* IBIRULES */
+#define IBIRULES_ADDR_MSK   0x3F
+#define IBIRULES_ADDR_SHIFT 0x6
+
+/* MDMACTRL options */
+#define MDMA_DMAFB_DISABLE      0x0
+#define MDMA_DMAFB_EN_ONE_FRAME 0x1
+#define MDMA_DMAFB_EN_MANUAL    0x2
+#define MDMA_DMATB_DISABLE      0x0
+#define MDMA_DMATB_EN_ONE_FRAME 0x1
+#define MDMA_DMATB_EN_MANUAL    0x2
+
+/* MDMA Controller registers */
+struct mdma_reg {
+	/* Channel 0 */
+	/* 0x000: Channel 0 Control */
+	volatile uint32_t MDMA_CTL0;
+	/* 0x004: Channel 0 Source Base Address */
+	volatile uint32_t MDMA_SRCB0;
+	/* 0x008: Channel 0 Destination Base Address */
+	volatile uint32_t MDMA_DSTB0;
+	/* 0x00C: Channel 0 Transfer Count */
+	volatile uint32_t MDMA_TCNT0;
+	/* 0x010: reserved1 */
+	volatile uint32_t reserved1;
+	/* 0x014: Channel 0 Current Destination */
+	volatile uint32_t MDMA_CDST0;
+	/* 0x018: Channel 0 Current Transfer Count */
+	volatile uint32_t MDMA_CTCNT0;
+	/* 0x01C: reserved2 */
+	volatile uint32_t reserved2;
+
+	/* Channel 1 */
+	/* 0x020: Channel 1 Control */
+	volatile uint32_t MDMA_CTL1;
+	/* 0x024: Channel 1 Source Base Address */
+	volatile uint32_t MDMA_SRCB1;
+	/* 0x028: Channel 1 Destination Base Address */
+	volatile uint32_t MDMA_DSTB1;
+	/* 0x02C: Channel 1 Transfer Count */
+	volatile uint32_t MDMA_TCNT1;
+	/* 0x030: Channel 1 Current Source */
+	volatile uint32_t MDMA_CSRC1;
+	/* 0x034: reserved3 */
+	volatile uint32_t reserved3;
+	/* 0x038: Channel 1 Current Transfer Count */
+	volatile uint32_t MDMA_CTCNT1;
+};
+
+/* MDMA register fields */
+#define NPCX_MDMA_CTL_MDMAEN    0
+#define NPCX_MDMA_CTL_MPD       1
+#define NPCX_MDMA_CTL_SIEN      8
+#define NPCX_MDMA_CTL_MPS       14
+#define NPCX_MDMA_CTL_TC        18
+#define NPCX_MDMA_TCNT_TFR_CNT  FIELD(0, 12)
+
 #endif /* _NUVOTON_NPCX_REG_DEF_H */
diff --git a/soc/arm/nuvoton_npcx/common/registers.c b/soc/arm/nuvoton_npcx/common/registers.c
index e12b3bc10..00ee142b1 100644
--- a/soc/arm/nuvoton_npcx/common/registers.c
+++ b/soc/arm/nuvoton_npcx/common/registers.c
@@ -197,3 +197,30 @@ NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[0], 0x004);
 NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[1], 0x008);
 NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[2], 0x00c);
 NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[3], 0x010);
+
+/* I3C register structure check */
+NPCX_REG_SIZE_CHECK(i3c_reg, 0x0E8);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MCONFIG, 0x000);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MCTRL, 0x084);
+NPCX_REG_OFFSET_CHECK(i3c_reg, IBIRULES, 0x08C);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MINTSET, 0x090);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MINTCLR, 0x094);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MINTMASKED, 0x098);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MERRWARN, 0x09C);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MDATACTRL, 0x0AC);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MWDATAB, 0x0B0);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MWDATABE, 0x0B4);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MWDATAH, 0x0B8);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MWDATAHE, 0x0BC);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MRDATAB, 0x0C0);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MRDATAH, 0x0C8);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MWMSG_DDR, 0x0D8);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MRMSG_DDR, 0x0DC);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MDYNADDR, 0x0E4);
+
+/* MDMA register structure check */
+NPCX_REG_SIZE_CHECK(mdma_reg, 0x03C);
+NPCX_REG_OFFSET_CHECK(mdma_reg, MDMA_SRCB0, 0x004);
+NPCX_REG_OFFSET_CHECK(mdma_reg, MDMA_CTCNT0, 0x018);
+NPCX_REG_OFFSET_CHECK(mdma_reg, MDMA_CTL1, 0x020);
+NPCX_REG_OFFSET_CHECK(mdma_reg, MDMA_CTCNT1, 0x038);
diff --git a/soc/arm/nuvoton_npcx/common/soc_dt.h b/soc/arm/nuvoton_npcx/common/soc_dt.h
index 6bcf2e416..64ddcf5f1 100644
--- a/soc/arm/nuvoton_npcx/common/soc_dt.h
+++ b/soc/arm/nuvoton_npcx/common/soc_dt.h
@@ -80,6 +80,20 @@
 	  .bit  = DT_CLOCKS_CELL_BY_IDX(DT_DRV_INST(inst), i, bit),            \
 	}
 
+/**
+ * @brief Construct a npcx_clk_cfg structure from 'clocks' with the same clock 'name'.
+ *
+ * @param inst instance number for compatible defined in DT_DRV_COMPAT.
+ * @param name name of the clock
+ * @return npcx_clk_cfg item from 'clocks' property with the same clock 'name'
+ */
+#define NPCX_DT_CLK_CFG_ITEM_BY_NAME(inst, name)                               \
+	{                                                                      \
+	  .bus  = DT_CLOCKS_CELL_BY_NAME(DT_DRV_INST(inst), name, bus),        \
+	  .ctrl = DT_CLOCKS_CELL_BY_NAME(DT_DRV_INST(inst), name, ctl),        \
+	  .bit  = DT_CLOCKS_CELL_BY_NAME(DT_DRV_INST(inst), name, bit),        \
+	}
+
 /**
  * @brief Length of 'clocks' property which type is 'phandle-array'
  *
-- 
2.17.1


From 2a0b352a18615152817ef9e37e18e9555c4314ef Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Wed, 8 May 2024 11:20:04 +0800
Subject: [PATCH 41/42] drivers: i3c: npcx: add HDR-DDR mode for transfer

1. Support HDR-DDR DMA transfer.
2. Remove polling mode in transfer.

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/i3c/i3c_npcx.c                    | 185 ++++++++++++++++++----
 soc/arm/nuvoton_npcx/common/reg/reg_def.h |   5 +
 2 files changed, 155 insertions(+), 35 deletions(-)

diff --git a/drivers/i3c/i3c_npcx.c b/drivers/i3c/i3c_npcx.c
index 9790e5939..75b9c73c9 100644
--- a/drivers/i3c/i3c_npcx.c
+++ b/drivers/i3c/i3c_npcx.c
@@ -39,11 +39,14 @@ LOG_MODULE_REGISTER(npcx_i3c, CONFIG_I3C_LOG_LEVEL);
 
 #define MCLKD_FREQ_45_MHZ MHZ(45)
 
-#define I3C_STATUS_CLR_MASK                                                 \
-	(BIT(NPCX_I3C_MSTATUS_TGTSTART) | BIT(NPCX_I3C_MSTATUS_MCTRLDONE) | \
-	 BIT(NPCX_I3C_MSTATUS_COMPLETE) | BIT(NPCX_I3C_MSTATUS_IBIWON) |    \
+#define I3C_STATUS_CLR_MASK                                                                        \
+	(BIT(NPCX_I3C_MSTATUS_TGTSTART) | BIT(NPCX_I3C_MSTATUS_MCTRLDONE) |                        \
+	 BIT(NPCX_I3C_MSTATUS_COMPLETE) | BIT(NPCX_I3C_MSTATUS_IBIWON) |                           \
 	 BIT(NPCX_I3C_MSTATUS_NOWCNTLR))
 
+#define HDR_DDR_CMD_AND_CRC_SZ_WORD 0x2 /* 2 words =  Command(1 word) + CRC(1 word) */
+#define HDR_RD_CMD                  0x80
+
 /* Supported I3C MCLKD frequency */
 enum npcx_i3c_speed {
 	NPCX_I3C_BUS_SPEED_45MHZ,
@@ -217,7 +220,7 @@ static inline void npcx_i3c_interrupt_enable(struct i3c_reg *inst, uint32_t mask
 static bool npcx_i3c_has_error(struct i3c_reg *inst)
 {
 	if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_ERRWARN)) {
-		LOG_WRN("ERROR: MSTATUS 0x%08x MERRWARN 0x%08x", inst->MSTATUS, inst->MERRWARN);
+		LOG_ERR("ERROR: MSTATUS 0x%08x MERRWARN 0x%08x", inst->MSTATUS, inst->MERRWARN);
 
 		return true;
 	}
@@ -314,7 +317,8 @@ static inline int npcx_i3c_request_auto_ibi(struct i3c_reg *inst)
  * param[in] addr     Dyamic address for xfer or 0x7E for CCC command.
  * param[in] op_type  Request type.
  * param[in] is_read  Read(true) or write(false) operation.
- * param[in] read_sz  Read size.
+ * param[in] read_sz  Read size in bytes.
+ *                    If op_tye is HDR-DDR, the read_sz must be the number of words.
  *
  * return  0, success
  *         else, error
@@ -396,6 +400,56 @@ static inline int npcx_i3c_request_emit_stop(struct i3c_reg *inst)
 	return 0;
 }
 
+static inline int npcx_i3c_request_hdr_exit(struct i3c_reg *inst)
+{
+	uint32_t val = 0;
+	uint32_t state;
+	int ret;
+
+	/* Before sending the HDR exit command, check the HDR mode */
+	state = npcx_i3c_state_get(inst);
+	if (state != MSTATUS_STATE_MSGDDR) {
+		LOG_ERR("%s, state error: %#x", __func__, state);
+		return -EPERM;
+	}
+
+	SET_FIELD(val, NPCX_I3C_MCTRL_TYPE, MCTRL_TYPE_HDR_EXIT);
+	SET_FIELD(val, NPCX_I3C_MCTRL_REQUEST, MCTRL_REQUEST_FORCEEXIT);
+
+	ret = npcx_i3c_send_request(inst, val);
+	if (ret != 0) {
+		LOG_ERR("Request hdr exit error %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int npcx_i3c_xfer_stop(struct i3c_reg *inst)
+{
+	uint32_t state;
+	int ret;
+
+	state = npcx_i3c_state_get(inst);
+	LOG_DBG("%s, state=%d", __func__, state);
+
+	switch (state) {
+	case MSTATUS_STATE_NORMACT: /* SDR */
+		ret = npcx_i3c_request_emit_stop(inst);
+		break;
+	case MSTATUS_STATE_MSGDDR:  /* HDR-DDR */
+		ret = npcx_i3c_request_hdr_exit(inst);
+		break;
+	default:
+		/* Not supported */
+		ret = -ENOTSUP;
+		LOG_WRN("xfer_stop state not supported, state:%d", state);
+		break;
+	}
+
+	return ret;
+}
+
 static inline int npcx_i3c_ibi_respond_nack(struct i3c_reg *inst)
 {
 	uint32_t val = 0;
@@ -668,6 +722,7 @@ out_wr_fifo_dma:
 
 /*
  * brief:  Perform DMA read transaction.
+ *         (Data width used for DMA transfers is "byte")
  *
  * For read end, use the MDMA end-of-transfer interrupt(SIEN bit)
  * instead of using the I3CI interrupt generated by COMPLETE bit in MSTATUS register.
@@ -717,6 +772,7 @@ static int npcx_i3c_xfer_read_fifo_dma(const struct device *dev, uint8_t *buf, u
 
 /*
  * brief:  Perform one transfer transaction by DMA.
+ *         (Support SDR and HDR-DDR)
  *
  * param[in] inst        Pointer to controller registers.
  * param[in] addr        Target address.
@@ -731,18 +787,45 @@ static int npcx_i3c_xfer_read_fifo_dma(const struct device *dev, uint8_t *buf, u
  */
 static int npcx_i3c_do_one_xfer_dma(const struct device *dev, uint8_t addr,
 				    enum npcx_i3c_mctrl_type op_type, uint8_t *buf, size_t buf_sz,
-				    bool is_read, bool emit_start, bool emit_stop)
+				    bool is_read, bool emit_start, bool emit_stop, uint8_t hdr_cmd)
 {
 	const struct npcx_i3c_config *config = dev->config;
 	struct i3c_reg *inst = config->base;
 	int ret = 0;
+	bool is_hdr_ddr = (op_type == NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR) ? true : false;
+	size_t rd_len = buf_sz;
 
 	npcx_i3c_status_clear_all(inst);
 	npcx_i3c_errwarn_clear_all(inst);
 
+	/* Check HDR-DDR moves data by words */
+	if (is_hdr_ddr && (buf_sz % 2 != 0)) {
+		LOG_ERR("%s, HDR-DDR data length should be even, len=%#x", __func__, buf_sz);
+		return -EINVAL;
+	}
+
 	/* Emit START if needed */
 	if (emit_start) {
-		ret = npcx_i3c_request_emit_start(inst, addr, op_type, is_read, buf_sz);
+		/*
+		 * For HDR-DDR mode read, RDTERM also includes one word (16 bits) for CRC.
+		 * For example, to read 8 bytes, set RDTERM to 6.
+		 * (1 word HDR-DDR command + 4 words data + 1 word for CRC)
+		 */
+		if (is_hdr_ddr) {
+			if (is_read) {
+				/* The unit of rd_len is "word" in DDR mode */
+				rd_len /= sizeof(uint16_t);    /* byte to word */
+				rd_len += HDR_DDR_CMD_AND_CRC_SZ_WORD;
+				hdr_cmd |= HDR_RD_CMD;
+			} else {
+				hdr_cmd &= ~HDR_RD_CMD;
+			}
+
+			/* Write the command code for the HDR-DDR message */
+			inst->MWDATAB = hdr_cmd;
+		}
+
+		ret = npcx_i3c_request_emit_start(inst, addr, op_type, is_read, rd_len);
 		if (ret != 0) {
 			LOG_ERR("%s: emit start fail", __func__);
 			goto out_do_one_xfer_dma;
@@ -773,9 +856,9 @@ static int npcx_i3c_do_one_xfer_dma(const struct device *dev, uint8_t addr,
 	}
 
 out_do_one_xfer_dma:
-	/* Emit STOP if needed */
+	/* Emit STOP or exit DDR if needed */
 	if (emit_stop) {
-		npcx_i3c_request_emit_stop(inst);
+		npcx_i3c_xfer_stop(inst);
 	}
 
 	return ret;
@@ -784,6 +867,7 @@ out_do_one_xfer_dma:
 
 /*
  * brief:  Perform one transfer transaction.
+ *         (Support SDR only)
  *
  * param[in] inst        Pointer to controller registers.
  * param[in] addr        Target address.
@@ -882,10 +966,12 @@ static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *t
 {
 	const struct npcx_i3c_config *config = dev->config;
 	struct i3c_reg *inst = config->base;
+	struct npcx_i3c_data *data = dev->data;
 	uint32_t intmask;
 	int xfered_len, ret = 0;
 	bool send_broadcast = true;
 	bool is_xfer_done = true;
+	enum npcx_i3c_mctrl_type op_type;
 
 	if (msgs == NULL) {
 		return -EINVAL;
@@ -913,7 +999,6 @@ static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *t
 
 	/* Iterate over all the messages */
 	for (int i = 0; i < num_msgs; i++) {
-
 		/*
 		 * Check message is read or write operaion.
 		 * For write operation, check the last data byte of a transmit message.
@@ -958,35 +1043,63 @@ static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *t
 		}
 #endif
 
-		/*
-		 * Two ways to do read/write transfer .
-		 * 1. [S] + [0x7E]    + [address] + [data] + [Sr or P]
-		 * 2. [S] + [address] + [data]    + [Sr or P]
-		 *
-		 * Send broadcast header(0x7E) on first transfer or after a STOP,
-		 * unless flag is set not to.
-		 */
-		if (!(msgs[i].flags & I3C_MSG_NBCH) && (send_broadcast)) {
-			ret = npcx_i3c_request_emit_start(inst, I3C_BROADCAST_ADDR,
-							  NPCX_I3C_MCTRL_TYPE_I3C, false, 0);
-			if (ret < 0) {
-				LOG_ERR("%s: emit start of broadcast addr failed, error (%d)",
-					__func__, ret);
+		/* Check message SDR or HDR mode */
+		bool is_msg_hdr = (msgs[i].flags & I3C_MSG_HDR) == I3C_MSG_HDR;
+
+		/* Set emit start type SDR or HDR-DDR mode */
+		if (!is_msg_hdr || msgs[i].hdr_mode == 0) {
+			op_type = NPCX_I3C_MCTRL_TYPE_I3C; /* Set operation type SDR */
+
+			/*
+			 * SDR, send boradcast header(0x7E)
+			 *
+			 * Two ways to do read/write transfer (SDR mode).
+			 * 1. [S] + [0x7E]    + [address] + [data] + [Sr or P]
+			 * 2. [S] + [address] + [data]    + [Sr or P]
+			 *
+			 * Send broadcast header(0x7E) on first transfer or after a STOP,
+			 * unless flag is set not to.
+			 */
+			if (!(msgs[i].flags & I3C_MSG_NBCH) && send_broadcast) {
+				ret = npcx_i3c_request_emit_start(inst, I3C_BROADCAST_ADDR,
+								  NPCX_I3C_MCTRL_TYPE_I3C, false,
+								  0);
+				if (ret < 0) {
+					LOG_ERR("%s: emit start of broadcast addr failed, error "
+						"(%d)",
+						__func__, ret);
+					break;
+				}
+				send_broadcast = false;
+			}
+		} else if ((data->common.ctrl_config.supported_hdr & I3C_MSG_HDR_DDR) &&
+			   (msgs[i].hdr_mode == I3C_MSG_HDR_DDR) && is_msg_hdr) {
+
+			op_type = NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR; /* Set operation type DDR */
+
+			/* Check HDR-DDR moves data by words */
+			if ((msgs[i].len % 2) != 0x0) {
+				LOG_ERR("HDR-DDR data length should be number of words , xfer "
+					"len=%d", msgs[i].num_xfer);
+				ret = -EINVAL;
 				break;
 			}
-			send_broadcast = false;
+		} else {
+			LOG_ERR("%s: %s controller HDR Mode %#x\r\n"
+				"msg HDR mode %#x, msg flag %#x",
+				__func__, dev->name, data->common.ctrl_config.supported_hdr,
+				msgs[i].hdr_mode, msgs[i].flags);
+			ret = -ENOTSUP;
+			break;
 		}
 
 #ifdef CONFIG_I3C_NPCX_DMA
 		/* Do transfer with target device */
-		xfered_len = npcx_i3c_do_one_xfer_dma(dev, target->dynamic_addr,
-						      NPCX_I3C_MCTRL_TYPE_I3C, msgs[i].buf,
-						      msgs[i].len, is_read, emit_start, emit_stop);
-#else
-		xfered_len = npcx_i3c_do_one_xfer(inst, target->dynamic_addr,
-						  NPCX_I3C_MCTRL_TYPE_I3C, msgs[i].buf, msgs[i].len,
-						  is_read, emit_start, emit_stop, no_ending);
+		xfered_len = npcx_i3c_do_one_xfer_dma(dev, target->dynamic_addr, op_type,
+						      msgs[i].buf, msgs[i].len, is_read, emit_start,
+						      emit_stop, msgs[i].hdr_cmd_code);
 #endif
+
 		if (xfered_len < 0) {
 			LOG_ERR("%s: do xfer fail", __func__);
 			ret = xfered_len; /* Set error code to ret */
@@ -997,7 +1110,7 @@ static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *t
 		msgs[i].num_xfer = xfered_len;
 
 		if (emit_stop) {
-			/* After a STOP, send broadcast header before next msg */
+			/* SDR. After a STOP, send broadcast header before next msg */
 			send_broadcast = true;
 		}
 
@@ -1009,7 +1122,7 @@ static int npcx_i3c_transfer(const struct device *dev, struct i3c_device_desc *t
 
 	/* Emit stop if error occurs or stop flag not in the msg */
 	if ((ret != 0) || (is_xfer_done == false)) {
-		npcx_i3c_request_emit_stop(inst);
+		npcx_i3c_xfer_stop(inst);
 	}
 
 	npcx_i3c_errwarn_clear_all(inst);
@@ -1681,6 +1794,8 @@ static void npcx_i3c_isr(const struct device *dev)
 #ifdef CONFIG_I3C_USE_IBI
 	/* Target start detected */
 	if (IS_BIT_SET(inst->MSTATUS, NPCX_I3C_MSTATUS_TGTSTART)) {
+		LOG_DBG("ISR TGTSTART !");
+
 		/* Disable further target initiated IBI interrupt */
 		inst->MINTCLR = BIT(NPCX_I3C_MINTCLR_TGTSTART);
 
@@ -1958,7 +2073,7 @@ static int npcx_i3c_init(const struct device *dev)
 	}
 
 	ctrl_config->is_secondary = false; /* Currently can only act as primary controller. */
-	ctrl_config->supported_hdr = 0U;   /* HDR mode not supported at the moment. */
+	ctrl_config->supported_hdr = I3C_MSG_HDR_DDR; /* HDR-DDR mode is supported. */
 	ctrl_config->scl.i3c = config->clocks.i3c_pp_scl_hz; /* Set I3C frequency */
 
 	ret = npcx_i3c_configure(dev, I3C_CONFIG_CONTROLLER, ctrl_config);
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index 78abce3c6..f4e13d952 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -1903,12 +1903,17 @@ struct i3c_reg {
 #define MCTRL_IBIRESP_ACK_MANDATORY 2 /* ACK with mandatory byte  */
 #define MCTRL_IBIRESP_MANUAL        3
 
+/* For REQUEST = EmitStartAddr */
 enum npcx_i3c_mctrl_type {
 	NPCX_I3C_MCTRL_TYPE_I3C,
 	NPCX_I3C_MCTRL_TYPE_I2C,
 	NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR,
 };
 
+/* For REQUEST = ForceExit/Target Reset */
+#define MCTRL_TYPE_HDR_EXIT    0
+#define MCTRL_TYPE_TGT_RESTART 2
+
 /* MSTATUS options */
 #define MSTATUS_STATE_IDLE    0x0
 #define MSTATUS_STATE_TGTREQ  0x1
-- 
2.17.1


From 65ddbce7d22be1f88e65c489927d9269ba709fcb Mon Sep 17 00:00:00 2001
From: Alvis Sun <yfsun@nuvoton.com>
Date: Mon, 7 Oct 2024 18:26:53 +0800
Subject: [PATCH 42/42] soc: nuvoton: reg: add i3c target registers and soc
 functions

As title.

Signed-off-by: Alvis Sun <yfsun@nuvoton.com>
---
 drivers/i3c/i3c_npcx.c                    |  73 +++
 include/zephyr/drivers/i3c/i3c_npcx.h     |  55 +++
 soc/arm/nuvoton_npcx/common/reg/reg_def.h | 536 ++++++++++++++++------
 soc/arm/nuvoton_npcx/common/registers.c   |  14 +-
 soc/arm/nuvoton_npcx/common/scfg.c        |  15 +
 soc/arm/nuvoton_npcx/common/soc_pins.h    |   9 +
 6 files changed, 556 insertions(+), 146 deletions(-)
 create mode 100644 include/zephyr/drivers/i3c/i3c_npcx.h

diff --git a/drivers/i3c/i3c_npcx.c b/drivers/i3c/i3c_npcx.c
index 75b9c73c9..69fc158a1 100644
--- a/drivers/i3c/i3c_npcx.c
+++ b/drivers/i3c/i3c_npcx.c
@@ -21,6 +21,79 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(npcx_i3c, CONFIG_I3C_LOG_LEVEL);
 
+/* MCONFIG options */
+#define MCONFIG_CTRENA_OFF        0x0
+#define MCONFIG_CTRENA_ON         0x1
+#define MCONFIG_CTRENA_CAPABLE    0x2
+#define MCONFIG_HKEEP_EXT_SDA_SCL 0x3
+
+/* MCTRL options */
+#define MCTRL_REQUEST_NONE          0 /* None */
+#define MCTRL_REQUEST_EMITSTARTADDR 1 /* Emit a START */
+#define MCTRL_REQUEST_EMITSTOP      2 /* Emit a STOP */
+#define MCTRL_REQUEST_IBIACKNACK    3 /* Manually ACK or NACK an IBI */
+#define MCTRL_REQUEST_PROCESSDAA    4 /* Starts the DAA process */
+#define MCTRL_REQUEST_FORCEEXIT     6 /* Emit HDR Exit Pattern  */
+/* Emits a START with address 7Eh when a slave pulls I3C_SDA low to request an IBI */
+#define MCTRL_REQUEST_AUTOIBI       7
+
+/* ACK with mandatory byte determined by IBIRULES or ACK with no mandatory byte */
+#define MCTRL_IBIRESP_ACK           0
+#define MCTRL_IBIRESP_NACK          1 /* NACK */
+#define MCTRL_IBIRESP_ACK_MANDATORY 2 /* ACK with mandatory byte  */
+#define MCTRL_IBIRESP_MANUAL        3
+
+/* For REQUEST = EmitStartAddr */
+enum npcx_i3c_mctrl_type {
+	NPCX_I3C_MCTRL_TYPE_I3C,
+	NPCX_I3C_MCTRL_TYPE_I2C,
+	NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR,
+};
+
+/* For REQUEST = ForceExit/Target Reset */
+#define MCTRL_TYPE_HDR_EXIT    0
+#define MCTRL_TYPE_TGT_RESTART 2
+
+/* MSTATUS options */
+#define MSTATUS_STATE_IDLE    0x0
+#define MSTATUS_STATE_TGTREQ  0x1
+#define MSTATUS_STATE_NORMACT 0x3 /* SDR message mode */
+#define MSTATUS_STATE_MSGDDR  0x4
+#define MSTATUS_STATE_DAA     0x5
+#define MSTATUS_STATE_IBIACK  0x6
+#define MSTATUS_STATE_IBIRCV  0x7
+#define MSTATUS_IBITYPE_NONE  0x0
+#define MSTATUS_IBITYPE_IBI   0x1
+#define MSTATUS_IBITYPE_CR    0x2
+#define MSTATUS_IBITYPE_HJ    0x3
+
+/* IBIRULES */
+#define IBIRULES_ADDR_MSK   0x3F
+#define IBIRULES_ADDR_SHIFT 0x6
+
+/* MDMACTRL options */
+#define MDMA_DMAFB_DISABLE      0x0
+#define MDMA_DMAFB_EN_ONE_FRAME 0x1
+#define MDMA_DMAFB_EN_MANUAL    0x2
+#define MDMA_DMATB_DISABLE      0x0
+#define MDMA_DMATB_EN_ONE_FRAME 0x1
+#define MDMA_DMATB_EN_MANUAL    0x2
+
+/* CTRL options */
+#define CTRL_EVENT_NORMAL    0
+#define CTRL_EVENT_IBI       1
+#define CTRL_EVENT_CNTLR_REQ 2
+#define CTRL_EVENT_HJ        3
+
+/* STATUS options */
+#define STATUS_EVDET_NONE            0
+#define STATUS_EVDET_REQ_NOT_SENT    1
+#define STATUS_EVDET_REQ_SENT_NACKED 2
+#define STATUS_EVDET_REQ_SENT_ACKED  3
+
+/*******************************************************************************
+ * Local Constants Definition
+ ******************************************************************************/
 #define NPCX_I3C_CHK_TIMEOUT_US 10000 /* Timeout for checking register status */
 #define I3C_SCL_PP_FREQ_MAX_MHZ 12500000
 #define I3C_SCL_OD_FREQ_MAX_MHZ 4170000
diff --git a/include/zephyr/drivers/i3c/i3c_npcx.h b/include/zephyr/drivers/i3c/i3c_npcx.h
new file mode 100644
index 000000000..2bd546e8e
--- /dev/null
+++ b/include/zephyr/drivers/i3c/i3c_npcx.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2020 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_DRIVERS_I3C_I3C_NPCX_H_
+#define ZEPHYR_DRIVERS_I3C_I3C_NPCX_H_
+
+#include <zephyr/device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef CONFIG_I3C_NPCX_DMA
+
+/**
+ * @brief Configures the application's buffer for use in MDMA mode.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param mdma_rd_buf Pointer to storage for read data
+ * @param mdma_rd_buf_size Length of the buffer to storage for read data
+ * @param mdma_wr_buf Pointer to the data to be written
+ * @param mdma_wr_buf_size Length of the buffer to be written
+ */
+void npcx_i3c_target_set_mdma_buff(const struct device *dev, uint8_t *mdma_rd_buf,
+				   uint16_t mdma_rd_buf_size, uint8_t *mdma_wr_buf,
+				   uint16_t mdma_wr_buf_size);
+
+/**
+ * @brief Retrieves the count of data received via MDMA.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ *
+ * @return The number of data bytes read from the bus.
+ */
+uint16_t npcx_i3c_target_get_mdmafb_count(const struct device *dev);
+
+/**
+ * @brief Retrieves the count of data written to the bus via MDMA.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ *
+ * @return The number of data bytes written to the bus.
+ */
+uint16_t npcx_i3c_target_get_mdmatb_count(const struct device *dev);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_DRIVERS_I3C_I3C_NPCX_H_ */
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index f4e13d952..08deaaa3c 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -213,16 +213,19 @@ struct scfg_reg {
 	volatile uint8_t STRPST;
 	/* 0x002: Reset Control and Status */
 	volatile uint8_t RSTCTL;
-	volatile uint8_t reserved1[3];
+	volatile uint8_t reserved1;
+	/* 0x004: Device Control 3*/
+	volatile uint8_t DEV_CTL3;
+	volatile uint8_t reserved2;
 	/* 0x006: Device Control 4 */
 	volatile uint8_t DEV_CTL4;
-	volatile uint8_t reserved2[9];
+	volatile uint8_t reserved3[9];
 	/* 0x010 - 1F: Device Alternate Function 0 - F */
 	volatile uint8_t DEVALT0[16];
-	volatile uint8_t reserved3[6];
+	volatile uint8_t reserved4[6];
 	/* 0x026: Low-Voltage GPIO Pins Control 5 */
 	volatile uint8_t LV_GPIO_CTL5[1];
-	volatile uint8_t reserved4;
+	volatile uint8_t reserved5;
 	/* 0x028: Pull-Up/Pull-Down Enable 0 */
 	volatile uint8_t PUPD_EN0;
 	/* 0x029: Pull-Up/Pull-Down Enable 1 */
@@ -258,6 +261,12 @@ struct scfg_reg {
 #define NPCX_RSTCTL_VCC1_RST_SCRATCH          3
 #define NPCX_RSTCTL_LRESET_PLTRST_MODE        5
 #define NPCX_RSTCTL_HIPRST_MODE               6
+#define NPCX_DEV_CTL3_RNGINT_MD               1
+#define NPCX_DEV_CTL3_FVCC1_PURST_EN          2
+#define NPCX_DEV_CTL3_I3C1_MS                 3
+#define NPCX_DEV_CTL3_I3C2_MS                 4
+#define NPCX_DEV_CTL3_I3C3_MS                 5
+#define NPCX_DEV_CTL3_SIO_CLK_SEL             FIELD(6, 2)
 #define NPCX_DEV_CTL4_F_SPI_SLLK              2
 #define NPCX_DEV_CTL4_SPI_SP_SEL              4
 #define NPCX_DEV_CTL4_WP_IF                   5
@@ -269,6 +278,11 @@ struct scfg_reg {
 #define NPCX_DEVPU0_I2C3_0_PUE                6
 #define NPCX_DEVPU1_F_SPI_PUD_EN              7
 
+#if defined(CONFIG_SOC_SERIES_NPCX4)
+/* I3C module controller, target mode for the MDMA module operation */
+#define NPCX_DEV_CTL3_I3C_MODE_BIT(inst_id) BIT(inst_id + 3)
+#endif /* End of CONFIG_SOC_SERIES_NPCX4 */
+
 /* Supported host interface type for HIF_TYP_SEL FILED in DEVCNT register. */
 enum npcx_hif_type {
 	NPCX_HIF_TYPE_NONE,
@@ -276,6 +290,14 @@ enum npcx_hif_type {
 	NPCX_HIF_TYPE_ESPI_SHI,
 };
 
+/* Supported VOSCCLK frequency for SIO_CLK_SEL FILED in DEV_CTL3 register. */
+enum npcx_voscclk_type {
+	NPCX_VOSCCLK_96MHz,
+	NPCX_VOSCCLK_100MHz,
+	NPCX_VOSCCLK_120MHz,
+	NPCX_VOSCCLK_90MHz,
+};
+
 /*
  * System Glue (GLUE) device registers
  */
@@ -1766,7 +1788,60 @@ struct i3c_reg {
 	volatile uint32_t MCONFIG;
 	/* 0x004: Target Configuration */
 	volatile uint32_t CONFIG;
-	volatile uint32_t reserved1[31];
+	/* 0x008: Target Status */
+	volatile uint32_t STATUS;
+	/* 0x00C: Target Control  */
+	volatile uint32_t CTRL;
+	/* 0x010: Target Interrupt Enable Set  */
+	volatile uint32_t INTSET;
+	/* 0x014: Target Interrupt Enable Clear */
+	volatile uint32_t INTCLR;
+	/* 0x018: Target Interrupt Masked */
+	volatile uint32_t INTMASKED;
+	/* 0x01C: Target Error and Warning */
+	volatile uint32_t ERRWARN;
+	/* 0x020: Target DMA Control */
+	volatile uint32_t DMACTRL;
+	/* 0x024-0x02B: reserved */
+	volatile uint32_t reserved0[2];
+	/* 0x02C: Target Data Control */
+	volatile uint32_t DATACTRL;
+	/* 0x030: Target Write Byte Data */
+	volatile uint32_t WDATAB;
+	/* 0x034: Target Write Byte Data as End */
+	volatile uint32_t WDATABE;
+	/* 0x038: Target Write Half-Word Data */
+	volatile uint32_t WDATAH;
+	/* 0x03C: Target Write Half-Word Data as End */
+	volatile uint32_t WDATAHE;
+	/* 0x040: Target Read Byte Data */
+	volatile uint32_t RDATAB;
+	/* 0x044: reserved */
+	volatile uint32_t reserved1;
+	/* 0x048: Target Read Half-Word Data */
+	volatile uint32_t RDATAH;
+	/* 0x04C-0x05B: reserved */
+	volatile uint32_t reserved2[4];
+	/* 0x05C: Target Capabilities 2 */
+	volatile uint32_t CCAPABILITIES2;
+	/* 0x060: Target Capabilities */
+	volatile uint32_t CCAPABILITIES;
+	/* 0x064: Target Dynamic Address */
+	volatile uint32_t DYNADDR;
+	/* 0x068: Target Maximum Limits */
+	volatile uint32_t MAXLIMITS;
+	/* 0x06C: Target Part Number */
+	volatile uint32_t PARTNO;
+	/* 0x070: Target ID Extension */
+	volatile uint32_t IDEXT;
+	/* 0x074: Target Vendor ID */
+	volatile uint32_t VENDORID;
+	/* 0x078: Target Timing Control Clock */
+	volatile uint32_t TCCLOCK;
+	/* 0x07C: Target Matching Address Index */
+	volatile uint32_t MSGLAST;
+	/* 0x080: reserved */
+	volatile uint32_t reserved3;
 	/* 0x084: Controller Control  */
 	volatile uint32_t MCTRL;
 	/* 0x088: Controller Status */
@@ -1783,7 +1858,8 @@ struct i3c_reg {
 	volatile uint32_t MERRWARN;
 	/* 0x0A0: Controller DMA Control */
 	volatile uint32_t MDMACTRL;
-	volatile uint32_t reserved2[2];
+	/* 0x0A0-0x0AB: reserved */
+	volatile uint32_t reserved4[2];
 	/* 0x0AC: Controller Data Control */
 	volatile uint32_t MDATACTRL;
 	/* 0x0B0: Controller Write Byte Data */
@@ -1796,148 +1872,315 @@ struct i3c_reg {
 	volatile uint32_t MWDATAHE;
 	/* 0x0C0: Controller Read Byte Data */
 	volatile uint32_t MRDATAB;
-	volatile uint32_t reserved3;
+	/* 0x0C4: reserved */
+	volatile uint32_t reserved5;
 	/* 0x0C8: Controller Read Half-Word Data */
 	volatile uint32_t MRDATAH;
-	volatile uint32_t reserved4[3];
+	/* 0x0CC-0x0D7: reserved */
+	volatile uint32_t reserved6[3];
 	/* 0x0D8: Start or Continue DDR Message */
 	volatile uint32_t MWMSG_DDR;
 	/* 0x0DC: Read DDR Message Data */
 	volatile uint32_t MRMSG_DDR;
-	volatile uint32_t reserved5;
+	/* 0x0E0: reserved */
+	volatile uint32_t reserved7;
 	/* 0x0E4: Controller Dynamic Address */
 	volatile uint32_t MDYNADDR;
+	/* 0x0E8-0x0FF reserved */
+	volatile uint32_t reserved8[6];
+	/* 0x100: Target Reset Recovery Time */
+	volatile uint32_t RSTACTTIME;
+	/* 0x104: reserved */
+	volatile uint32_t reserved9;
+	/* 0x108: Target HDR Command Byte */
+	volatile uint32_t HDRCMD;
+	/* 0x10C-0x113: reserved */
+	volatile uint32_t reserved10[2];
+	/* 0x114: Target Group Definition */
+	volatile uint32_t GROUPDEF;
+	/* 0x118: reserved */
+	volatile uint32_t reserved11;
+	/* 0x11C: Target Map Control 0 */
+	volatile uint32_t MAPCTRL0;
+	/* 0x120: Target Map Control 1 */
+	volatile uint32_t MAPCTRL1;
+	/* 0x124: Target Map Control 2 */
+	volatile uint32_t MAPCTRL2;
+	/* 0x128: Target Map Control 3 */
+	volatile uint32_t MAPCTRL3;
+	/* 0x12C: Target Map Control 4 */
+	volatile uint32_t MAPCTRL4;
+	/* 0x130: Target Map Control 5 */
+	volatile uint32_t MAPCTRL5;
+	/* 0x134: Target Map Control 6 */
+	volatile uint32_t MAPCTRL6;
+	/* 0x138: Target Map Control 7 */
+	volatile uint32_t MAPCTRL7;
+	/* 0x13C: Target Map Control 8 */
+	volatile uint32_t MAPCTRL8;
+	/* 0x140: Target Extended IBI Data 1 */
+	volatile uint32_t IBIEXT1;
+	/* 0x144: Target Extended IBI Data 2 */
+	volatile uint32_t IBIEXT2;
 };
 
-/* I3C register fields */
-#define NPCX_I3C_CONFIG_BAMATCH    FIELD(16, 7)
-#define NPCX_I3C_MCONFIG_CTRENA    FIELD(0, 2)
-#define NPCX_I3C_MCONFIG_DISTO     3
-#define NPCX_I3C_MCONFIG_HKEEP     FIELD(4, 2) /* Must be '11' */
-#define NPCX_I3C_MCONFIG_ODSTOP    6
-#define NPCX_I3C_MCONFIG_PPBAUD    FIELD(8, 4)
-#define NPCX_I3C_MCONFIG_PPLOW     FIELD(12, 4)
-#define NPCX_I3C_MCONFIG_ODBAUD    FIELD(16, 8)
-#define NPCX_I3C_MCONFIG_ODHPP     24
-#define NPCX_I3C_MCONFIG_SKEW      FIELD(25, 3)
-#define NPCX_I3C_MCONFIG_I2CBAUD   FIELD(28, 4)
-#define NPCX_I3C_MCTRL_REQUEST     FIELD(0, 3)
-#define NPCX_I3C_MCTRL_TYPE        FIELD(4, 2)
-#define NPCX_I3C_MCTRL_IBIRESP     FIELD(6, 2)
-#define NPCX_I3C_MCTRL_DIR         8
-#define NPCX_I3C_MCTRL_ADDR        FIELD(9, 7)
-#define NPCX_I3C_MCTRL_RDTERM      FIELD(16, 8)
-#define NPCX_I3C_MSTATUS_STATE     FIELD(0, 3)
-#define NPCX_I3C_MSTATUS_BETWEEN   4
-#define NPCX_I3C_MSTATUS_NACKED    5
-#define NPCX_I3C_MSTATUS_IBITYPE   FIELD(6, 2)
-#define NPCX_I3C_MSTATUS_TGTSTART  8
-#define NPCX_I3C_MSTATUS_MCTRLDONE 9
-#define NPCX_I3C_MSTATUS_COMPLETE  10
-#define NPCX_I3C_MSTATUS_RXPEND    11
-#define NPCX_I3C_MSTATUS_TXNOTFULL 12
-#define NPCX_I3C_MSTATUS_IBIWON    13
-#define NPCX_I3C_MSTATUS_ERRWARN   15
-#define NPCX_I3C_MSTATUS_NOWCNTLR  19
-#define NPCX_I3C_MSTATUS_IBIADDR   FIELD(24, 7)
-#define NPCX_I3C_IBIRULES_MSB0     30
-#define NPCX_I3C_IBIRULES_NOBYTE   31
-#define NPCX_I3C_MINTSET_TGTSTART  8
-#define NPCX_I3C_MINTSET_MCTRLDONE 9
-#define NPCX_I3C_MINTSET_COMPLETE  10
-#define NPCX_I3C_MINTSET_RXPEND    11
-#define NPCX_I3C_MINTSET_TXNOTFULL 12
-#define NPCX_I3C_MINTSET_IBIWON    13
-#define NPCX_I3C_MINTSET_ERRWARN   15
-#define NPCX_I3C_MINTSET_NOWCNTLR  19
-#define NPCX_I3C_MINTCLR_TGTSTART  8
-#define NPCX_I3C_MINTCLR_MCTRLDONE 9
-#define NPCX_I3C_MINTCLR_COMPLETE  10
-#define NPCX_I3C_MINTCLR_RXPEND    11
-#define NPCX_I3C_MINTCLR_TXNOTFULL 12
-#define NPCX_I3C_MINTCLR_IBIWON    13
-#define NPCX_I3C_MINTCLR_ERRWARN   15
-#define NPCX_I3C_MINTCLR_NOWCNTLR  19
-#define NPCX_I3C_MDATACTRL_FLUSHTB 0
-#define NPCX_I3C_MDATACTRL_FLUSHFB 1
-#define NPCX_I3C_MDATACTRL_UNLOCK  3
-#define NPCX_I3C_MDATACTRL_TXTRIG  FIELD(4, 2)
-#define NPCX_I3C_MDATACTRL_RXTRIG  FIELD(6, 2)
-#define NPCX_I3C_MDATACTRL_TXCOUNT FIELD(16, 5)
-#define NPCX_I3C_MDATACTRL_RXCOUNT FIELD(24, 5)
-#define NPCX_I3C_MDATACTRL_TXFULL  30
-#define NPCX_I3C_MDATACTRL_RXEMPTY 31
-#define NPCX_I3C_MERRWARN_NACK     2
-#define NPCX_I3C_MERRWARN_WRABT    3
-#define NPCX_I3C_MERRWARN_TERM     4
-#define NPCX_I3C_MERRWARN_HPAR     9
-#define NPCX_I3C_MERRWARN_HCRC     10
-#define NPCX_I3C_MERRWARN_OREAD    16
-#define NPCX_I3C_MERRWARN_OWRITE   17
-#define NPCX_I3C_MERRWARN_MSGERR   18
-#define NPCX_I3C_MERRWARN_INVERQ   19
-#define NPCX_I3C_MERRWARN_TIMEOUT  20
-#define NPCX_I3C_MDMACTRL_DMAFB    FIELD(0, 2)
-#define NPCX_I3C_MDMACTRL_DMATB    FIELD(2, 2)
-
-
-/* MCONFIG options */
-#define MCONFIG_CTRENA_OFF        0x0
-#define MCONFIG_CTRENA_ON         0x1
-#define MCONFIG_CTRENA_CAPABLE    0x2
-#define MCONFIG_HKEEP_EXT_SDA_SCL 0x3
-
-/* MCTRL options */
-#define MCTRL_REQUEST_NONE          0 /* None */
-#define MCTRL_REQUEST_EMITSTARTADDR 1 /* Emit a START */
-#define MCTRL_REQUEST_EMITSTOP      2 /* Emit a STOP */
-#define MCTRL_REQUEST_IBIACKNACK    3 /* Manually ACK or NACK an IBI */
-#define MCTRL_REQUEST_PROCESSDAA    4 /* Starts the DAA process */
-#define MCTRL_REQUEST_FORCEEXIT     6 /* Emit HDR Exit Pattern  */
-/* Emits a START with address 7Eh when a slave pulls I3C_SDA low to request an IBI */
-#define MCTRL_REQUEST_AUTOIBI       7
-
-/* ACK with mandatory byte determined by IBIRULES or ACK with no mandatory byte */
-#define MCTRL_IBIRESP_ACK           0
-#define MCTRL_IBIRESP_NACK          1 /* NACK */
-#define MCTRL_IBIRESP_ACK_MANDATORY 2 /* ACK with mandatory byte  */
-#define MCTRL_IBIRESP_MANUAL        3
-
-/* For REQUEST = EmitStartAddr */
-enum npcx_i3c_mctrl_type {
-	NPCX_I3C_MCTRL_TYPE_I3C,
-	NPCX_I3C_MCTRL_TYPE_I2C,
-	NPCX_I3C_MCTRL_TYPE_I3C_HDR_DDR,
-};
-
-/* For REQUEST = ForceExit/Target Reset */
-#define MCTRL_TYPE_HDR_EXIT    0
-#define MCTRL_TYPE_TGT_RESTART 2
-
-/* MSTATUS options */
-#define MSTATUS_STATE_IDLE    0x0
-#define MSTATUS_STATE_TGTREQ  0x1
-#define MSTATUS_STATE_NORMACT 0x3 /* SDR message mode */
-#define MSTATUS_STATE_MSGDDR  0x4
-#define MSTATUS_STATE_DAA     0x5
-#define MSTATUS_STATE_IBIACK  0x6
-#define MSTATUS_STATE_IBIRCV  0x7
-#define MSTATUS_IBITYPE_NONE  0x0
-#define MSTATUS_IBITYPE_IBI   0x1
-#define MSTATUS_IBITYPE_CR    0x2
-#define MSTATUS_IBITYPE_HJ    0x3
-
-/* IBIRULES */
-#define IBIRULES_ADDR_MSK   0x3F
-#define IBIRULES_ADDR_SHIFT 0x6
-
-/* MDMACTRL options */
-#define MDMA_DMAFB_DISABLE      0x0
-#define MDMA_DMAFB_EN_ONE_FRAME 0x1
-#define MDMA_DMAFB_EN_MANUAL    0x2
-#define MDMA_DMATB_DISABLE      0x0
-#define MDMA_DMATB_EN_ONE_FRAME 0x1
-#define MDMA_DMATB_EN_MANUAL    0x2
+/* I3C controller register fields */
+#define NPCX_I3C_MCONFIG_CTRENA         FIELD(0, 2)
+#define NPCX_I3C_MCONFIG_DISTO          3
+#define NPCX_I3C_MCONFIG_HKEEP          FIELD(4, 2) /* Must be '11' */
+#define NPCX_I3C_MCONFIG_ODSTOP         6
+#define NPCX_I3C_MCONFIG_PPBAUD         FIELD(8, 4)
+#define NPCX_I3C_MCONFIG_PPLOW          FIELD(12, 4)
+#define NPCX_I3C_MCONFIG_ODBAUD         FIELD(16, 8)
+#define NPCX_I3C_MCONFIG_ODHPP          24
+#define NPCX_I3C_MCONFIG_SKEW           FIELD(25, 3)
+#define NPCX_I3C_MCONFIG_I2CBAUD        FIELD(28, 4)
+#define NPCX_I3C_MCTRL_REQUEST          FIELD(0, 3)
+#define NPCX_I3C_MCTRL_TYPE             FIELD(4, 2)
+#define NPCX_I3C_MCTRL_IBIRESP          FIELD(6, 2)
+#define NPCX_I3C_MCTRL_DIR              8
+#define NPCX_I3C_MCTRL_ADDR             FIELD(9, 7)
+#define NPCX_I3C_MCTRL_RDTERM           FIELD(16, 8)
+#define NPCX_I3C_MSTATUS_STATE          FIELD(0, 3)
+#define NPCX_I3C_MSTATUS_BETWEEN        4
+#define NPCX_I3C_MSTATUS_NACKED         5
+#define NPCX_I3C_MSTATUS_IBITYPE        FIELD(6, 2)
+#define NPCX_I3C_MSTATUS_TGTSTART       8
+#define NPCX_I3C_MSTATUS_MCTRLDONE      9
+#define NPCX_I3C_MSTATUS_COMPLETE       10
+#define NPCX_I3C_MSTATUS_RXPEND         11
+#define NPCX_I3C_MSTATUS_TXNOTFULL      12
+#define NPCX_I3C_MSTATUS_IBIWON         13
+#define NPCX_I3C_MSTATUS_ERRWARN        15
+#define NPCX_I3C_MSTATUS_NOWCNTLR       19
+#define NPCX_I3C_MSTATUS_IBIADDR        FIELD(24, 7)
+#define NPCX_I3C_IBIRULES_MSB0          30
+#define NPCX_I3C_IBIRULES_NOBYTE        31
+#define NPCX_I3C_MINTSET_TGTSTART       8
+#define NPCX_I3C_MINTSET_MCTRLDONE      9
+#define NPCX_I3C_MINTSET_COMPLETE       10
+#define NPCX_I3C_MINTSET_RXPEND         11
+#define NPCX_I3C_MINTSET_TXNOTFULL      12
+#define NPCX_I3C_MINTSET_IBIWON         13
+#define NPCX_I3C_MINTSET_ERRWARN        15
+#define NPCX_I3C_MINTSET_NOWCNTLR       19
+#define NPCX_I3C_MINTCLR_TGTSTART       8
+#define NPCX_I3C_MINTCLR_MCTRLDONE      9
+#define NPCX_I3C_MINTCLR_COMPLETE       10
+#define NPCX_I3C_MINTCLR_RXPEND         11
+#define NPCX_I3C_MINTCLR_TXNOTFULL      12
+#define NPCX_I3C_MINTCLR_IBIWON         13
+#define NPCX_I3C_MINTCLR_ERRWARN        15
+#define NPCX_I3C_MINTCLR_NOWCNTLR       19
+#define NPCX_I3C_MINTMASKED_NOWCNTLR    19
+#define NPCX_I3C_MDATACTRL_FLUSHTB      0
+#define NPCX_I3C_MDATACTRL_FLUSHFB      1
+#define NPCX_I3C_MDATACTRL_UNLOCK       3
+#define NPCX_I3C_MDATACTRL_TXTRIG       FIELD(4, 2)
+#define NPCX_I3C_MDATACTRL_RXTRIG       FIELD(6, 2)
+#define NPCX_I3C_MDATACTRL_TXCOUNT      FIELD(16, 5)
+#define NPCX_I3C_MDATACTRL_RXCOUNT      FIELD(24, 5)
+#define NPCX_I3C_MDATACTRL_TXFULL       30
+#define NPCX_I3C_MDATACTRL_RXEMPTY      31
+#define NPCX_I3C_MERRWARN_NACK          2
+#define NPCX_I3C_MERRWARN_WRABT         3
+#define NPCX_I3C_MERRWARN_TERM          4
+#define NPCX_I3C_MERRWARN_HPAR          9
+#define NPCX_I3C_MERRWARN_HCRC          10
+#define NPCX_I3C_MERRWARN_OREAD         16
+#define NPCX_I3C_MERRWARN_OWRITE        17
+#define NPCX_I3C_MERRWARN_MSGERR        18
+#define NPCX_I3C_MERRWARN_INVERQ        19
+#define NPCX_I3C_MERRWARN_TIMEOUT       20
+#define NPCX_I3C_MDMACTRL_DMAFB         FIELD(0, 2)
+#define NPCX_I3C_MDMACTRL_DMATB         FIELD(2, 2)
+
+/* I3C target register fields */
+#define NPCX_I3C_CONFIG_TGTENA          0
+#define NPCX_I3C_CONFIG_MATCHSS         2
+#define NPCX_I3C_CONFIG_S0IGNORE        3
+#define NPCX_I3C_CONFIG_IDRAND          8
+#define NPCX_I3C_CONFIG_OFFLINE         9
+#define NPCX_I3C_CONFIG_HDRCMD          FIELD(10, 2)
+#define NPCX_I3C_CONFIG_BAMATCH         FIELD(16, 7)
+#define NPCX_I3C_CONFIG_SADDR           FIELD(25, 7)
+#define NPCX_I3C_STATUS_STNOTSTOP       0
+#define NPCX_I3C_STATUS_STMSG           1
+#define NPCX_I3C_STATUS_STCCCH          2
+#define NPCX_I3C_STATUS_STREQRD         3
+#define NPCX_I3C_STATUS_STREQWR         4
+#define NPCX_I3C_STATUS_STDAA           5
+#define NPCX_I3C_STATUS_STHDR           6
+#define NPCX_I3C_STATUS_START           8
+#define NPCX_I3C_STATUS_MATCHED         9
+#define NPCX_I3C_STATUS_STOP            10
+#define NPCX_I3C_STATUS_RXPEND          11
+#define NPCX_I3C_STATUS_TXNOTFULL       12
+#define NPCX_I3C_STATUS_DACHG           13
+#define NPCX_I3C_STATUS_CCC             14
+#define NPCX_I3C_STATUS_ERRWARN         15
+#define NPCX_I3C_STATUS_HDRMATCH        16
+#define NPCX_I3C_STATUS_CHANDLED        17
+#define NPCX_I3C_STATUS_EVENT           18
+#define NPCX_I3C_STATUS_TGTRST          19
+#define NPCX_I3C_STATUS_EVDET           FIELD(20, 2)
+#define NPCX_I3C_STATUS_IBIDIS          24
+#define NPCX_I3C_STATUS_MRDIS           25
+#define NPCX_I3C_STATUS_HJDIS           27
+#define NPCX_I3C_STATUS_ACTSTATE        FIELD(28, 2)
+#define NPCX_I3C_STATUS_TIMECTRL        FIELD(30, 2)
+#define NPCX_I3C_CTRL_EVENT             FIELD(0, 2)
+#define NPCX_I3C_CTRL_EXTDATA           3
+#define NPCX_I3C_CTRL_MAPIDX            FIELD(4, 4)
+#define NPCX_I3C_CTRL_IBIDATA           FIELD(8, 8)
+#define NPCX_I3C_CTRL_PENDINT           FIELD(16, 4)
+#define NPCX_I3C_CTRL_ACTSTATE          FIELD(20, 2)
+#define NPCX_I3C_CTRL_VENDINFO          FIELD(24, 8)
+#define NPCX_I3C_INTSET_START           8
+#define NPCX_I3C_INTSET_MATCHED         9
+#define NPCX_I3C_INTSET_STOP            10
+#define NPCX_I3C_INTSET_RXPEND          11
+#define NPCX_I3C_INTSET_TXNOTFULL       12
+#define NPCX_I3C_INTSET_DACHG           13
+#define NPCX_I3C_INTSET_CCC             14
+#define NPCX_I3C_INTSET_ERRWARN         15
+#define NPCX_I3C_INTSET_HDRMATCH        16
+#define NPCX_I3C_INTSET_CHANDLED        17
+#define NPCX_I3C_INTSET_EVENT           18
+#define NPCX_I3C_INTSET_TGTRST          19
+#define NPCX_I3C_INTCLR_START           8
+#define NPCX_I3C_INTCLR_MATCHED         9
+#define NPCX_I3C_INTCLR_STOP            10
+#define NPCX_I3C_INTCLR_RXPEND          11
+#define NPCX_I3C_INTCLR_TXNOTFULL       12
+#define NPCX_I3C_INTCLR_DACHG           13
+#define NPCX_I3C_INTCLR_CCC             14
+#define NPCX_I3C_INTCLR_ERRWARN         15
+#define NPCX_I3C_INTCLR_HDRMATCH        16
+#define NPCX_I3C_INTCLR_CHANDLED        17
+#define NPCX_I3C_INTCLR_EVENT           18
+#define NPCX_I3C_INTCLR_TGTRST          19
+#define NPCX_I3C_INTMASKED_START        8
+#define NPCX_I3C_INTMASKED_MATCHED      9
+#define NPCX_I3C_INTMASKED_STOP         10
+#define NPCX_I3C_INTMASKED_RXPEND       11
+#define NPCX_I3C_INTMASKED_TXNOTFULL    12
+#define NPCX_I3C_INTMASKED_DACHG        13
+#define NPCX_I3C_INTMASKED_CCC          14
+#define NPCX_I3C_INTMASKED_ERRWARN      15
+#define NPCX_I3C_INTMASKED_HDRMATCH     16
+#define NPCX_I3C_INTMASKED_CHANDLED     17
+#define NPCX_I3C_INTMASKED_EVENT        18
+#define NPCX_I3C_INTMASKED_TGTRST       19
+#define NPCX_I3C_ERRWARN_ORUN           0
+#define NPCX_I3C_ERRWARN_URUN           1
+#define NPCX_I3C_ERRWARN_URUNNACK       2
+#define NPCX_I3C_ERRWARN_TERM           3
+#define NPCX_I3C_ERRWARN_INVSTART       4
+#define NPCX_I3C_ERRWARN_SPAR           8
+#define NPCX_I3C_ERRWARN_HPAR           9
+#define NPCX_I3C_ERRWARN_HCRC           10
+#define NPCX_I3C_ERRWARN_S0S1           11
+#define NPCX_I3C_ERRWARN_OREAD          16
+#define NPCX_I3C_ERRWARN_OWRITE         17
+#define NPCX_I3C_DMACTRL_DMAFB          FIELD(0, 2)
+#define NPCX_I3C_DMACTRL_DMATB          FIELD(2, 2)
+#define NPCX_I3C_DATACTRL_FLUSHTB       0
+#define NPCX_I3C_DATACTRL_FLUSHFB       1
+#define NPCX_I3C_DATACTRL_UNLOCK        3
+#define NPCX_I3C_DATACTRL_TXTRIG        FIELD(4, 2)
+#define NPCX_I3C_DATACTRL_RXTRIG        FIELD(6, 2)
+#define NPCX_I3C_DATACTRL_TXCOUNT       FIELD(16, 6)
+#define NPCX_I3C_DATACTRL_RXCOUNT       FIELD(24, 6)
+#define NPCX_I3C_DATACTRL_TXFULL        30
+#define NPCX_I3C_DATACTRL_RXEMPTY       31
+#define NPCX_I3C_WDATAB_DATA            FIELD(0, 8)
+#define NPCX_I3C_WDATAB_END_B           8
+#define NPCX_I3C_WDATAB_END_A           16
+#define NPCX_I3C_WDATABE_DATA           FIELD(0, 8)
+#define NPCX_I3C_WDATAH_DATA0           FIELD(0, 8)
+#define NPCX_I3C_WDATAH_DATA1           FIELD(8, 8)
+#define NPCX_I3C_WDATAH_END             16
+#define NPCX_I3C_WDATAHE_DATA0          FIELD(0, 8)
+#define NPCX_I3C_WDATAHE_DATA1          FIELD(8, 8)
+#define NPCX_I3C_RDATAB_DATA            FIELD(0, 8)
+#define NPCX_I3C_RDATAH_DATA0           FIELD(0, 8)
+#define NPCX_I3C_RDATAH_DATA1           FIELD(8, 8)
+#define NPCX_I3C_CAPABILITIES2_MAPCNT   FIELD(0, 4)
+#define NPCX_I3C_CAPABILITIES2_I2C10B   4
+#define NPCX_I3C_CAPABILITIES2_I2CRST   5
+#define NPCX_I3C_CAPABILITIES2_I2CDEVID 6
+#define NPCX_I3C_CAPABILITIES2_DATA32   7
+#define NPCX_I3C_CAPABILITIES2_IBIEXT   8
+#define NPCX_I3C_CAPABILITIES2_IBIXREG  9
+#define NPCX_I3C_CAPABILITIES2_SMLANE   FIELD(12, 2)
+#define NPCX_I3C_CAPABILITIES2_V1_1     16
+#define NPCX_I3C_CAPABILITIES2_TGTRST   17
+#define NPCX_I3C_CAPABILITIES2_GROUP    FIELD(18, 2)
+#define NPCX_I3C_CAPABILITIES2_AASA     21
+#define NPCX_I3C_CAPABILITIES2_SSTSUB   22
+#define NPCX_I3C_CAPABILITIES2_SSTWR    23
+#define NPCX_I3C_CAPABILITIES_IDENA     FIELD(0, 2)
+#define NPCX_I3C_CAPABILITIES_IDREG     FIELD(2, 4)
+#define NPCX_I3C_CAPABILITIES_HDRSUPP   FIELD(6, 3)
+#define NPCX_I3C_CAPABILITIES_CNTLR     9
+#define NPCX_I3C_CAPABILITIES_SADDR     FIELD(10, 2)
+#define NPCX_I3C_CAPABILITIES_CCCHANDLE FIELD(12, 4)
+#define NPCX_I3C_CAPABILITIES_IBI_MR_HJ FIELD(16, 5)
+#define NPCX_I3C_CAPABILITIES_TIMECTRL  21
+#define NPCX_I3C_CAPABILITIES_EXTFIFO   FIELD(23, 3)
+#define NPCX_I3C_CAPABILITIES_FIFOTX    FIELD(26, 2)
+#define NPCX_I3C_CAPABILITIES_FIFORX    FIELD(28, 2)
+#define NPCX_I3C_CAPABILITIES_INT       30
+#define NPCX_I3C_CAPABILITIES_DMA       31
+#define NPCX_I3C_DYNADDR_DAVALID        0
+#define NPCX_I3C_DYNADDR_DADDR          FIELD(1, 7)
+#define NPCX_I3C_DYNADDR_CAUSE          FIELD(8, 3)
+#define NPCX_I3C_MAXLIMITS_MAXRD        FIELD(0, 12)
+#define NPCX_I3C_MAXLIMITS_MAXWR        FIELD(16, 12)
+#define NPCX_I3C_IDEXT_DCR              FIELD(8, 8)
+#define NPCX_I3C_IDEXT_BCR              FIELD(16, 8)
+#define NPCX_I3C_VENDORID_VID           FIELD(0, 15)
+#define NPCX_I3C_TCCLOCK_ACCURACY       FIELD(0, 8)
+#define NPCX_I3C_TCCLOCK_FREQ           FIELD(8, 8)
+#define NPCX_I3C_MSGLAST_MAPLAST        FIELD(0, 4)
+#define NPCX_I3C_MSGLAST_LASTSTATIC     4
+#define NPCX_I3C_MSGLAST_LASTGROUP      5
+#define NPCX_I3C_MSGLAST_LASTMODE       FIELD(6, 2)
+#define NPCX_I3C_MSGLAST_MAPLASTM1      FIELD(8, 4)
+#define NPCX_I3C_MSGLAST_LASTGROUPM1    13
+#define NPCX_I3C_MSGLAST_LASTMODE1      FIELD(14, 2)
+#define NPCX_I3C_MSGLAST_MAPLASTM2      FIELD(16, 4)
+#define NPCX_I3C_MSGLAST_LASTGROUPM2    21
+#define NPCX_I3C_MSGLAST_LASTMODE2      FIELD(22, 2)
+#define NPCX_I3C_RSTACTTIME_PERRSTTIM   FIELD(0, 8)
+#define NPCX_I3C_RSTACTTIME_SYSRSTTIM   FIELD(8, 8)
+#define NPCX_I3C_HDRCMD_CMD0            FIELD(0, 8)
+#define NPCX_I3C_HDRCMD_OVFL            30
+#define NPCX_I3C_HDRCMD_NEWCMD          31
+#define NPCX_I3C_GROUPDEF_GRP0ENA       0
+#define NPCX_I3C_GROUPDEF_GRP0DA        FIELD(1, 7)
+#define NPCX_I3C_GROUPDEF_GRP1ENA       8
+#define NPCX_I3C_GROUPDEF_GRP1DA        FIELD(9, 7)
+#define NPCX_I3C_GROUPDEF_GRP2ENA       16
+#define NPCX_I3C_GROUPDEF_GRP2DA        FIELD(17, 7)
+#define NPCX_I3C_MAPCTRL0_ENA           0
+#define NPCX_I3C_MAPCTRL0_DA            FIELD(1, 7)
+#define NPCX_I3C_MAPCTRL0_CAUSE         FIELD(8, 3)
+#define NPCX_I3C_MAPCTRLn_ENA           0
+#define NPCX_I3C_MAPCTRLn_ADDR          FIELD(1, 7)
+#define NPCX_I3C_MAPCTRLn_MAPSA         8
+#define NPCX_I3C_MAPCTRLn_NACK          12
+#define NPCX_I3C_MAPCTRLn_AUTO          13
+#define NPCX_I3C_MAPCTRLn_SLOT_PID      FIELD(14, 5)
+#define NPCX_I3C_IBIEXT1_CNT            FIELD(0, 3)
+#define NPCX_I3C_IBIEXT1_EXT1           FIELD(8, 8)
+#define NPCX_I3C_IBIEXT1_EXT2           FIELD(16, 8)
+#define NPCX_I3C_IBIEXT1_EXT3           FIELD(24, 8)
+#define NPCX_I3C_IBIEXT2_EXT4           FIELD(0, 8)
+#define NPCX_I3C_IBIEXT2_EXT5           FIELD(8, 8)
+#define NPCX_I3C_IBIEXT2_EXT6           FIELD(16, 8)
+#define NPCX_I3C_IBIEXT2_EXT7           FIELD(24, 8)
 
 /* MDMA Controller registers */
 struct mdma_reg {
@@ -1977,11 +2220,16 @@ struct mdma_reg {
 };
 
 /* MDMA register fields */
-#define NPCX_MDMA_CTL_MDMAEN    0
-#define NPCX_MDMA_CTL_MPD       1
-#define NPCX_MDMA_CTL_SIEN      8
-#define NPCX_MDMA_CTL_MPS       14
-#define NPCX_MDMA_CTL_TC        18
-#define NPCX_MDMA_TCNT_TFR_CNT  FIELD(0, 12)
+#define NPCX_MDMA_CTL_MDMAEN 0
+#define NPCX_MDMA_CTL_MPD    1
+#define NPCX_MDMA_CTL_SIEN   8
+#define NPCX_MDMA_CTL_MPS    14
+#define NPCX_MDMA_CTL_TC     18
+
+/* Channel 0/1 Transfer Count Register (MDMA_TCNT0/MDMA_TCNT1) */
+#define NPCX_MDMA_TCNT_TFR_CNT FIELD(0, 13)
+
+/* Channel 0/1 Current Transfer Count Register (MDMA_CTCNT0/MDMA_CTCNT1) */
+#define NPCX_MDMA_CTCNT_CURRENT_TFR_CNT FIELD(0, 13)
 
 #endif /* _NUVOTON_NPCX_REG_DEF_H */
diff --git a/soc/arm/nuvoton_npcx/common/registers.c b/soc/arm/nuvoton_npcx/common/registers.c
index 00ee142b1..e54775bc6 100644
--- a/soc/arm/nuvoton_npcx/common/registers.c
+++ b/soc/arm/nuvoton_npcx/common/registers.c
@@ -199,8 +199,8 @@ NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[2], 0x00c);
 NPCX_REG_OFFSET_CHECK(swrst_reg, SWRST_CTL[3], 0x010);
 
 /* I3C register structure check */
-NPCX_REG_SIZE_CHECK(i3c_reg, 0x0E8);
-NPCX_REG_OFFSET_CHECK(i3c_reg, MCONFIG, 0x000);
+NPCX_REG_SIZE_CHECK(i3c_reg, 0x148);
+NPCX_REG_OFFSET_CHECK(i3c_reg, MCONFIG, 0x000); /* Controller register */
 NPCX_REG_OFFSET_CHECK(i3c_reg, MCTRL, 0x084);
 NPCX_REG_OFFSET_CHECK(i3c_reg, IBIRULES, 0x08C);
 NPCX_REG_OFFSET_CHECK(i3c_reg, MINTSET, 0x090);
@@ -217,6 +217,16 @@ NPCX_REG_OFFSET_CHECK(i3c_reg, MRDATAH, 0x0C8);
 NPCX_REG_OFFSET_CHECK(i3c_reg, MWMSG_DDR, 0x0D8);
 NPCX_REG_OFFSET_CHECK(i3c_reg, MRMSG_DDR, 0x0DC);
 NPCX_REG_OFFSET_CHECK(i3c_reg, MDYNADDR, 0x0E4);
+NPCX_REG_OFFSET_CHECK(i3c_reg, CONFIG, 0x004); /* Target register */
+NPCX_REG_OFFSET_CHECK(i3c_reg, STATUS, 0x008);
+NPCX_REG_OFFSET_CHECK(i3c_reg, CTRL, 0x00C);
+NPCX_REG_OFFSET_CHECK(i3c_reg, INTSET, 0x010);
+NPCX_REG_OFFSET_CHECK(i3c_reg, INTCLR, 0x014);
+NPCX_REG_OFFSET_CHECK(i3c_reg, INTMASKED, 0x018);
+NPCX_REG_OFFSET_CHECK(i3c_reg, ERRWARN, 0x01C);
+NPCX_REG_OFFSET_CHECK(i3c_reg, DMACTRL, 0x020);
+NPCX_REG_OFFSET_CHECK(i3c_reg, DATACTRL, 0x02C);
+NPCX_REG_OFFSET_CHECK(i3c_reg, IBIEXT2, 0x144);
 
 /* MDMA register structure check */
 NPCX_REG_SIZE_CHECK(mdma_reg, 0x03C);
diff --git a/soc/arm/nuvoton_npcx/common/scfg.c b/soc/arm/nuvoton_npcx/common/scfg.c
index 6dac027cb..6d3142e7a 100644
--- a/soc/arm/nuvoton_npcx/common/scfg.c
+++ b/soc/arm/nuvoton_npcx/common/scfg.c
@@ -131,6 +131,21 @@ void npcx_host_interface_sel(enum npcx_hif_type hif_type)
 	SET_FIELD(inst_scfg->DEVCNT, NPCX_DEVCNT_HIF_TYP_SEL_FIELD, hif_type);
 }
 
+void npcx_i3c_target_sel(uint8_t module_id, bool enable)
+{
+#if defined(CONFIG_SOC_SERIES_NPCX4)
+	struct scfg_reg *inst_scfg = HAL_SFCG_INST();
+
+	if (enable == true) {
+		inst_scfg->DEV_CTL3 |= NPCX_DEV_CTL3_I3C_MODE_BIT(module_id);
+	} else {
+		inst_scfg->DEV_CTL3 &= ~NPCX_DEV_CTL3_I3C_MODE_BIT(module_id);
+	}
+#else
+	LOG_ERR("%s: i3c target select not supported yet", __func__);
+#endif
+}
+
 void npcx_dbg_freeze_enable(bool enable)
 {
 	const uintptr_t dbg_base = npcx_scfg_cfg.base_dbg;
diff --git a/soc/arm/nuvoton_npcx/common/soc_pins.h b/soc/arm/nuvoton_npcx/common/soc_pins.h
index 93b5d601c..143aad6b5 100644
--- a/soc/arm/nuvoton_npcx/common/soc_pins.h
+++ b/soc/arm/nuvoton_npcx/common/soc_pins.h
@@ -85,6 +85,15 @@ bool npcx_lvol_get_detect_level(int lvol_ctrl, int lvol_bit);
  */
 void npcx_host_interface_sel(enum npcx_hif_type hif_type);
 
+/**
+ * @brief Select the I3C module controller or target mode for the mdma
+ *        module operation.
+ *
+ * @param module i3c device
+ * @param enable true to enable target mode, false to controller mode.
+ */
+void npcx_i3c_target_sel(uint8_t module, bool enable);
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.17.1

